{"version":3,"file":"48495.5896abf3.iframe.bundle.js","mappings":";;;;;;;AA8TA;;;;;;;AAaA;;;;;;;AAWA","sources":["webpack://@legal-and-general/canopy/./node_modules/@storybook/angular/dist/_browser-chunks/chunk-6CHBWP5J.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: !0 });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  for (var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target, i = decorators.length - 1, decorator; i >= 0; i--)\n    (decorator = decorators[i]) && (result = (kind ? decorator(target, key, result) : decorator(result)) || result);\n  return kind && result && __defProp(target, key, result), result;\n}, __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);\n\n// src/client/render.ts\nvar render_exports = {};\n__export(render_exports, {\n  render: () => render,\n  renderToCanvas: () => renderToCanvas,\n  rendererFactory: () => rendererFactory\n});\nimport \"@angular/compiler\";\n\n// src/client/angular-beta/AbstractRenderer.ts\nimport { bootstrapApplication } from \"@angular/platform-browser\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { stringify } from \"telejson\";\n\n// src/client/angular-beta/utils/NgComponentAnalyzer.ts\nimport {\n  Component,\n  Directive,\n  Input,\n  Output,\n  Pipe,\n  \\u0275ReflectionCapabilities as ReflectionCapabilities\n} from \"@angular/core\";\nvar reflectionCapabilities = new ReflectionCapabilities(), getComponentInputsOutputs = (component) => {\n  let componentMetadata = getComponentDecoratorMetadata(component), componentPropsMetadata = getComponentPropsDecoratorMetadata(component), initialValue = {\n    inputs: [],\n    outputs: []\n  };\n  return componentMetadata && componentMetadata.inputs && initialValue.inputs.push(\n    ...componentMetadata.inputs.map((i) => ({\n      propName: typeof i == \"string\" ? i : i.name,\n      templateName: typeof i == \"string\" ? i : i.alias\n    }))\n  ), componentMetadata && componentMetadata.outputs && initialValue.outputs.push(\n    ...componentMetadata.outputs.map((i) => ({ propName: i, templateName: i }))\n  ), componentPropsMetadata ? Object.entries(componentPropsMetadata).reduce((previousValue, [propertyName, values]) => {\n    let value = values.find((v) => v instanceof Input || v instanceof Output);\n    if (value instanceof Input) {\n      let inputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      }, previousInputsFiltered = previousValue.inputs.filter(\n        (i) => i.templateName !== propertyName\n      );\n      return {\n        ...previousValue,\n        inputs: [...previousInputsFiltered, inputToAdd]\n      };\n    }\n    if (value instanceof Output) {\n      let outputToAdd = {\n        propName: propertyName,\n        templateName: value.bindingPropertyName ?? value.alias ?? propertyName\n      }, previousOutputsFiltered = previousValue.outputs.filter(\n        (i) => i.templateName !== propertyName\n      );\n      return {\n        ...previousValue,\n        outputs: [...previousOutputsFiltered, outputToAdd]\n      };\n    }\n    return previousValue;\n  }, initialValue) : initialValue;\n};\nvar isComponent = (component) => component ? (reflectionCapabilities.annotations(component) || []).some((d) => d instanceof Component) : !1;\nvar getComponentPropsDecoratorMetadata = (component) => reflectionCapabilities.propMetadata(component), getComponentDecoratorMetadata = (component) => reflectionCapabilities.annotations(component).reverse().find((d) => d instanceof Component);\n\n// src/client/angular-beta/ComputesTemplateFromComponent.ts\nvar isValidIdentifier = (name) => /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name), formatPropInTemplate = (propertyName) => isValidIdentifier(propertyName) ? propertyName : `this['${propertyName}']`, separateInputsOutputsAttributes = (ngComponentInputsOutputs, props = {}) => {\n  let inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName), outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);\n  return {\n    inputs,\n    outputs,\n    otherProps: Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k))\n  };\n}, computesTemplateFromComponent = (component, initialProps, innerTemplate = \"\") => {\n  let ngComponentMetadata = getComponentDecoratorMetadata(component), ngComponentInputsOutputs = getComponentInputsOutputs(component);\n  if (!ngComponentMetadata.selector)\n    return '<ng-container *ngComponentOutlet=\"storyComponent\"></ng-container>';\n  let { inputs: initialInputs, outputs: initialOutputs } = separateInputsOutputsAttributes(\n    ngComponentInputsOutputs,\n    initialProps\n  ), templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map((i) => `[${i}]=\"${formatPropInTemplate(i)}\"`).join(\" \")}` : \"\", templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})=\"${formatPropInTemplate(i)}($event)\"`).join(\" \")}` : \"\";\n  return buildTemplate(\n    ngComponentMetadata.selector,\n    innerTemplate,\n    templateInputs,\n    templateOutputs\n  );\n};\nfunction stringifyCircular(obj) {\n  let seen = /* @__PURE__ */ new Set();\n  return JSON.stringify(obj, (key, value) => {\n    if (typeof value == \"object\" && value !== null) {\n      if (seen.has(value))\n        return \"[Circular]\";\n      seen.add(value);\n    }\n    return value;\n  });\n}\nvar createAngularInputProperty = ({\n  propertyName,\n  value,\n  argType\n}) => {\n  let templateValue;\n  switch (typeof value) {\n    case \"string\":\n      templateValue = `'${value}'`;\n      break;\n    case \"object\":\n      templateValue = stringifyCircular(value).replace(/'/g, \"\\u2019\").replace(/\\\\\"/g, \"\\u201D\").replace(/\"([^-\"]+)\":/g, \"$1: \").replace(/\"/g, \"'\").replace(/\\u2019/g, \"\\\\'\").replace(/\\u201D/g, \"\\\\'\").split(\",\").join(\", \");\n      break;\n    default:\n      templateValue = value;\n  }\n  return `[${propertyName}]=\"${templateValue}\"`;\n}, computesTemplateSourceFromComponent = (component, initialProps, argTypes) => {\n  let ngComponentMetadata = getComponentDecoratorMetadata(component);\n  if (!ngComponentMetadata)\n    return null;\n  if (!ngComponentMetadata.selector)\n    return `<ng-container *ngComponentOutlet=\"${component.name}\"></ng-container>`;\n  let ngComponentInputsOutputs = getComponentInputsOutputs(component), { inputs: initialInputs, outputs: initialOutputs } = separateInputsOutputsAttributes(\n    ngComponentInputsOutputs,\n    initialProps\n  ), templateInputs = initialInputs.length > 0 ? ` ${initialInputs.map(\n    (propertyName) => createAngularInputProperty({\n      propertyName,\n      value: initialProps[propertyName],\n      argType: argTypes?.[propertyName]\n    })\n  ).join(\" \")}` : \"\", templateOutputs = initialOutputs.length > 0 ? ` ${initialOutputs.map((i) => `(${i})=\"${formatPropInTemplate(i)}($event)\"`).join(\" \")}` : \"\";\n  return buildTemplate(ngComponentMetadata.selector, \"\", templateInputs, templateOutputs);\n}, buildTemplate = (selector, innerTemplate, inputs, outputs) => {\n  let voidElements = [\n    \"area\",\n    \"base\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\"\n  ], firstSelector = selector.split(\",\")[0];\n  return [\n    [/(^.*?)(?=[,])/, \"$1\"],\n    [/(^\\..+)/, \"div$1\"],\n    [/(^\\[.+?])/, \"div$1\"],\n    [/([\\w[\\]]+)(\\s*,[\\w\\s-[\\],]+)+/, \"$1\"],\n    [/#([\\w-]+)/, ' id=\"$1\"'],\n    [/((\\.[\\w-]+)+)/, (_, c) => ` class=\"${c.split`.`.join` `.trim()}\"`],\n    [/(\\[.+?])/g, (_, a) => ` ${a.slice(1, -1)}`],\n    [\n      /([\\S]+)(.*)/,\n      (template, elementSelector) => voidElements.some((element) => elementSelector === element) ? template.replace(/([\\S]+)(.*)/, `<$1$2${inputs}${outputs} />`) : template.replace(/([\\S]+)(.*)/, `<$1$2${inputs}${outputs}>${innerTemplate}</$1>`)\n    ]\n  ].reduce(\n    (prevSelector, [searchValue, replacer]) => prevSelector.replace(searchValue, replacer),\n    firstSelector\n  );\n};\n\n// src/client/angular-beta/StorybookWrapperComponent.ts\nimport {\n  ChangeDetectorRef,\n  Component as Component3,\n  Inject,\n  NgModule as NgModule2,\n  ViewChild,\n  ViewContainerRef\n} from \"@angular/core\";\nimport { map, skip } from \"rxjs/operators\";\n\n// src/client/angular-beta/StorybookProvider.ts\nimport { InjectionToken, NgZone } from \"@angular/core\";\nimport { Observable } from \"rxjs\";\nvar STORY_PROPS = new InjectionToken(\"STORY_PROPS\"), storyPropsProvider = (storyProps$) => ({\n  provide: STORY_PROPS,\n  useFactory: storyDataFactory(storyProps$.asObservable()),\n  deps: [NgZone]\n});\nfunction storyDataFactory(data) {\n  return (ngZone) => new Observable((subscriber) => {\n    let sub = data.subscribe(\n      (v) => {\n        ngZone.run(() => subscriber.next(v));\n      },\n      (err) => {\n        ngZone.run(() => subscriber.error(err));\n      },\n      () => {\n        ngZone.run(() => subscriber.complete());\n      }\n    );\n    return () => {\n      sub.unsubscribe();\n    };\n  });\n}\n\n// src/client/angular-beta/utils/PropertyExtractor.ts\nimport { CommonModule } from \"@angular/common\";\nimport {\n  Component as Component2,\n  Directive as Directive2,\n  Injectable,\n  InjectionToken as InjectionToken2,\n  Input as Input2,\n  Output as Output2,\n  Pipe as Pipe2,\n  \\u0275ReflectionCapabilities as ReflectionCapabilities3,\n  VERSION\n} from \"@angular/core\";\nimport { BrowserModule } from \"@angular/platform-browser\";\nimport { dedent } from \"ts-dedent\";\n\n// src/client/angular-beta/utils/NgModulesAnalyzer.ts\nimport { NgModule, \\u0275ReflectionCapabilities as ReflectionCapabilities2 } from \"@angular/core\";\nvar reflectionCapabilities2 = new ReflectionCapabilities2(), isComponentAlreadyDeclared = (componentToFind, moduleDeclarations, moduleImports) => moduleDeclarations && moduleDeclarations.flat().some((declaration) => declaration === componentToFind) ? !0 : moduleImports ? moduleImports.flat().some((importItem) => {\n  let extractedNgModuleMetadata = extractNgModuleMetadata(importItem);\n  return extractedNgModuleMetadata ? isComponentAlreadyDeclared(\n    componentToFind,\n    extractedNgModuleMetadata.declarations,\n    extractedNgModuleMetadata.imports\n  ) : !1;\n}) : !1, extractNgModuleMetadata = (importItem) => {\n  let target = importItem && importItem.ngModule ? importItem.ngModule : importItem, decorators = reflectionCapabilities2.annotations(target);\n  if (!decorators || decorators.length === 0)\n    return null;\n  let ngModuleDecorator = decorators.find(\n    (decorator) => decorator instanceof NgModule\n  );\n  return ngModuleDecorator || null;\n};\n\n// src/client/angular-beta/utils/PropertyExtractor.ts\nvar reflectionCapabilities3 = new ReflectionCapabilities3(), REMOVED_MODULES = new InjectionToken2(\"REMOVED_MODULES\"), uniqueArray = (arr) => arr.flat(Number.MAX_VALUE).filter(Boolean).filter((value, index, self) => self.indexOf(value) === index), _PropertyExtractor = class _PropertyExtractor {\n  constructor(metadata, component) {\n    this.metadata = metadata;\n    this.component = component;\n    this.declarations = [];\n    /**\n     * Analyze NgModule Metadata\n     *\n     * - Removes Restricted Imports\n     * - Extracts providers from ModuleWithProviders\n     * - Returns a new NgModuleMetadata object\n     */\n    this.analyzeMetadata = async (metadata) => {\n      let declarations = [...metadata?.declarations || []], providers = [...metadata?.providers || []], applicationProviders = [], imports = await Promise.all(\n        [...metadata?.imports || []].map(async (imported) => {\n          let [isRestricted, restrictedProviders] = await _PropertyExtractor.analyzeRestricted(imported);\n          return isRestricted ? (applicationProviders.unshift(restrictedProviders || []), null) : imported;\n        })\n      ).then((results) => results.filter(Boolean));\n      return { ...metadata, imports, providers, applicationProviders, declarations };\n    };\n  }\n  // With the new way of mounting standalone components to the DOM via bootstrapApplication API,\n  // we should now pass ModuleWithProviders to the providers array of the bootstrapApplication function.\n  static warnImportsModuleWithProviders(propertyExtractor) {\n    propertyExtractor.imports.some(\n      (importedModule) => \"ngModule\" in importedModule\n    ) && console.warn(\n      dedent(\n        `\n          Storybook Warning: \n          moduleMetadata property 'imports' contains one or more ModuleWithProviders, likely the result of a 'Module.forRoot()'-style call.\n          In Storybook 7.0 we use Angular's new 'bootstrapApplication' API to mount the component to the DOM, which accepts a list of providers to set up application-wide providers.\n          Use the 'applicationConfig' decorator from '@storybook/angular' to pass your ModuleWithProviders to the 'providers' property in combination with the importProvidersFrom helper function from '@angular/core' to extract all the necessary providers.\n          Visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information\n          `\n      )\n    );\n  }\n  async init() {\n    let analyzed = await this.analyzeMetadata(this.metadata);\n    if (this.imports = uniqueArray([CommonModule, analyzed.imports]), this.providers = uniqueArray(analyzed.providers), this.applicationProviders = uniqueArray(analyzed.applicationProviders), this.declarations = uniqueArray(analyzed.declarations), this.component) {\n      let { isDeclarable, isStandalone } = _PropertyExtractor.analyzeDecorators(this.component), isDeclared = isComponentAlreadyDeclared(\n        this.component,\n        analyzed.declarations,\n        this.imports\n      );\n      isStandalone ? this.imports.push(this.component) : isDeclarable && !isDeclared && this.declarations.push(this.component);\n    }\n  }\n};\n_PropertyExtractor.analyzeRestricted = async (ngModule) => {\n  if (ngModule === BrowserModule)\n    return console.warn(\n      dedent`\n          Storybook Warning:\n          You have imported the \"BrowserModule\", which is not necessary anymore. \n          In Storybook v7.0 we are using Angular's new bootstrapApplication API to mount an Angular application to the DOM.\n          Note that the BrowserModule providers are automatically included when starting an application with bootstrapApplication()\n          Please remove the \"BrowserModule\" from the list of imports in your moduleMetadata definition to remove this warning.\n        `\n    ), [!0];\n  try {\n    let animations = await import(\"@angular/platform-browser/animations\");\n    if (ngModule === animations.BrowserAnimationsModule)\n      return console.warn(\n        dedent`\n            Storybook Warning:\n            You have added the \"BrowserAnimationsModule\" to the list of \"imports\" in your moduleMetadata definition of your Story.\n            In Storybook 7.0 we use Angular's new 'bootstrapApplication' API to mount the component to the DOM, which accepts a list of providers to set up application-wide providers.\n            Use the 'applicationConfig' decorator from '@storybook/angular' and add the \"provideAnimations\" function to the list of \"providers\".\n            If your Angular version does not support \"provide-like\" functions, use the helper function importProvidersFrom instead to set up animations. For this case, please add \"importProvidersFrom(BrowserAnimationsModule)\" to the list of providers of your applicationConfig definition.\n            Please visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information.\n          `\n      ), [!0, animations.provideAnimations()];\n    if (ngModule === animations.NoopAnimationsModule)\n      return console.warn(\n        dedent`\n            Storybook Warning:\n            You have added the \"NoopAnimationsModule\" to the list of \"imports\" in your moduleMetadata definition of your Story.\n            In Storybook v7.0 we are using Angular's new bootstrapApplication API to mount an Angular application to the DOM, which accepts a list of providers to set up application-wide providers.\n            Use the 'applicationConfig' decorator from '@storybook/angular' and add the \"provideNoopAnimations\" function to the list of \"providers\".\n            If your Angular version does not support \"provide-like\" functions, use the helper function importProvidersFrom instead to set up noop animations and to extract all necessary providers from NoopAnimationsModule. For this case, please add \"importProvidersFrom(NoopAnimationsModule)\" to the list of providers of your applicationConfig definition.\n            Please visit https://angular.io/guide/standalone-components#configuring-dependency-injection for more information.\n          `\n      ), [!0, animations.provideNoopAnimations()];\n  } catch {\n    return [!1];\n  }\n  return [!1];\n}, _PropertyExtractor.analyzeDecorators = (component) => {\n  let decorators = reflectionCapabilities3.annotations(component), isComponent2 = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Component\")), isDirective = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Directive\")), isPipe = decorators.some((d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Pipe\")), isDeclarable = isComponent2 || isDirective || isPipe, isStandalone = (isComponent2 || isDirective) && [...decorators].reverse().find(\n    (d) => _PropertyExtractor.isDecoratorInstanceOf(d, \"Component\") || _PropertyExtractor.isDecoratorInstanceOf(d, \"Directive\")\n  )?.standalone;\n  return isStandalone === void 0 && (isStandalone = !!(VERSION.major && Number(VERSION.major) >= 19)), { isDeclarable, isStandalone };\n}, _PropertyExtractor.isDecoratorInstanceOf = (decorator, name) => {\n  let factory;\n  switch (name) {\n    case \"Component\":\n      factory = Component2;\n      break;\n    case \"Directive\":\n      factory = Directive2;\n      break;\n    case \"Pipe\":\n      factory = Pipe2;\n      break;\n    case \"Injectable\":\n      factory = Injectable;\n      break;\n    case \"Input\":\n      factory = Input2;\n      break;\n    case \"Output\":\n      factory = Output2;\n      break;\n    default:\n      throw new Error(`Unknown decorator type: ${name}`);\n  }\n  return decorator instanceof factory || decorator.ngMetadataName === name;\n};\nvar PropertyExtractor = _PropertyExtractor;\n\n// src/client/angular-beta/StorybookWrapperComponent.ts\nvar getNonInputsOutputsProps = (ngComponentInputsOutputs, props = {}) => {\n  let inputs = ngComponentInputsOutputs.inputs.filter((i) => i.templateName in props).map((i) => i.templateName), outputs = ngComponentInputsOutputs.outputs.filter((o) => o.templateName in props).map((o) => o.templateName);\n  return Object.keys(props).filter((k) => ![...inputs, ...outputs].includes(k));\n}, createStorybookWrapperComponent = ({\n  selector,\n  template,\n  storyComponent,\n  styles,\n  moduleMetadata,\n  initialProps,\n  analyzedMetadata\n}) => {\n  let viewChildSelector = storyComponent ?? \"__storybook-noop\", { imports, declarations, providers } = analyzedMetadata, StorybookComponentModule = class {\n  };\n  StorybookComponentModule = __decorateClass([\n    NgModule2({\n      declarations,\n      imports,\n      exports: [...declarations, ...imports]\n    })\n  ], StorybookComponentModule), PropertyExtractor.warnImportsModuleWithProviders(analyzedMetadata);\n  let StorybookWrapperComponent = class {\n    constructor(storyProps$, changeDetectorRef) {\n      this.storyProps$ = storyProps$;\n      this.changeDetectorRef = changeDetectorRef;\n      // Used in case of a component without selector\n      this.storyComponent = storyComponent ?? \"\";\n    }\n    ngOnInit() {\n      this.storyWrapperPropsSubscription = this.storyProps$.subscribe((storyProps = {}) => {\n        Object.assign(this, storyProps), this.changeDetectorRef.detectChanges(), this.changeDetectorRef.markForCheck();\n      });\n    }\n    ngAfterViewInit() {\n      if (this.storyComponentElementRef) {\n        let ngComponentInputsOutputs = getComponentInputsOutputs(storyComponent);\n        getNonInputsOutputsProps(ngComponentInputsOutputs, initialProps).forEach((p) => {\n          this.storyComponentElementRef[p] = initialProps[p];\n        }), this.storyComponentViewContainerRef.injector.get(ChangeDetectorRef).markForCheck(), this.changeDetectorRef.detectChanges(), this.storyComponentPropsSubscription = this.storyProps$.pipe(\n          skip(1),\n          map((props) => getNonInputsOutputsProps(ngComponentInputsOutputs, props).reduce((acc, p) => ({ ...acc, [p]: props[p] }), {}))\n        ).subscribe((props) => {\n          Object.assign(this.storyComponentElementRef, props), this.storyComponentViewContainerRef.injector.get(ChangeDetectorRef).markForCheck(), this.changeDetectorRef.detectChanges();\n        });\n      }\n    }\n    ngOnDestroy() {\n      this.storyComponentPropsSubscription != null && this.storyComponentPropsSubscription.unsubscribe(), this.storyWrapperPropsSubscription != null && this.storyWrapperPropsSubscription.unsubscribe();\n    }\n  };\n  return __decorateClass([\n    ViewChild(viewChildSelector, { static: !0 })\n  ], StorybookWrapperComponent.prototype, \"storyComponentElementRef\", 2), __decorateClass([\n    ViewChild(viewChildSelector, { read: ViewContainerRef, static: !0 })\n  ], StorybookWrapperComponent.prototype, \"storyComponentViewContainerRef\", 2), StorybookWrapperComponent = __decorateClass([\n    Component3({\n      selector,\n      template,\n      standalone: !0,\n      imports: [StorybookComponentModule],\n      providers,\n      styles,\n      schemas: moduleMetadata.schemas\n    }),\n    __decorateParam(0, Inject(STORY_PROPS)),\n    __decorateParam(1, Inject(ChangeDetectorRef))\n  ], StorybookWrapperComponent), StorybookWrapperComponent;\n};\n\n// src/client/angular-beta/StorybookModule.ts\nvar getApplication = ({\n  storyFnAngular,\n  component,\n  targetSelector,\n  analyzedMetadata\n}) => {\n  let { props, styles, moduleMetadata = {} } = storyFnAngular, { template } = storyFnAngular;\n  return !!hasNoTemplate(template) && component && (template = computesTemplateFromComponent(component, props, \"\")), createStorybookWrapperComponent({\n    moduleMetadata,\n    selector: targetSelector,\n    template,\n    storyComponent: component,\n    styles,\n    initialProps: props,\n    analyzedMetadata\n  });\n};\nfunction hasNoTemplate(template) {\n  return template == null;\n}\n\n// src/client/angular-beta/utils/BootstrapQueue.ts\nvar queue = [], isProcessing = !1, resetCompiledComponents = async () => {\n  try {\n    let { \\u0275resetCompiledComponents } = await import(\"@angular/core\");\n    \\u0275resetCompiledComponents();\n  } catch {\n  }\n}, queueBootstrapping = (fn) => new Promise((resolve, reject) => {\n  queue.push(() => fn().then(resolve).catch(reject)), isProcessing || processQueue();\n}), processQueue = async () => {\n  for (isProcessing = !0; queue.length > 0; ) {\n    let bootstrappingFn = queue.shift();\n    bootstrappingFn && (await bootstrappingFn(), await resetCompiledComponents());\n  }\n  isProcessing = !1;\n};\n\n// src/client/angular-beta/utils/Zoneless.ts\nvar getProvideZonelessChangeDetectionFn = async () => {\n  let angularCore = await import(\"@angular/core\");\n  return \"provideExperimentalZonelessChangeDetection\" in angularCore ? angularCore.provideExperimentalZonelessChangeDetection : \"provideZonelessChangeDetection\" in angularCore ? angularCore.provideZonelessChangeDetection : null;\n};\n\n// src/client/angular-beta/AbstractRenderer.ts\nvar applicationRefs = /* @__PURE__ */ new Map(), STORY_UID_ATTRIBUTE = \"data-sb-story-uid\", AbstractRenderer = class {\n  constructor() {\n    this.previousStoryRenderInfo = /* @__PURE__ */ new Map();\n  }\n  /** Wait and destroy the platform */\n  static resetApplications(domNode) {\n    applicationRefs.forEach((appRef, appDOMNode) => {\n      !appRef.destroyed && (!domNode || appDOMNode === domNode) && appRef.destroy();\n    });\n  }\n  /**\n   * Bootstrap main angular module with main component or send only new `props` with storyProps$\n   *\n   * @param storyFnAngular {StoryFnAngularReturnType}\n   * @param forced {boolean} If :\n   *\n   *   - True render will only use the StoryFn `props' in storyProps observable that will update sotry's\n   *       component/template properties. Improves performance without reloading the whole\n   *       module&component if props changes\n   *   - False fully recharges or initializes angular module & component\n   *\n   * @param component {Component}\n   */\n  async render({\n    storyFnAngular,\n    forced,\n    component,\n    targetDOMNode\n  }) {\n    let targetSelector = this.generateTargetSelectorFromStoryId(targetDOMNode.id), newStoryProps$ = new BehaviorSubject(storyFnAngular.props);\n    if (!this.fullRendererRequired({\n      targetDOMNode,\n      storyFnAngular,\n      moduleMetadata: {\n        ...storyFnAngular.moduleMetadata\n      },\n      forced\n    })) {\n      this.storyProps$.next(storyFnAngular.props);\n      return;\n    }\n    await this.beforeFullRender(targetDOMNode), this.storyProps$ && this.storyProps$.complete(), this.storyProps$ = newStoryProps$, this.initAngularRootElement(targetDOMNode, targetSelector);\n    let analyzedMetadata = new PropertyExtractor(storyFnAngular.moduleMetadata, component);\n    await analyzedMetadata.init();\n    let storyUid = this.generateStoryUIdFromRawStoryUid(\n      targetDOMNode.getAttribute(STORY_UID_ATTRIBUTE)\n    ), componentSelector = storyUid !== null ? `${targetSelector}[${storyUid}]` : targetSelector;\n    storyUid !== null && targetDOMNode.querySelector(targetSelector).toggleAttribute(storyUid, !0);\n    let application = getApplication({\n      storyFnAngular,\n      component,\n      targetSelector: componentSelector,\n      analyzedMetadata\n    }), providers = [\n      storyPropsProvider(newStoryProps$),\n      ...analyzedMetadata.applicationProviders,\n      ...storyFnAngular.applicationConfig?.providers ?? []\n    ];\n    if (STORYBOOK_ANGULAR_OPTIONS?.experimentalZoneless) {\n      let provideZonelessChangeDetectionFn = await getProvideZonelessChangeDetectionFn();\n      if (provideZonelessChangeDetectionFn)\n        providers.unshift(provideZonelessChangeDetectionFn());\n      else\n        throw new Error(\"Zoneless change detection requires Angular 18 or higher\");\n    }\n    let applicationRef = await queueBootstrapping(() => bootstrapApplication(application, {\n      ...storyFnAngular.applicationConfig,\n      providers\n    }));\n    applicationRefs.set(targetDOMNode, applicationRef);\n  }\n  /**\n   * Only ASCII alphanumerics can be used as HTML tag name. https://html.spec.whatwg.org/#elements-2\n   *\n   * Therefore, stories break when non-ASCII alphanumerics are included in target selector.\n   * https://github.com/storybookjs/storybook/issues/15147\n   *\n   * This method returns storyId when it doesn't contain any non-ASCII alphanumerics. Otherwise, it\n   * generates a valid HTML tag name from storyId by removing non-ASCII alphanumerics from storyId,\n   * prefixing \"sb-\", and suffixing \"-component\"\n   *\n   * @memberof AbstractRenderer\n   * @protected\n   */\n  generateTargetSelectorFromStoryId(id) {\n    let invalidHtmlTag = /[^A-Za-z0-9-]/g;\n    return invalidHtmlTag.test(id) ? `sb-${id.replace(invalidHtmlTag, \"\")}-component` : id;\n  }\n  /**\n   * Angular is unable to handle components that have selectors with accented attributes.\n   *\n   * Therefore, stories break when meta's title contains accents.\n   * https://github.com/storybookjs/storybook/issues/29132\n   *\n   * This method filters accents from a given raw id. For example, this method converts\n   * 'Example/Button with an \"Ã©\" accent' into 'Example/Button with an \"e\" accent'.\n   *\n   * @memberof AbstractRenderer\n   * @protected\n   */\n  generateStoryUIdFromRawStoryUid(rawStoryUid) {\n    if (rawStoryUid === null)\n      return rawStoryUid;\n    let accentCharacters = /[\\u0300-\\u036f]/g;\n    return rawStoryUid.normalize(\"NFD\").replace(accentCharacters, \"\");\n  }\n  /** Adds DOM element that angular will use as bootstrap component. */\n  initAngularRootElement(targetDOMNode, targetSelector) {\n    targetDOMNode.innerHTML = \"\", targetDOMNode.appendChild(document.createElement(targetSelector));\n  }\n  fullRendererRequired({\n    targetDOMNode,\n    storyFnAngular,\n    moduleMetadata,\n    forced\n  }) {\n    let previousStoryRenderInfo = this.previousStoryRenderInfo.get(targetDOMNode), currentStoryRender = {\n      storyFnAngular,\n      moduleMetadataSnapshot: stringify(moduleMetadata, { maxDepth: 50 })\n    };\n    return this.previousStoryRenderInfo.set(targetDOMNode, currentStoryRender), // check `forceRender` of story RenderContext\n    !forced || // if it's the first rendering and storyProps$ is not init\n    !this.storyProps$ || !!storyFnAngular?.template && previousStoryRenderInfo?.storyFnAngular?.template !== storyFnAngular.template ? !0 : currentStoryRender.moduleMetadataSnapshot !== previousStoryRenderInfo?.moduleMetadataSnapshot;\n  }\n};\n\n// src/client/angular-beta/CanvasRenderer.ts\nvar CanvasRenderer = class _CanvasRenderer extends AbstractRenderer {\n  async render(options) {\n    await super.render(options);\n  }\n  async beforeFullRender() {\n    _CanvasRenderer.resetApplications();\n  }\n};\n\n// src/client/angular-beta/DocsRenderer.ts\nimport { DOCS_RENDERED, STORY_CHANGED } from \"storybook/internal/core-events\";\nimport { addons } from \"storybook/preview-api\";\n\n// src/client/angular-beta/utils/StoryUID.ts\nvar storyCounts = /* @__PURE__ */ new Map(), getNextStoryUID = (storyId) => {\n  storyCounts.has(storyId) || storyCounts.set(storyId, -1);\n  let count = storyCounts.get(storyId) + 1;\n  return storyCounts.set(storyId, count), `${storyId}-${count}`;\n};\n\n// src/client/angular-beta/DocsRenderer.ts\nvar DocsRenderer = class _DocsRenderer extends AbstractRenderer {\n  async render(options) {\n    let channel = addons.getChannel();\n    channel.once(STORY_CHANGED, async () => {\n      await _DocsRenderer.resetApplications();\n    }), channel.once(DOCS_RENDERED, async () => {\n      await _DocsRenderer.resetApplications();\n    }), await super.render({ ...options, forced: !1 });\n  }\n  async beforeFullRender(domNode) {\n    _DocsRenderer.resetApplications(domNode);\n  }\n  initAngularRootElement(targetDOMNode, targetSelector) {\n    super.initAngularRootElement(targetDOMNode, targetSelector), targetDOMNode.setAttribute(STORY_UID_ATTRIBUTE, getNextStoryUID(targetDOMNode.id));\n  }\n};\n\n// src/client/angular-beta/RendererFactory.ts\nvar RendererFactory = class {\n  constructor() {\n    this.rendererMap = /* @__PURE__ */ new Map();\n  }\n  async getRendererInstance(targetDOMNode) {\n    let targetId = targetDOMNode.id;\n    if (targetDOMNode === null)\n      return null;\n    let renderType = getRenderType(targetDOMNode);\n    return this.lastRenderType && this.lastRenderType !== renderType && (await AbstractRenderer.resetApplications(), clearRootHTMLElement(renderType), this.rendererMap.clear()), this.rendererMap.has(targetId) || this.rendererMap.set(targetId, this.buildRenderer(renderType)), this.lastRenderType = renderType, this.rendererMap.get(targetId);\n  }\n  buildRenderer(renderType) {\n    return renderType === \"docs\" ? new DocsRenderer() : new CanvasRenderer();\n  }\n}, getRenderType = (targetDOMNode) => targetDOMNode.id === \"storybook-root\" ? \"canvas\" : \"docs\";\nfunction clearRootHTMLElement(renderType) {\n  switch (renderType) {\n    case \"canvas\":\n      global.document.getElementById(\"storybook-docs\").innerHTML = \"\";\n      break;\n    case \"docs\":\n      global.document.getElementById(\"storybook-root\").innerHTML = \"\";\n      break;\n    default:\n      break;\n  }\n}\n\n// src/client/render.ts\nvar rendererFactory = new RendererFactory(), render = (props) => ({ props });\nasync function renderToCanvas({ storyFn, showMain, forceRemount, storyContext: { component } }, element) {\n  showMain(), await (await rendererFactory.getRendererInstance(element)).render({\n    storyFnAngular: storyFn(),\n    component,\n    forced: !forceRemount,\n    targetDOMNode: element\n  });\n}\n\nexport {\n  isComponent,\n  formatPropInTemplate,\n  computesTemplateFromComponent,\n  computesTemplateSourceFromComponent,\n  render,\n  renderToCanvas,\n  render_exports\n};\n"],"names":[],"ignoreList":[],"sourceRoot":""}