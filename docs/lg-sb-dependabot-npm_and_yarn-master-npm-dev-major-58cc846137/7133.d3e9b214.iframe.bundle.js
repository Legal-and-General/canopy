/*! For license information please see 7133.d3e9b214.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_legal_and_general_canopy=self.webpackChunk_legal_and_general_canopy||[]).push([[7133],{"./node_modules/@angular/router/fesm2022/testing.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c1:()=>RouterTestingModule});var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),Subscription=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js"),compiler=__webpack_require__("./node_modules/@angular/compiler/fesm2022/compiler.mjs");class TestBedApplicationErrorHandler{zone=(0,core.inject)(core.NgZone);userErrorHandler=(0,core.inject)(core.ErrorHandler);whenStableRejectFunctions=new Set;handleError(e){try{this.zone.runOutsideAngular((()=>this.userErrorHandler.handleError(e)))}catch(userError){e=userError}if(!(this.whenStableRejectFunctions.size>0))throw e;for(const fn of this.whenStableRejectFunctions.values())fn(e);this.whenStableRejectFunctions.clear()}static ɵfac=function TestBedApplicationErrorHandler_Factory(__ngFactoryType__){return new(__ngFactoryType__||TestBedApplicationErrorHandler)};static ɵprov=core["ɵɵdefineInjectable"]({token:TestBedApplicationErrorHandler,factory:TestBedApplicationErrorHandler.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](TestBedApplicationErrorHandler,[{type:core.Injectable}],null,null);class DeferBlockFixture{block;componentFixture;constructor(block,componentFixture){this.block=block,this.componentFixture=componentFixture}render(state){var _this=this;return(0,asyncToGenerator.A)((function*(){if(!function hasStateTemplate(state,block){switch(state){case core["ɵDeferBlockState"].Placeholder:return null!==block.tDetails.placeholderTmplIndex;case core["ɵDeferBlockState"].Loading:return null!==block.tDetails.loadingTmplIndex;case core["ɵDeferBlockState"].Error:return null!==block.tDetails.errorTmplIndex;case core["ɵDeferBlockState"].Complete:return!0;default:return!1}}(state,_this.block)){const stateAsString=function getDeferBlockStateNameFromEnum(state){switch(state){case core["ɵDeferBlockState"].Placeholder:return"Placeholder";case core["ɵDeferBlockState"].Loading:return"Loading";case core["ɵDeferBlockState"].Error:return"Error";default:return"Main"}}(state);throw new Error(`Tried to render this defer block in the \`${stateAsString}\` state, but there was no @${stateAsString.toLowerCase()} block defined in a template.`)}state===core["ɵDeferBlockState"].Complete&&(yield(0,core["ɵtriggerResourceLoading"])(_this.block.tDetails,_this.block.lView,_this.block.tNode));(0,core["ɵrenderDeferBlockState"])(state,_this.block.tNode,_this.block.lContainer,!0),_this.componentFixture.detectChanges()}))()}getDeferBlocks(){const deferBlocks=[],deferBlockFixtures=[];if(this.block.lContainer.length>=core["ɵCONTAINER_HEADER_OFFSET"]){const lView=this.block.lContainer[core["ɵCONTAINER_HEADER_OFFSET"]];(0,core["ɵgetDeferBlocks"])(lView,deferBlocks);for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this.componentFixture))}return Promise.resolve(deferBlockFixtures)}}const DEFER_BLOCK_DEFAULT_BEHAVIOR=core["ɵDeferBlockBehavior"].Playthrough;class TestComponentRenderer{insertRootElement(rootElementId){}removeAllRootElements(){}}const ComponentFixtureAutoDetect=new core.InjectionToken("ComponentFixtureAutoDetect"),ComponentFixtureNoNgZone=new core.InjectionToken("ComponentFixtureNoNgZone");class ComponentFixture{componentRef;debugElement;componentInstance;nativeElement;elementRef;changeDetectorRef;_renderer;_isDestroyed=!1;_noZoneOptionIsSet=(0,core.inject)(ComponentFixtureNoNgZone,{optional:!0});_ngZone=this._noZoneOptionIsSet?new core["ɵNoopNgZone"]:(0,core.inject)(core.NgZone);_appRef=(0,core.inject)(core.ApplicationRef);_testAppRef=this._appRef;pendingTasks=(0,core.inject)(core["ɵPendingTasksInternal"]);appErrorHandler=(0,core.inject)(TestBedApplicationErrorHandler);zonelessEnabled=(0,core.inject)(core["ɵZONELESS_ENABLED"]);scheduler=(0,core.inject)(core["ɵChangeDetectionScheduler"]);rootEffectScheduler=(0,core.inject)(core["ɵEffectScheduler"]);microtaskEffectScheduler=(0,core.inject)(core["ɵMicrotaskEffectScheduler"]);autoDetectDefault=!!this.zonelessEnabled;autoDetect=(0,core.inject)(ComponentFixtureAutoDetect,{optional:!0})??this.autoDetectDefault;subscriptions=new Subscription.yU;ngZone=this._noZoneOptionIsSet?null:this._ngZone;constructor(componentRef){this.componentRef=componentRef,this.changeDetectorRef=componentRef.changeDetectorRef,this.elementRef=componentRef.location,this.debugElement=(0,core.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=componentRef.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=componentRef,this.autoDetect&&(this._testAppRef.externalTestViews.add(this.componentRef.hostView),this.scheduler?.notify(8),this.scheduler?.notify(0)),this.componentRef.hostView.onDestroy((()=>{this._testAppRef.externalTestViews.delete(this.componentRef.hostView)})),this._ngZone.runOutsideAngular((()=>{this.subscriptions.add(this._ngZone.onError.subscribe({next:error=>{throw error}}))}))}detectChanges(checkNoChanges=!0){this.microtaskEffectScheduler.flush();const originalCheckNoChanges=this.componentRef.changeDetectorRef.checkNoChanges;try{if(checkNoChanges||(this.componentRef.changeDetectorRef.checkNoChanges=()=>{}),this.zonelessEnabled)try{this._testAppRef.externalTestViews.add(this.componentRef.hostView),this._appRef.tick()}finally{this.autoDetect||this._testAppRef.externalTestViews.delete(this.componentRef.hostView)}else this._ngZone.run((()=>{this.rootEffectScheduler.flush(),this.changeDetectorRef.detectChanges(),this.checkNoChanges()}))}finally{this.componentRef.changeDetectorRef.checkNoChanges=originalCheckNoChanges}this.microtaskEffectScheduler.flush()}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}autoDetectChanges(autoDetect=!0){if(this._noZoneOptionIsSet&&!this.zonelessEnabled)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.");autoDetect!==this.autoDetect&&(autoDetect?this._testAppRef.externalTestViews.add(this.componentRef.hostView):this._testAppRef.externalTestViews.delete(this.componentRef.hostView)),this.autoDetect=autoDetect,this.detectChanges()}isStable(){return!this.pendingTasks.hasPendingTasks.value}whenStable(){return this.isStable()?Promise.resolve(!1):new Promise(((resolve,reject)=>{this.appErrorHandler.whenStableRejectFunctions.add(reject),this._appRef.whenStable().then((()=>{this.appErrorHandler.whenStableRejectFunctions.delete(reject),resolve(!0)}))}))}getDeferBlocks(){const deferBlocks=[],lView=this.componentRef.hostView._lView;(0,core["ɵgetDeferBlocks"])(lView,deferBlocks);const deferBlockFixtures=[];for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this));return Promise.resolve(deferBlockFixtures)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(core.RendererFactory2,null)),this._renderer}whenRenderingDone(){const renderer=this._getRenderer();return renderer&&renderer.whenRenderingDone?renderer.whenRenderingDone():this.whenStable()}destroy(){this.subscriptions.unsubscribe(),this._testAppRef.externalTestViews.delete(this.componentRef.hostView),this._isDestroyed||(this.componentRef.destroy(),this._isDestroyed=!0)}}const _Zone="undefined"!=typeof Zone?Zone:null,fakeAsyncTestModule=_Zone&&_Zone[_Zone.__symbol__("fakeAsyncTest")];let _nextReferenceId=0;class MetadataOverrider{_references=new Map;overrideMetadata(metadataClass,oldMetadata,override){const props={};if(oldMetadata&&function _valueProps(obj){const props=[];Object.keys(obj).forEach((prop=>{prop.startsWith("_")||props.push(prop)}));let proto=obj;for(;proto=Object.getPrototypeOf(proto);)Object.keys(proto).forEach((protoProp=>{const desc=Object.getOwnPropertyDescriptor(proto,protoProp);!protoProp.startsWith("_")&&desc&&"get"in desc&&props.push(protoProp)}));return props}(oldMetadata).forEach((prop=>props[prop]=oldMetadata[prop])),override.set){if(override.remove||override.add)throw new Error(`Cannot set and add/remove ${(0,core["ɵstringify"])(metadataClass)} at the same time!`);!function setMetadata(metadata,set){for(const prop in set)metadata[prop]=set[prop]}(props,override.set)}return override.remove&&function removeMetadata(metadata,remove,references){const removeObjects=new Set;for(const prop in remove){const removeValue=remove[prop];Array.isArray(removeValue)?removeValue.forEach((value=>{removeObjects.add(_propHashKey(prop,value,references))})):removeObjects.add(_propHashKey(prop,removeValue,references))}for(const prop in metadata){const propValue=metadata[prop];Array.isArray(propValue)?metadata[prop]=propValue.filter((value=>!removeObjects.has(_propHashKey(prop,value,references)))):removeObjects.has(_propHashKey(prop,propValue,references))&&(metadata[prop]=void 0)}}(props,override.remove,this._references),override.add&&function addMetadata(metadata,add){for(const prop in add){const addValue=add[prop],propValue=metadata[prop];null!=propValue&&Array.isArray(propValue)?metadata[prop]=propValue.concat(addValue):metadata[prop]=addValue}}(props,override.add),new metadataClass(props)}}function _propHashKey(propName,propValue,references){let nextObjectId=0;const objectIds=new Map;return`${propName}:${JSON.stringify(propValue,((key,value)=>null!==value&&"object"==typeof value?objectIds.has(value)?objectIds.get(value):(objectIds.set(value,"ɵobj#"+nextObjectId++),value):("function"==typeof value&&(value=function _serializeReference(ref,references){let id=references.get(ref);id||(id=`${(0,core["ɵstringify"])(ref)}${_nextReferenceId++}`,references.set(ref,id));return id}(value,references)),value)))}`}const reflection=new core["ɵReflectionCapabilities"];class OverrideResolver{overrides=new Map;resolved=new Map;addOverride(type,override){const overrides=this.overrides.get(type)||[];overrides.push(override),this.overrides.set(type,overrides),this.resolved.delete(type)}setOverrides(overrides){this.overrides.clear(),overrides.forEach((([type,override])=>{this.addOverride(type,override)}))}getAnnotation(type){const annotations=reflection.annotations(type);for(let i=annotations.length-1;i>=0;i--){const annotation=annotations[i];if(annotation instanceof core.Directive||annotation instanceof core.Component||annotation instanceof core.Pipe||annotation instanceof core.NgModule)return annotation instanceof this.type?annotation:null}return null}resolve(type){let resolved=this.resolved.get(type)||null;if(!resolved){if(resolved=this.getAnnotation(type),resolved){const overrides=this.overrides.get(type);if(overrides){const overrider=new MetadataOverrider;overrides.forEach((override=>{resolved=overrider.overrideMetadata(this.type,resolved,override)}))}}this.resolved.set(type,resolved)}return resolved}}class DirectiveResolver extends OverrideResolver{get type(){return core.Directive}}class ComponentResolver extends OverrideResolver{get type(){return core.Component}}class PipeResolver extends OverrideResolver{get type(){return core.Pipe}}class NgModuleResolver extends OverrideResolver{get type(){return core.NgModule}}var TestingModuleOverride;function assertNoStandaloneComponents(types,resolver,location){types.forEach((type=>{if(!(0,core["ɵgetAsyncClassMetadataFn"])(type)){const component=resolver.resolve(type);if(component&&(null==component.standalone||component.standalone))throw new Error((0,core["ɵgenerateStandaloneInDeclarationsError"])(type,location))}}))}!function(TestingModuleOverride){TestingModuleOverride[TestingModuleOverride.DECLARATION=0]="DECLARATION",TestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"}(TestingModuleOverride||(TestingModuleOverride={}));class TestBedCompiler{platform;additionalModuleTypes;originalComponentResolutionQueue=null;declarations=[];imports=[];providers=[];schemas=[];pendingComponents=new Set;pendingDirectives=new Set;pendingPipes=new Set;componentsWithAsyncMetadata=new Set;seenComponents=new Set;seenDirectives=new Set;overriddenModules=new Set;existingComponentStyles=new Map;resolvers=function initResolvers(){return{module:new NgModuleResolver,component:new ComponentResolver,directive:new DirectiveResolver,pipe:new PipeResolver}}();componentToModuleScope=new Map;initialNgDefs=new Map;defCleanupOps=[];_injector=null;compilerProviders=null;providerOverrides=[];rootProviderOverrides=[];providerOverridesByModule=new Map;providerOverridesByToken=new Map;scopesWithOverriddenProviders=new Set;testModuleType;testModuleRef=null;deferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR;rethrowApplicationTickErrors=true;constructor(platform,additionalModuleTypes){this.platform=platform,this.additionalModuleTypes=additionalModuleTypes;this.testModuleType=class DynamicTestModule{}}setCompilerProviders(providers){this.compilerProviders=providers,this._injector=null}configureTestingModule(moduleDef){void 0!==moduleDef.declarations&&(assertNoStandaloneComponents(moduleDef.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(moduleDef.declarations,TestingModuleOverride.DECLARATION),this.declarations.push(...moduleDef.declarations)),void 0!==moduleDef.imports&&(this.queueTypesFromModulesArray(moduleDef.imports),this.imports.push(...moduleDef.imports)),void 0!==moduleDef.providers&&this.providers.push(...moduleDef.providers),void 0!==moduleDef.schemas&&this.schemas.push(...moduleDef.schemas),this.deferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR,this.rethrowApplicationTickErrors=moduleDef.rethrowApplicationErrors??true}overrideModule(ngModule,override){core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(ngModule),this.overriddenModules.add(ngModule),this.resolvers.module.addOverride(ngModule,override);const metadata=this.resolvers.module.resolve(ngModule);if(null===metadata)throw invalidTypeError(ngModule.name,"NgModule");this.recompileNgModule(ngModule,metadata),this.queueTypesFromModulesArray([ngModule])}overrideComponent(component,override){this.verifyNoStandaloneFlagOverrides(component,override),this.resolvers.component.addOverride(component,override),this.pendingComponents.add(component),this.maybeRegisterComponentWithAsyncMetadata(component)}overrideDirective(directive,override){this.verifyNoStandaloneFlagOverrides(directive,override),this.resolvers.directive.addOverride(directive,override),this.pendingDirectives.add(directive)}overridePipe(pipe,override){this.verifyNoStandaloneFlagOverrides(pipe,override),this.resolvers.pipe.addOverride(pipe,override),this.pendingPipes.add(pipe)}verifyNoStandaloneFlagOverrides(type,override){if(override.add?.hasOwnProperty("standalone")||override.set?.hasOwnProperty("standalone")||override.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${type.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(token,provider){let providerDef;providerDef=void 0!==provider.useFactory?{provide:token,useFactory:provider.useFactory,deps:provider.deps||[],multi:provider.multi}:void 0!==provider.useValue?{provide:token,useValue:provider.useValue,multi:provider.multi}:{provide:token};const injectableDef="string"!=typeof token?(0,core["ɵgetInjectableDef"])(token):null,providedIn=null===injectableDef?null:(0,core.resolveForwardRef)(injectableDef.providedIn);if(("root"===providedIn?this.rootProviderOverrides:this.providerOverrides).push(providerDef),this.providerOverridesByToken.set(token,providerDef),null!==injectableDef&&null!==providedIn&&"string"!=typeof providedIn){const existingOverrides=this.providerOverridesByModule.get(providedIn);void 0!==existingOverrides?existingOverrides.push(providerDef):this.providerOverridesByModule.set(providedIn,[providerDef])}}overrideTemplateUsingTestingModule(type,template){const def=type[core["ɵNG_COMP_DEF"]],overrideStyleUrls=!!def&&!(0,core["ɵisComponentDefPendingResolution"])(type)&&(()=>{const metadata=this.resolvers.component.resolve(type);return!!metadata.styleUrl||!!metadata.styleUrls?.length})(),override=overrideStyleUrls?{template,styles:[],styleUrls:[],styleUrl:void 0}:{template};this.overrideComponent(type,{set:override}),overrideStyleUrls&&def.styles&&def.styles.length>0&&this.existingComponentStyles.set(type,def.styles),this.componentToModuleScope.set(type,TestingModuleOverride.OVERRIDE_TEMPLATE)}resolvePendingComponentsWithAsyncMetadata(){var _this2=this;return(0,asyncToGenerator.A)((function*(){if(0===_this2.componentsWithAsyncMetadata.size)return;const promises=[];for(const component of _this2.componentsWithAsyncMetadata){const asyncMetadataFn=(0,core["ɵgetAsyncClassMetadataFn"])(component);asyncMetadataFn&&promises.push(asyncMetadataFn())}_this2.componentsWithAsyncMetadata.clear();const flatResolvedDeps=(yield Promise.all(promises)).flat(2);_this2.queueTypesFromModulesArray(flatResolvedDeps);for(const component of flatResolvedDeps)_this2.applyProviderOverridesInScope(component)}))()}compileComponents(){var _this3=this;return(0,asyncToGenerator.A)((function*(){if(_this3.clearComponentResolutionQueue(),yield _this3.resolvePendingComponentsWithAsyncMetadata(),assertNoStandaloneComponents(_this3.declarations,_this3.resolvers.component,'"TestBed.configureTestingModule" call'),_this3.compileTypesSync()){let resourceLoader,resolver=url=>(resourceLoader||(resourceLoader=_this3.injector.get(compiler.WHm)),Promise.resolve(resourceLoader.get(url)));yield(0,core["ɵresolveComponentResources"])(resolver)}}))()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const parentInjector=this.platform.injector;this.testModuleRef=new core["ɵRender3NgModuleRef"](this.testModuleType,parentInjector,[]),this.testModuleRef.injector.get(core.ApplicationInitStatus).runInitializers();const localeId=this.testModuleRef.injector.get(core.LOCALE_ID,core["ɵDEFAULT_LOCALE_ID"]);return(0,core["ɵsetLocaleId"])(localeId),this.testModuleRef}_compileNgModuleSync(moduleType){this.queueTypesFromModulesArray([moduleType]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(moduleType),this.applyTransitiveScopes()}_compileNgModuleAsync(moduleType){var _this4=this;return(0,asyncToGenerator.A)((function*(){_this4.queueTypesFromModulesArray([moduleType]),yield _this4.compileComponents(),_this4.applyProviderOverrides(),_this4.applyProviderOverridesInScope(moduleType),_this4.applyTransitiveScopes()}))()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(moduleType){return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(((factories,declaration)=>{const componentDef=declaration.ɵcmp;return componentDef&&factories.push(new core["ɵRender3ComponentFactory"](componentDef,this.testModuleRef)),factories}),[])}compileTypesSync(){let needsAsyncResources=!1;return this.pendingComponents.forEach((declaration=>{if((0,core["ɵgetAsyncClassMetadataFn"])(declaration))throw new Error(`Component '${declaration.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);needsAsyncResources=needsAsyncResources||(0,core["ɵisComponentDefPendingResolution"])(declaration);const metadata=this.resolvers.component.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Component");this.maybeStoreNgDef(core["ɵNG_COMP_DEF"],declaration),core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(declaration),(0,core["ɵcompileComponent"])(declaration,metadata)})),this.pendingComponents.clear(),this.pendingDirectives.forEach((declaration=>{const metadata=this.resolvers.directive.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Directive");this.maybeStoreNgDef(core["ɵNG_DIR_DEF"],declaration),(0,core["ɵcompileDirective"])(declaration,metadata)})),this.pendingDirectives.clear(),this.pendingPipes.forEach((declaration=>{const metadata=this.resolvers.pipe.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Pipe");this.maybeStoreNgDef(core["ɵNG_PIPE_DEF"],declaration),(0,core["ɵcompilePipe"])(declaration,metadata)})),this.pendingPipes.clear(),needsAsyncResources}applyTransitiveScopes(){if(this.overriddenModules.size>0){const testingModuleDef=this.testModuleType[core["ɵNG_MOD_DEF"]],affectedModules=this.collectModulesAffectedByOverrides(testingModuleDef.imports);affectedModules.size>0&&affectedModules.forEach((moduleType=>{core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]?core["ɵdepsTracker"].clearScopeCacheFor(moduleType):(this.storeFieldOfDefOnType(moduleType,core["ɵNG_MOD_DEF"],"transitiveCompileScopes"),moduleType[core["ɵNG_MOD_DEF"]].transitiveCompileScopes=null)}))}const moduleToScope=new Map,getScopeOfModule=moduleType=>{if(!moduleToScope.has(moduleType)){const realType=function isTestingModuleOverride(value){return value===TestingModuleOverride.DECLARATION||value===TestingModuleOverride.OVERRIDE_TEMPLATE}(moduleType)?this.testModuleType:moduleType;moduleToScope.set(moduleType,(0,core["ɵtransitiveScopesFor"])(realType))}return moduleToScope.get(moduleType)};this.componentToModuleScope.forEach(((moduleType,componentType)=>{if(null!==moduleType){const moduleScope=getScopeOfModule(moduleType);this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"directiveDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"pipeDefs"),(0,core["ɵpatchComponentDefWithScope"])(getComponentDef(componentType),moduleScope)}this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"tView")})),this.componentToModuleScope.clear()}applyProviderOverrides(){const maybeApplyOverrides=field=>type=>{const metadata=(field===core["ɵNG_COMP_DEF"]?this.resolvers.component:this.resolvers.directive).resolve(type);this.hasProviderOverrides(metadata.providers)&&this.patchDefWithProviderOverrides(type,field)};this.seenComponents.forEach(maybeApplyOverrides(core["ɵNG_COMP_DEF"])),this.seenDirectives.forEach(maybeApplyOverrides(core["ɵNG_DIR_DEF"])),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(type){if(!(isStandaloneComponent(type)||function isNgModule(value){return hasNgModuleDef(value)}(type))||this.scopesWithOverriddenProviders.has(type))return;this.scopesWithOverriddenProviders.add(type);const injectorDef=type[core["ɵNG_INJ_DEF"]];if(0!==this.providerOverridesByToken.size)if(isStandaloneComponent(type)){const dependencies=maybeUnwrapFn(getComponentDef(type).dependencies??[]);for(const dependency of dependencies)this.applyProviderOverridesInScope(dependency)}else{const providers=[...injectorDef.providers,...this.providerOverridesByModule.get(type)||[]];this.hasProviderOverrides(providers)&&(this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],type),this.storeFieldOfDefOnType(type,core["ɵNG_INJ_DEF"],"providers"),injectorDef.providers=this.getOverriddenProviders(providers));const imports=maybeUnwrapFn(type[core["ɵNG_MOD_DEF"]].imports);for(const importedModule of imports)this.applyProviderOverridesInScope(importedModule);for(const importedModule of flatten(injectorDef.imports))isModuleWithProviders(importedModule)&&(this.defCleanupOps.push({object:importedModule,fieldName:"providers",originalValue:importedModule.providers}),importedModule.providers=this.getOverriddenProviders(importedModule.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach(((styles,type)=>type[core["ɵNG_COMP_DEF"]].styles=styles)),this.existingComponentStyles.clear()}queueTypeArray(arr,moduleType){for(const value of arr)Array.isArray(value)?this.queueTypeArray(value,moduleType):this.queueType(value,moduleType)}recompileNgModule(ngModule,metadata){this.maybeStoreNgDef(core["ɵNG_MOD_DEF"],ngModule),this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],ngModule),(0,core["ɵcompileNgModuleDefs"])(ngModule,metadata)}maybeRegisterComponentWithAsyncMetadata(type){(0,core["ɵgetAsyncClassMetadataFn"])(type)&&this.componentsWithAsyncMetadata.add(type)}queueType(type,moduleType){this.maybeRegisterComponentWithAsyncMetadata(type);if(this.resolvers.component.resolve(type))return!(0,core["ɵisComponentDefPendingResolution"])(type)&&type.hasOwnProperty(core["ɵNG_COMP_DEF"])||this.pendingComponents.add(type),this.seenComponents.add(type),void(this.componentToModuleScope.has(type)&&this.componentToModuleScope.get(type)!==TestingModuleOverride.DECLARATION||this.componentToModuleScope.set(type,moduleType));if(this.resolvers.directive.resolve(type))return type.hasOwnProperty(core["ɵNG_DIR_DEF"])||this.pendingDirectives.add(type),void this.seenDirectives.add(type);!this.resolvers.pipe.resolve(type)||type.hasOwnProperty(core["ɵNG_PIPE_DEF"])||this.pendingPipes.add(type)}queueTypesFromModulesArray(arr){const processedDefs=new Set,queueTypesFromModulesArrayRecur=arr=>{for(const value of arr)if(Array.isArray(value))queueTypesFromModulesArrayRecur(value);else if(hasNgModuleDef(value)){const def=value.ɵmod;if(processedDefs.has(def))continue;processedDefs.add(def),this.queueTypeArray(maybeUnwrapFn(def.declarations),value),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports)),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports))}else if(isModuleWithProviders(value))queueTypesFromModulesArrayRecur([value.ngModule]);else if(isStandaloneComponent(value)){this.queueType(value,null);const def=getComponentDef(value);if(processedDefs.has(def))continue;processedDefs.add(def);maybeUnwrapFn(def.dependencies??[]).forEach((dependency=>{isStandaloneComponent(dependency)||hasNgModuleDef(dependency)?queueTypesFromModulesArrayRecur([dependency]):this.queueType(dependency,null)}))}};queueTypesFromModulesArrayRecur(arr)}collectModulesAffectedByOverrides(arr){const seenModules=new Set,affectedModules=new Set,calcAffectedModulesRecur=(arr,path)=>{for(const value of arr)if(Array.isArray(value))calcAffectedModulesRecur(value,path);else if(hasNgModuleDef(value)){if(seenModules.has(value)){affectedModules.has(value)&&path.forEach((item=>affectedModules.add(item)));continue}seenModules.add(value),this.overriddenModules.has(value)&&path.forEach((item=>affectedModules.add(item)));const moduleDef=value[core["ɵNG_MOD_DEF"]];calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports),path.concat(value))}};return calcAffectedModulesRecur(arr,[]),affectedModules}maybeStoreNgDef(prop,type){this.initialNgDefs.has(type)||this.initialNgDefs.set(type,new Map);const currentDefs=this.initialNgDefs.get(type);if(!currentDefs.has(prop)){const currentDef=Object.getOwnPropertyDescriptor(type,prop);currentDefs.set(prop,currentDef)}}storeFieldOfDefOnType(type,defField,fieldName){const def=type[defField],originalValue=def[fieldName];this.defCleanupOps.push({object:def,fieldName,originalValue})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),(0,core["ɵclearResolutionOfComponentResourcesQueue"])().forEach(((value,key)=>this.originalComponentResolutionQueue.set(key,value)))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&((0,core["ɵrestoreComponentResolutionQueue"])(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){forEachRight(this.defCleanupOps,(op=>{op.object[op.fieldName]=op.originalValue})),this.initialNgDefs.forEach(((defs,type)=>{core["ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT"]&&core["ɵdepsTracker"].clearScopeCacheFor(type),defs.forEach(((descriptor,prop)=>{descriptor?Object.defineProperty(type,prop,descriptor):delete type[prop]}))})),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,core["ɵsetLocaleId"])(core["ɵDEFAULT_LOCALE_ID"])}compileTestModule(){class RootScopeModule{}(0,core["ɵcompileNgModuleDefs"])(RootScopeModule,{providers:[...this.rootProviderOverrides,(0,core["ɵinternalProvideZoneChangeDetection"])({}),TestBedApplicationErrorHandler,{provide:core["ɵChangeDetectionScheduler"],useExisting:core["ɵChangeDetectionSchedulerImpl"]}]});const providers=[{provide:core.Compiler,useFactory:()=>new R3TestCompiler(this)},{provide:core["ɵDEFER_BLOCK_CONFIG"],useValue:{behavior:this.deferBlockBehavior}},{provide:core["ɵINTERNAL_APPLICATION_ERROR_HANDLER"],useFactory:()=>{if(this.rethrowApplicationTickErrors){const handler=(0,core.inject)(TestBedApplicationErrorHandler);return e=>{handler.handleError(e)}}{const userErrorHandler=(0,core.inject)(core.ErrorHandler),ngZone=(0,core.inject)(core.NgZone);return e=>ngZone.runOutsideAngular((()=>userErrorHandler.handleError(e)))}}},...this.providers,...this.providerOverrides],imports=[RootScopeModule,this.additionalModuleTypes,this.imports||[]];(0,core["ɵcompileNgModuleDefs"])(this.testModuleType,{declarations:this.declarations,imports,schemas:this.schemas,providers},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const providers=[];return this.platform.injector.get(core.COMPILER_OPTIONS,[]).forEach((opts=>{opts.providers&&providers.push(opts.providers)})),null!==this.compilerProviders&&providers.push(...this.compilerProviders),this._injector=core.Injector.create({providers,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(provider){const token=getProviderToken(provider);return this.providerOverridesByToken.get(token)||null}getProviderOverrides(providers){return providers&&providers.length&&0!==this.providerOverridesByToken.size?flatten(flattenProviders(providers,(provider=>this.getSingleProviderOverrides(provider)||[]))):[]}getOverriddenProviders(providers){if(!providers||!providers.length||0===this.providerOverridesByToken.size)return[];const flattenedProviders=flattenProviders(providers),overrides=this.getProviderOverrides(flattenedProviders),overriddenProviders=[...flattenedProviders,...overrides],final=[],seenOverriddenProviders=new Set;return forEachRight(overriddenProviders,(provider=>{const token=getProviderToken(provider);this.providerOverridesByToken.has(token)?seenOverriddenProviders.has(token)||(seenOverriddenProviders.add(token),final.unshift({...provider,multi:!1})):final.unshift(provider)})),final}hasProviderOverrides(providers){return this.getProviderOverrides(providers).length>0}patchDefWithProviderOverrides(declaration,field){const def=declaration[field];if(def&&def.providersResolver){this.maybeStoreNgDef(field,declaration);const resolver=def.providersResolver,processProvidersFn=providers=>this.getOverriddenProviders(providers);this.storeFieldOfDefOnType(declaration,field,"providersResolver"),def.providersResolver=ngDef=>resolver(ngDef,processProvidersFn)}}}function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}function getComponentDef(value){return value.ɵcmp??null}function hasNgModuleDef(value){return value.hasOwnProperty("ɵmod")}function maybeUnwrapFn(maybeFn){return maybeFn instanceof Function?maybeFn():maybeFn}function flatten(values){const out=[];return values.forEach((value=>{Array.isArray(value)?out.push(...flatten(value)):out.push(value)})),out}function identityFn(value){return value}function flattenProviders(providers,mapFn=identityFn){const out=[];for(let provider of providers)(0,core["ɵisEnvironmentProviders"])(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?out.push(...flattenProviders(provider,mapFn)):out.push(mapFn(provider));return out}function getProviderToken(provider){return function getProviderField(provider,field){return provider&&"object"==typeof provider&&provider[field]}(provider,"provide")||provider}function isModuleWithProviders(value){return value.hasOwnProperty("ngModule")}function forEachRight(values,fn){for(let idx=values.length-1;idx>=0;idx--)fn(values[idx],idx)}function invalidTypeError(name,expectedType){return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`)}class R3TestCompiler{testBed;constructor(testBed){this.testBed=testBed}compileModuleSync(moduleType){return this.testBed._compileNgModuleSync(moduleType),new core["ɵNgModuleFactory"](moduleType)}compileModuleAsync(moduleType){var _this5=this;return(0,asyncToGenerator.A)((function*(){return yield _this5.testBed._compileNgModuleAsync(moduleType),new core["ɵNgModuleFactory"](moduleType)}))()}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=this.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){var _this6=this;return(0,asyncToGenerator.A)((function*(){const ngModuleFactory=yield _this6.compileModuleAsync(moduleType),componentFactories=_this6.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}))()}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){const meta=this.testBed._getModuleResolver().resolve(moduleType);return meta&&meta.id||void 0}}let _nextRootElementId=0;class TestBedImpl{static _INSTANCE=null;static get INSTANCE(){return TestBedImpl._INSTANCE=TestBedImpl._INSTANCE||new TestBedImpl}static _environmentTeardownOptions;static _environmentErrorOnUnknownElementsOption;static _environmentErrorOnUnknownPropertiesOption;_instanceTeardownOptions;_instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR;_instanceErrorOnUnknownElementsOption;_instanceErrorOnUnknownPropertiesOption;_previousErrorOnUnknownElementsOption;_previousErrorOnUnknownPropertiesOption;static initTestEnvironment(ngModule,platform,options){const testBed=TestBedImpl.INSTANCE;return testBed.initTestEnvironment(ngModule,platform,options),testBed}static resetTestEnvironment(){TestBedImpl.INSTANCE.resetTestEnvironment()}static configureCompiler(config){return TestBedImpl.INSTANCE.configureCompiler(config)}static configureTestingModule(moduleDef){return TestBedImpl.INSTANCE.configureTestingModule(moduleDef)}static compileComponents(){return TestBedImpl.INSTANCE.compileComponents()}static overrideModule(ngModule,override){return TestBedImpl.INSTANCE.overrideModule(ngModule,override)}static overrideComponent(component,override){return TestBedImpl.INSTANCE.overrideComponent(component,override)}static overrideDirective(directive,override){return TestBedImpl.INSTANCE.overrideDirective(directive,override)}static overridePipe(pipe,override){return TestBedImpl.INSTANCE.overridePipe(pipe,override)}static overrideTemplate(component,template){return TestBedImpl.INSTANCE.overrideTemplate(component,template)}static overrideTemplateUsingTestingModule(component,template){return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component,template)}static overrideProvider(token,provider){return TestBedImpl.INSTANCE.overrideProvider(token,provider)}static inject(token,notFoundValue,flags){return TestBedImpl.INSTANCE.inject(token,notFoundValue,(0,core["ɵconvertToBitFlags"])(flags))}static get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return TestBedImpl.INSTANCE.inject(token,notFoundValue,flags)}static runInInjectionContext(fn){return TestBedImpl.INSTANCE.runInInjectionContext(fn)}static createComponent(component){return TestBedImpl.INSTANCE.createComponent(component)}static resetTestingModule(){return TestBedImpl.INSTANCE.resetTestingModule()}static execute(tokens,fn,context){return TestBedImpl.INSTANCE.execute(tokens,fn,context)}static get platform(){return TestBedImpl.INSTANCE.platform}static get ngModule(){return TestBedImpl.INSTANCE.ngModule}static flushEffects(){return TestBedImpl.INSTANCE.flushEffects()}platform=null;ngModule=null;_compiler=null;_testModuleRef=null;_activeFixtures=[];globalCompilationChecked=!1;initTestEnvironment(ngModule,platform,options){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");TestBedImpl._environmentTeardownOptions=options?.teardown,TestBedImpl._environmentErrorOnUnknownElementsOption=options?.errorOnUnknownElements,TestBedImpl._environmentErrorOnUnknownPropertiesOption=options?.errorOnUnknownProperties,this.platform=platform,this.ngModule=ngModule,this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,TestBedImpl._environmentTeardownOptions=void 0,(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,core["ɵresetCompiledComponents"])(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetUnknownElementStrictMode"])(this._previousErrorOnUnknownElementsOption??false),(0,core["ɵsetUnknownPropertyStrictMode"])(this._previousErrorOnUnknownPropertiesOption??false);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0,this._instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR}}return this}configureCompiler(config){if(null!=config.useJit)throw new Error("JIT compiler is not configurable via TestBed APIs.");return void 0!==config.providers&&this.compiler.setCompilerProviders(config.providers),this}configureTestingModule(moduleDef){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=moduleDef.teardown,this._instanceErrorOnUnknownElementsOption=moduleDef.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=moduleDef.errorOnUnknownProperties,this._instanceDeferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR,this._previousErrorOnUnknownElementsOption=(0,core["ɵgetUnknownElementStrictMode"])(),(0,core["ɵsetUnknownElementStrictMode"])(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,core["ɵgetUnknownPropertyStrictMode"])(),(0,core["ɵsetUnknownPropertyStrictMode"])(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(moduleDef),this}compileComponents(){return this.compiler.compileComponents()}inject(token,notFoundValue,flags){if(token===TestBed)return this;const UNDEFINED={},result=this.testModuleRef.injector.get(token,UNDEFINED,(0,core["ɵconvertToBitFlags"])(flags));return result===UNDEFINED?this.compiler.injector.get(token,notFoundValue,flags):result}get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return this.inject(token,notFoundValue,flags)}runInInjectionContext(fn){return(0,core.runInInjectionContext)(this.inject(core.EnvironmentInjector),fn)}execute(tokens,fn,context){const params=tokens.map((t=>this.inject(t)));return fn.apply(context,params)}overrideModule(ngModule,override){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(ngModule,override),this}overrideComponent(component,override){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(component,override),this}overrideTemplateUsingTestingModule(component,template){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(component,template),this}overrideDirective(directive,override){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(directive,override),this}overridePipe(pipe,override){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(pipe,override),this}overrideProvider(token,provider){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(token,provider),this}overrideTemplate(component,template){return this.overrideComponent(component,{set:{template,templateUrl:null}})}createComponent(type){const testComponentRenderer=this.inject(TestComponentRenderer),rootElId="root"+_nextRootElementId++;if(testComponentRenderer.insertRootElement(rootElId),(0,core["ɵgetAsyncClassMetadataFn"])(type))throw new Error(`Component '${type.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);const componentDef=type.ɵcmp;if(!componentDef)throw new Error(`It looks like '${(0,core["ɵstringify"])(type)}' has not been compiled.`);const componentFactory=new core["ɵRender3ComponentFactory"](componentDef),initComponent=()=>{const componentRef=componentFactory.create(core.Injector.NULL,[],`#${rootElId}`,this.testModuleRef);return this.runInInjectionContext((()=>new ComponentFixture(componentRef)))},ngZone=this.inject(ComponentFixtureNoNgZone,!1)?null:this.inject(core.NgZone,null),fixture=ngZone?ngZone.run(initComponent):initComponent();return this._activeFixtures.push(fixture),fixture}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(methodName,methodDescription){if(null!==this._testModuleRef)throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`)}checkGlobalCompilationFinished(){this.globalCompilationChecked||null!==this._testModuleRef||(0,core["ɵflushModuleScopingQueueAsMuchAsPossible"])(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let errorCount=0;if(this._activeFixtures.forEach((fixture=>{try{fixture.destroy()}catch(e){errorCount++,console.error("Error during cleanup of component",{component:fixture.componentInstance,stacktrace:e})}})),this._activeFixtures=[],errorCount>0&&this.shouldRethrowTeardownErrors())throw Error(`${errorCount} ${1===errorCount?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const instanceOptions=this._instanceTeardownOptions,environmentOptions=TestBedImpl._environmentTeardownOptions;return!instanceOptions&&!environmentOptions||(instanceOptions?.rethrowErrors??environmentOptions?.rethrowErrors??this.shouldTearDownTestingModule())}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??TestBedImpl._environmentErrorOnUnknownElementsOption??false}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??TestBedImpl._environmentErrorOnUnknownPropertiesOption??false}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??TestBedImpl._environmentTeardownOptions?.destroyAfterEach??true}getDeferBlockBehavior(){return this._instanceDeferBlockBehavior}tearDownTestingModule(){if(null===this._testModuleRef)return;const testRenderer=this.inject(TestComponentRenderer);try{this._testModuleRef.destroy()}catch(e){if(this.shouldRethrowTeardownErrors())throw e;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:e})}finally{testRenderer.removeAllRootElements?.()}}flushEffects(){this.inject(core["ɵMicrotaskEffectScheduler"]).flush(),this.inject(core["ɵEffectScheduler"]).flush()}}const TestBed=TestBedImpl;function getCleanupHook(expectedTeardownValue){return()=>{const testBed=TestBedImpl.INSTANCE;testBed.shouldTearDownTestingModule()===expectedTeardownValue&&(testBed.resetTestingModule(),function resetFakeAsyncZoneIfExists(){fakeAsyncTestModule&&Zone.ProxyZoneSpec?.isLoaded()&&fakeAsyncTestModule.resetFakeAsyncZone()}())}}globalThis.beforeEach?.(getCleanupHook(!1)),globalThis.afterEach?.(getCleanupHook(!0));class FakeNavigation{entriesArr=[];currentEntryIndex=0;navigateEvent=null;traversalQueue=new Map;nextTraversal=Promise.resolve();prospectiveEntryIndex=0;synchronousTraversals=!1;canSetInitialEntry=!0;eventTarget;nextId=0;nextKey=0;disposed=!1;get currentEntry(){return this.entriesArr[this.currentEntryIndex]}get canGoBack(){return this.currentEntryIndex>0}get canGoForward(){return this.currentEntryIndex<this.entriesArr.length-1}createEventTarget;_window;get window(){return this._window}constructor(doc,startURL){this.createEventTarget=()=>{try{return doc.createElement("div")}catch{return new EventTarget}},this._window=document.defaultView??this.createEventTarget(),this.eventTarget=this.createEventTarget(),this.setInitialEntryForTesting(startURL)}setInitialEntryForTesting(url,options={historyState:null}){if(!this.canSetInitialEntry)throw new Error("setInitialEntryForTesting can only be called before any navigation has occurred");const currentInitialEntry=this.entriesArr[0];this.entriesArr[0]=new FakeNavigationHistoryEntry(this.eventTarget,new URL(url).toString(),{index:0,key:currentInitialEntry?.key??String(this.nextKey++),id:currentInitialEntry?.id??String(this.nextId++),sameDocument:!0,historyState:options?.historyState,state:options.state})}canSetInitialEntryForTesting(){return this.canSetInitialEntry}setSynchronousTraversalsForTesting(synchronousTraversals){this.synchronousTraversals=synchronousTraversals}entries(){return this.entriesArr.slice()}navigate(url,options){const fromUrl=new URL(this.currentEntry.url),toUrl=new URL(url,this.currentEntry.url);let navigationType;navigationType=options?.history&&"auto"!==options.history?options.history:fromUrl.toString()===toUrl.toString()?"replace":"push";const hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),state:options?.state,sameDocument:hashChange,historyState:null}),result=new InternalNavigationResult(this);return this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info})||this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent),{committed:result.committed,finished:result.finished}}pushState(data,title,url){this.pushOrReplaceState("push",data,title,url)}replaceState(data,title,url){this.pushOrReplaceState("replace",data,title,url)}pushOrReplaceState(navigationType,data,_title,url){const fromUrl=new URL(this.currentEntry.url),toUrl=url?new URL(url,this.currentEntry.url):fromUrl,hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),sameDocument:!0,historyState:data}),result=new InternalNavigationResult(this);this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange})||this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent)}traverseTo(key,options){const fromUrl=new URL(this.currentEntry.url),entry=this.findEntry(key);if(!entry){const domException=new DOMException("Invalid key","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}if(entry===this.currentEntry)return{committed:Promise.resolve(this.currentEntry),finished:Promise.resolve(this.currentEntry)};if(this.traversalQueue.has(entry.key)){const existingResult=this.traversalQueue.get(entry.key);return{committed:existingResult.committed,finished:existingResult.finished}}const hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument});this.prospectiveEntryIndex=entry.index;const result=new InternalNavigationResult(this);return this.traversalQueue.set(entry.key,result),this.runTraversal((()=>{this.traversalQueue.delete(entry.key);this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info})||this.userAgentTraverse(this.navigateEvent)})),{committed:result.committed,finished:result.finished}}back(options){if(0===this.currentEntryIndex){const domException=new DOMException("Cannot go back","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex-1];return this.traverseTo(entry.key,options)}forward(options){if(this.currentEntryIndex===this.entriesArr.length-1){const domException=new DOMException("Cannot go forward","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch((()=>{})),finished.catch((()=>{})),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex+1];return this.traverseTo(entry.key,options)}go(direction){const targetIndex=this.prospectiveEntryIndex+direction;targetIndex>=this.entriesArr.length||targetIndex<0||(this.prospectiveEntryIndex=targetIndex,this.runTraversal((()=>{if(targetIndex>=this.entriesArr.length||targetIndex<0)return;const fromUrl=new URL(this.currentEntry.url),entry=this.entriesArr[targetIndex],hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument}),result=new InternalNavigationResult(this);this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange})||this.userAgentTraverse(this.navigateEvent)})))}runTraversal(traversal){this.synchronousTraversals?traversal():this.nextTraversal=this.nextTraversal.then((()=>new Promise((resolve=>{setTimeout((()=>{resolve(),traversal()}))}))))}addEventListener(type,callback,options){this.eventTarget.addEventListener(type,callback,options)}removeEventListener(type,callback,options){this.eventTarget.removeEventListener(type,callback,options)}dispatchEvent(event){return this.eventTarget.dispatchEvent(event)}dispose(){this.eventTarget=this.createEventTarget(),this.disposed=!0}isDisposed(){return this.disposed}userAgentNavigate(destination,result,options){return this.canSetInitialEntry=!1,this.navigateEvent&&(this.navigateEvent.cancel(new DOMException("Navigation was aborted","AbortError")),this.navigateEvent=null),function dispatchNavigateEvent({cancelable,canIntercept,userInitiated,hashChange,navigationType,signal,destination,info,sameDocument,result}){const{navigation}=result,event=new Event("navigate",{bubbles:!1,cancelable});event.focusResetBehavior=null,event.scrollBehavior=null,event.interceptionState="none",event.canIntercept=canIntercept,event.userInitiated=userInitiated,event.hashChange=hashChange,event.navigationType=navigationType,event.signal=signal,event.destination=destination,event.info=info,event.downloadRequest=null,event.formData=null,event.result=result,event.sameDocument=sameDocument;let precommitHandlers=[],handlers=[];function redirect(url){if("none"===event.interceptionState)throw new Error("cannot redirect when event is not intercepted");if("intercepted"!==event.interceptionState)throw new DOMException("cannot redirect when event is not in 'intercepted' state","InvalidStateError");if("push"!==event.navigationType&&"replace"!==event.navigationType)throw new DOMException("cannot redirect when navigationType is not 'push' or 'replace","InvalidStateError");const toUrl=new URL(url,navigation.currentEntry.url);event.destination.url=toUrl.href}function commit(){if(result.signal.aborted)return;if("none"!==event.interceptionState){if(event.interceptionState="committed",!navigation.currentEntry)throw new Error("from history entry should not be null");switch(navigation.transition=new InternalNavigationTransition(navigation.currentEntry,navigationType),event.navigationType){case"push":case"replace":navigation.urlAndHistoryUpdateSteps(event);break;case"reload":navigation.updateNavigationEntriesForSameDocumentNavigation(event);break;case"traverse":navigation.userAgentTraverse(event)}}const promisesList=handlers.map((handler=>handler()));0===promisesList.length&&promisesList.push(Promise.resolve()),Promise.all(promisesList).then((()=>{if(result.signal.aborted)return;if(event!==navigation.navigateEvent)throw new Error("Navigation's ongoing event not equal to resolved event");navigation.navigateEvent=null,finishNavigationEvent(event,!0);const navigatesuccessEvent=new Event("navigatesuccess",{bubbles:!1,cancelable});navigation.eventTarget.dispatchEvent(navigatesuccessEvent),result.finishedResolve(),null!==navigation.transition&&navigation.transition.finishedResolve(),navigation.transition=null})).catch((reason=>event.cancel(reason)))}function dispatch(){if(navigation.navigateEvent=event,navigation.eventTarget.dispatchEvent(event),0===precommitHandlers.length)commit();else{const precommitController={redirect},precommitPromisesList=precommitHandlers.map((handler=>handler(precommitController)));Promise.all(precommitPromisesList).then((()=>commit())).catch((reason=>event.cancel(reason)))}}return event.intercept=function(options){if(!this.canIntercept)throw new DOMException("Cannot intercept when canIntercept is 'false'","SecurityError");this.interceptionState="intercepted",event.sameDocument=!0;const precommitHandler=options?.precommitHandler;if(precommitHandler){if(!this.cancelable)throw new DOMException("Cannot use precommitHandler when cancelable is 'false'","InvalidStateError");precommitHandlers.push(precommitHandler)}if("none"!==event.interceptionState&&"intercepted"!==event.interceptionState)throw new Error('Event interceptionState should be "none" or "intercepted"');event.interceptionState="intercepted";const handler=options?.handler;handler&&handlers.push(handler),event.focusResetBehavior=options?.focusReset??event.focusResetBehavior,event.scrollBehavior=options?.scroll??event.scrollBehavior},event.scroll=function(){if("committed"!==event.interceptionState)throw new DOMException("Failed to execute 'scroll' on 'NavigateEvent': scroll() must be called after commit() and interception options must specify manual scroll.","InvalidStateError");processScrollBehavior(event)},event.cancel=function(reason){if(result.signal.aborted)return;if(event!==navigation.navigateEvent)throw new Error("Navigation's ongoing event not equal to resolved event");navigation.navigateEvent=null,"intercepted"!==event.interceptionState&&finishNavigationEvent(event,!1);const navigateerrorEvent=new Event("navigateerror",{bubbles:!1,cancelable});navigation.eventTarget.dispatchEvent(navigateerrorEvent),result.finishedReject(reason),null!==navigation.transition&&navigation.transition.finishedReject(reason),navigation.transition=null},dispatch(),"none"!==event.interceptionState}({navigationType:options.navigationType,cancelable:options.cancelable,canIntercept:options.canIntercept,userInitiated:options.userInitiated,hashChange:options.hashChange,signal:result.signal,destination,info:options.info,sameDocument:destination.sameDocument,result})}urlAndHistoryUpdateSteps(navigateEvent){this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent)}userAgentTraverse(navigateEvent){const oldUrl=this.currentEntry.url;this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);const popStateEvent=function createPopStateEvent({state}){const event=new Event("popstate",{bubbles:!1,cancelable:!1});return event.state=state,event}({state:navigateEvent.destination.getHistoryState()});if(this._window.dispatchEvent(popStateEvent),navigateEvent.hashChange){const hashchangeEvent=function createHashChangeEvent(newURL,oldURL){const event=new Event("hashchange",{bubbles:!1,cancelable:!1});return event.newURL=newURL,event.oldURL=oldURL,event}(oldUrl,this.currentEntry.url);this._window.dispatchEvent(hashchangeEvent)}}updateNavigationEntriesForSameDocumentNavigation({destination,navigationType,result}){const oldCurrentNHE=this.currentEntry,disposedNHEs=[];if("traverse"===navigationType){if(this.currentEntryIndex=destination.index,-1===this.currentEntryIndex)throw new Error("unexpected current entry index")}else"push"===navigationType?(this.currentEntryIndex++,this.prospectiveEntryIndex=this.currentEntryIndex,disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex))):"replace"===navigationType&&disposedNHEs.push(oldCurrentNHE);if("push"===navigationType||"replace"===navigationType){const index=this.currentEntryIndex,key="push"===navigationType?String(this.nextKey++):this.currentEntry.key,newNHE=new FakeNavigationHistoryEntry(this.eventTarget,destination.url,{id:String(this.nextId++),key,index,sameDocument:!0,state:destination.getState(),historyState:destination.getHistoryState()});this.entriesArr[this.currentEntryIndex]=newNHE}result.committedResolve(this.currentEntry);const currentEntryChangeEvent=function createFakeNavigationCurrentEntryChangeEvent({from,navigationType}){const event=new Event("currententrychange",{bubbles:!1,cancelable:!1});return event.from=from,event.navigationType=navigationType,event}({from:oldCurrentNHE,navigationType});this.eventTarget.dispatchEvent(currentEntryChangeEvent);for(const disposedNHE of disposedNHEs)disposedNHE.dispose()}findEntry(key){for(const entry of this.entriesArr)if(entry.key===key)return entry}set onnavigate(_handler){throw new Error("unimplemented")}get onnavigate(){throw new Error("unimplemented")}set oncurrententrychange(_handler){throw new Error("unimplemented")}get oncurrententrychange(){throw new Error("unimplemented")}set onnavigatesuccess(_handler){throw new Error("unimplemented")}get onnavigatesuccess(){throw new Error("unimplemented")}set onnavigateerror(_handler){throw new Error("unimplemented")}get onnavigateerror(){throw new Error("unimplemented")}_transition=null;set transition(t){this._transition=t}get transition(){return this._transition}updateCurrentEntry(_options){throw new Error("unimplemented")}reload(_options){throw new Error("unimplemented")}}class FakeNavigationHistoryEntry{eventTarget;url;sameDocument;id;key;index;state;historyState;ondispose=null;constructor(eventTarget,url,{id,key,index,sameDocument,state,historyState}){this.eventTarget=eventTarget,this.url=url,this.id=id,this.key=key,this.index=index,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState}getState(){return this.state?JSON.parse(JSON.stringify(this.state)):this.state}getHistoryState(){return this.historyState?JSON.parse(JSON.stringify(this.historyState)):this.historyState}addEventListener(type,callback,options){this.eventTarget.addEventListener(type,callback,options)}removeEventListener(type,callback,options){this.eventTarget.removeEventListener(type,callback,options)}dispatchEvent(event){return this.eventTarget.dispatchEvent(event)}dispose(){const disposeEvent=new Event("disposed");this.dispatchEvent(disposeEvent),this.eventTarget=null}}function finishNavigationEvent(event,didFulfill){if("finished"===event.interceptionState)throw new Error("Attempting to finish navigation event that was already finished");if("intercepted"!==event.interceptionState)"none"!==event.interceptionState&&(!function potentiallyResetFocus(event){if("committed"!==event.interceptionState&&"scrolled"!==event.interceptionState)throw new Error("cannot reset focus if navigation event is not committed or scrolled")}(event),didFulfill&&function potentiallyResetScroll(event){if("committed"!==event.interceptionState&&"scrolled"!==event.interceptionState)throw new Error("cannot reset scroll if navigation event is not committed or scrolled");if("scrolled"===event.interceptionState||"manual"===event.scrollBehavior)return;processScrollBehavior(event)}(event),event.interceptionState="finished");else{if(!0===didFulfill)throw new Error("didFulfill should be false");event.interceptionState="finished"}}function processScrollBehavior(event){if("committed"!==event.interceptionState)throw new Error("invalid event interception state when processing scroll behavior");event.interceptionState="scrolled"}class FakeNavigationDestination{url;sameDocument;key;id;index;state;historyState;constructor({url,sameDocument,historyState,state,key=null,id=null,index=-1}){this.url=url,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState,this.key=key,this.id=id,this.index=index}getState(){return this.state}getHistoryState(){return this.historyState}}function isHashChange(from,to){return to.hash!==from.hash&&to.hostname===from.hostname&&to.pathname===from.pathname&&to.search===from.search}class InternalNavigationTransition{from;navigationType;finished;finishedResolve;finishedReject;constructor(from,navigationType){this.from=from,this.navigationType=navigationType,this.finished=new Promise(((resolve,reject)=>{this.finishedReject=reject,this.finishedResolve=resolve})),this.finished.catch((()=>{}))}}class InternalNavigationResult{navigation;committedTo=null;committedResolve;committedReject;finishedResolve;finishedReject;committed;finished;get signal(){return this.abortController.signal}abortController=new AbortController;constructor(navigation){var _this7=this;this.navigation=navigation,this.committed=new Promise(((resolve,reject)=>{this.committedResolve=entry=>{this.committedTo=entry,resolve(entry)},this.committedReject=reject})),this.finished=new Promise(function(){var _ref=(0,asyncToGenerator.A)((function*(resolve,reject){_this7.finishedResolve=()=>{if(null===_this7.committedTo)throw new Error("NavigateEvent should have been committed before resolving finished promise.");resolve(_this7.committedTo)},_this7.finishedReject=reason=>{reject(reason),_this7.abortController.abort(reason)}}));return function(_x,_x2){return _ref.apply(this,arguments)}}()),this.committed.catch((()=>{})),this.finished.catch((()=>{}))}}class Log{logItems;constructor(){this.logItems=[]}add(value){this.logItems.push(value)}fn(value){return()=>{this.logItems.push(value)}}clear(){this.logItems=[]}result(){return this.logItems.join("; ")}static ɵfac=function Log_Factory(__ngFactoryType__){return new(__ngFactoryType__||Log)};static ɵprov=core["ɵɵdefineInjectable"]({token:Log,factory:Log.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](Log,[{type:core.Injectable}],(()=>[]),null);var router_Dwfin5Au=__webpack_require__("./node_modules/@angular/router/fesm2022/router-Dwfin5Au.mjs"),router_module_DTJgGWLd=__webpack_require__("./node_modules/@angular/router/fesm2022/router_module-DTJgGWLd.mjs"),location_Dq4mJT_A=__webpack_require__("./node_modules/@angular/common/fesm2022/location-Dq4mJT-A.mjs"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");class platform_navigation_B45Jeakb_PlatformNavigation{static ɵfac=function PlatformNavigation_Factory(__ngFactoryType__){return new(__ngFactoryType__||platform_navigation_B45Jeakb_PlatformNavigation)};static ɵprov=core["ɵɵdefineInjectable"]({token:platform_navigation_B45Jeakb_PlatformNavigation,factory:()=>window.navigation,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](platform_navigation_B45Jeakb_PlatformNavigation,[{type:core.Injectable,args:[{providedIn:"platform",useFactory:()=>window.navigation}]}],null,null);var dom_tokens_rA0ACyx7=__webpack_require__("./node_modules/@angular/common/fesm2022/dom_tokens-rA0ACyx7.mjs");const urlParse=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;function parseUrl(urlStr,baseHref){let serverBase,parsedUrl;/^((http[s]?|ftp):\/\/)/.test(urlStr)||(serverBase="http://empty.com/");try{parsedUrl=new URL(urlStr,serverBase)}catch(e){const result=urlParse.exec(serverBase||""+urlStr);if(!result)throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);const hostSplit=result[4].split(":");parsedUrl={protocol:result[1],hostname:hostSplit[0],port:hostSplit[1]||"",pathname:result[5],search:result[6],hash:result[8]}}return parsedUrl.pathname&&0===parsedUrl.pathname.indexOf(baseHref)&&(parsedUrl.pathname=parsedUrl.pathname.substring(baseHref.length)),{hostname:!serverBase&&parsedUrl.hostname||"",protocol:!serverBase&&parsedUrl.protocol||"",port:!serverBase&&parsedUrl.port||"",pathname:parsedUrl.pathname||"/",search:parsedUrl.search||"",hash:parsedUrl.hash||""}}const MOCK_PLATFORM_LOCATION_CONFIG=new core.InjectionToken("MOCK_PLATFORM_LOCATION_CONFIG");class MockPlatformLocation{baseHref="";hashUpdate=new Subject.B;popStateSubject=new Subject.B;urlChangeIndex=0;urlChanges=[{hostname:"",protocol:"",port:"",pathname:"/",search:"",hash:"",state:null}];constructor(config){if(config){this.baseHref=config.appBaseHref||"";const parsedChanges=this.parseChanges(null,config.startUrl||"http://_empty_/",this.baseHref);this.urlChanges[0]={...parsedChanges}}}get hostname(){return this.urlChanges[this.urlChangeIndex].hostname}get protocol(){return this.urlChanges[this.urlChangeIndex].protocol}get port(){return this.urlChanges[this.urlChangeIndex].port}get pathname(){return this.urlChanges[this.urlChangeIndex].pathname}get search(){return this.urlChanges[this.urlChangeIndex].search}get hash(){return this.urlChanges[this.urlChangeIndex].hash}get state(){return this.urlChanges[this.urlChangeIndex].state}getBaseHrefFromDOM(){return this.baseHref}onPopState(fn){const subscription=this.popStateSubject.subscribe(fn);return()=>subscription.unsubscribe()}onHashChange(fn){const subscription=this.hashUpdate.subscribe(fn);return()=>subscription.unsubscribe()}get href(){let url=`${this.protocol}//${this.hostname}${this.port?":"+this.port:""}`;return url+=`${"/"===this.pathname?"":this.pathname}${this.search}${this.hash}`,url}get url(){return`${this.pathname}${this.search}${this.hash}`}parseChanges(state,url,baseHref=""){return state=JSON.parse(JSON.stringify(state)),{...parseUrl(url,baseHref),state}}replaceState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChanges[this.urlChangeIndex]={...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}}pushState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChangeIndex>0&&this.urlChanges.splice(this.urlChangeIndex+1),this.urlChanges.push({...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}),this.urlChangeIndex=this.urlChanges.length-1}forward(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex<this.urlChanges.length&&this.urlChangeIndex++,this.emitEvents(oldHash,oldUrl)}back(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex>0&&this.urlChangeIndex--,this.emitEvents(oldHash,oldUrl)}historyGo(relativePosition=0){const oldUrl=this.url,oldHash=this.hash,nextPageIndex=this.urlChangeIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this.urlChanges.length&&(this.urlChangeIndex=nextPageIndex),this.emitEvents(oldHash,oldUrl)}getState(){return this.state}emitEvents(oldHash,oldUrl){this.popStateSubject.next({type:"popstate",state:this.getState(),oldUrl,newUrl:this.url}),oldHash!==this.hash&&this.hashUpdate.next({type:"hashchange",state:null,oldUrl,newUrl:this.url})}static ɵfac=function MockPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockPlatformLocation)(core["ɵɵinject"](MOCK_PLATFORM_LOCATION_CONFIG,8))};static ɵprov=core["ɵɵdefineInjectable"]({token:MockPlatformLocation,factory:MockPlatformLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockPlatformLocation,[{type:core.Injectable}],(()=>[{type:void 0,decorators:[{type:core.Inject,args:[MOCK_PLATFORM_LOCATION_CONFIG]},{type:core.Optional}]}]),null);class FakeNavigationPlatformLocation{_platformNavigation;constructor(){const platformNavigation=(0,core.inject)(platform_navigation_B45Jeakb_PlatformNavigation);if(!(platformNavigation instanceof FakeNavigation))throw new Error("FakePlatformNavigation cannot be used without FakeNavigation. Use `provideFakeNavigation` to have all these services provided together.");this._platformNavigation=platformNavigation}config=(0,core.inject)(MOCK_PLATFORM_LOCATION_CONFIG,{optional:!0});getBaseHrefFromDOM(){return this.config?.appBaseHref??""}onPopState(fn){return this._platformNavigation.window.addEventListener("popstate",fn),()=>this._platformNavigation.window.removeEventListener("popstate",fn)}onHashChange(fn){return this._platformNavigation.window.addEventListener("hashchange",fn),()=>this._platformNavigation.window.removeEventListener("hashchange",fn)}get href(){return this._platformNavigation.currentEntry.url}get protocol(){return new URL(this._platformNavigation.currentEntry.url).protocol}get hostname(){return new URL(this._platformNavigation.currentEntry.url).hostname}get port(){return new URL(this._platformNavigation.currentEntry.url).port}get pathname(){return new URL(this._platformNavigation.currentEntry.url).pathname}get search(){return new URL(this._platformNavigation.currentEntry.url).search}get hash(){return new URL(this._platformNavigation.currentEntry.url).hash}pushState(state,title,url){this._platformNavigation.pushState(state,title,url)}replaceState(state,title,url){this._platformNavigation.replaceState(state,title,url)}forward(){this._platformNavigation.forward()}back(){this._platformNavigation.back()}historyGo(relativePosition=0){this._platformNavigation.go(relativePosition)}getState(){return this._platformNavigation.currentEntry.getHistoryState()}static ɵfac=function FakeNavigationPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||FakeNavigationPlatformLocation)};static ɵprov=core["ɵɵdefineInjectable"]({token:FakeNavigationPlatformLocation,factory:FakeNavigationPlatformLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](FakeNavigationPlatformLocation,[{type:core.Injectable}],(()=>[]),null);new core.InjectionToken("fakeNavigation",{providedIn:"root",factory:()=>{const config=(0,core.inject)(MOCK_PLATFORM_LOCATION_CONFIG,{optional:!0}),startUrl=new URL(config?.startUrl||"http://_empty_/","http://_empty_/");return new FakeNavigation((0,core.inject)(dom_tokens_rA0ACyx7.q),startUrl.href)}});class SpyLocation{urlChanges=[];_history=[new LocationState("","",null)];_historyIndex=0;_subject=new Subject.B;_basePath="";_locationStrategy=null;_urlChangeListeners=[];_urlChangeSubscription=null;ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}setInitialPath(url){this._history[this._historyIndex].path=url}setBaseHref(url){this._basePath=url}path(){return this._history[this._historyIndex].path}getState(){return this._history[this._historyIndex].state}isCurrentPathEqualTo(path,query=""){const givenPath=path.endsWith("/")?path.substring(0,path.length-1):path;return(this.path().endsWith("/")?this.path().substring(0,this.path().length-1):this.path())==givenPath+(query.length>0?"?"+query:"")}simulateUrlPop(pathname){this._subject.next({url:pathname,pop:!0,type:"popstate"})}simulateHashChange(pathname){const path=this.prepareExternalUrl(pathname);this.pushHistory(path,"",null),this.urlChanges.push("hash: "+pathname),this._subject.next({url:pathname,pop:!0,type:"popstate"}),this._subject.next({url:pathname,pop:!0,type:"hashchange"})}prepareExternalUrl(url){return url.length>0&&!url.startsWith("/")&&(url="/"+url),this._basePath+url}go(path,query="",state=null){path=this.prepareExternalUrl(path),this.pushHistory(path,query,state);const locationState=this._history[this._historyIndex-1];if(locationState.path==path&&locationState.query==query)return;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push(url),this._notifyUrlChangeListeners(path+(0,location_Dq4mJT_A.Q)(query),state)}replaceState(path,query="",state=null){path=this.prepareExternalUrl(path);const history=this._history[this._historyIndex];if(history.state=state,history.path==path&&history.query==query)return;history.path=path,history.query=query;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push("replace: "+url),this._notifyUrlChangeListeners(path+(0,location_Dq4mJT_A.Q)(query),state)}forward(){this._historyIndex<this._history.length-1&&(this._historyIndex++,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}back(){this._historyIndex>0&&(this._historyIndex--,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}historyGo(relativePosition=0){const nextPageIndex=this._historyIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this._history.length&&(this._historyIndex=nextPageIndex,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription??=this.subscribe((v=>{this._notifyUrlChangeListeners(v.url,v.state)})),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach((fn=>fn(url,state)))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow??void 0,complete:onReturn??void 0})}normalize(url){return null}pushHistory(path,query,state){this._historyIndex>0&&this._history.splice(this._historyIndex+1),this._history.push(new LocationState(path,query,state)),this._historyIndex=this._history.length-1}static ɵfac=function SpyLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||SpyLocation)};static ɵprov=core["ɵɵdefineInjectable"]({token:SpyLocation,factory:SpyLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](SpyLocation,[{type:core.Injectable}],null,null);class LocationState{path;query;state;constructor(path,query,state){this.path=path,this.query=query,this.state=state}}class MockLocationStrategy extends location_Dq4mJT_A.hb{internalBaseHref="/";internalPath="/";internalTitle="";urlChanges=[];_subject=new Subject.B;stateChanges=[];constructor(){super()}simulatePopState(url){this.internalPath=url,this._subject.next(new _MockPopStateEvent(this.path()))}path(includeHash=!1){return this.internalPath}prepareExternalUrl(internal){return internal.startsWith("/")&&this.internalBaseHref.endsWith("/")?this.internalBaseHref+internal.substring(1):this.internalBaseHref+internal}pushState(ctx,title,path,query){this.stateChanges.push(ctx),this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push(externalUrl)}replaceState(ctx,title,path,query){this.stateChanges[(this.stateChanges.length||1)-1]=ctx,this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push("replace: "+externalUrl)}onPopState(fn){this._subject.subscribe({next:fn})}getBaseHref(){return this.internalBaseHref}back(){if(this.urlChanges.length>0){this.urlChanges.pop(),this.stateChanges.pop();const nextUrl=this.urlChanges.length>0?this.urlChanges[this.urlChanges.length-1]:"";this.simulatePopState(nextUrl)}}forward(){throw"not implemented"}getState(){return this.stateChanges[(this.stateChanges.length||1)-1]}static ɵfac=function MockLocationStrategy_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockLocationStrategy)};static ɵprov=core["ɵɵdefineInjectable"]({token:MockLocationStrategy,factory:MockLocationStrategy.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockLocationStrategy,[{type:core.Injectable}],(()=>[]),null);class _MockPopStateEvent{newUrl;pop=!0;type="popstate";constructor(newUrl){this.newUrl=newUrl}}function provideLocationMocks(){return[{provide:location_Dq4mJT_A.aZ,useClass:SpyLocation},{provide:location_Dq4mJT_A.hb,useClass:MockLocationStrategy}]}class RouterTestingModule{static withRoutes(routes,config){return{ngModule:RouterTestingModule,providers:[{provide:router_Dwfin5Au.bw,multi:!0,useValue:routes},{provide:router_Dwfin5Au.J_,useValue:config||{}}]}}static ɵfac=function RouterTestingModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||RouterTestingModule)};static ɵmod=core["ɵɵdefineNgModule"]({type:RouterTestingModule,exports:[router_module_DTJgGWLd.iI]});static ɵinj=core["ɵɵdefineInjector"]({providers:[router_module_DTJgGWLd.JG,provideLocationMocks(),(0,router_module_DTJgGWLd.Sn)(router_module_DTJgGWLd.D7).ɵproviders,{provide:router_Dwfin5Au.bw,multi:!0,useValue:[]}],imports:[router_module_DTJgGWLd.iI]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterTestingModule,[{type:core.NgModule,args:[{exports:[router_module_DTJgGWLd.iI],providers:[router_module_DTJgGWLd.JG,provideLocationMocks(),(0,router_module_DTJgGWLd.Sn)(router_module_DTJgGWLd.D7).ɵproviders,{provide:router_Dwfin5Au.bw,multi:!0,useValue:[]}]}]}],null,null);class RootFixtureService{fixture;harness;createHarness(){if(this.harness)throw new Error("Only one harness should be created per test.");return this.harness=new RouterTestingHarness(this.getRootFixture()),this.harness}getRootFixture(){return void 0!==this.fixture||(this.fixture=TestBed.createComponent(RootCmp),this.fixture.detectChanges()),this.fixture}static ɵfac=function RootFixtureService_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootFixtureService)};static ɵprov=core["ɵɵdefineInjectable"]({token:RootFixtureService,factory:RootFixtureService.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootFixtureService,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class RootCmp{outlet;routerOutletData=(0,core.signal)(void 0);static ɵfac=function RootCmp_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootCmp)};static ɵcmp=core["ɵɵdefineComponent"]({type:RootCmp,selectors:[["ng-component"]],viewQuery:function RootCmp_Query(rf,ctx){if(1&rf&&core["ɵɵviewQuery"](router_Dwfin5Au.n3,5),2&rf){let _t;core["ɵɵqueryRefresh"](_t=core["ɵɵloadQuery"]())&&(ctx.outlet=_t.first)}},decls:1,vars:1,consts:[[3,"routerOutletData"]],template:function RootCmp_Template(rf,ctx){1&rf&&core["ɵɵelement"](0,"router-outlet",0),2&rf&&core["ɵɵproperty"]("routerOutletData",ctx.routerOutletData())},dependencies:[router_Dwfin5Au.n3],encapsulation:2})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootCmp,[{type:core.Component,args:[{template:'<router-outlet [routerOutletData]="routerOutletData()"></router-outlet>',imports:[router_Dwfin5Au.n3]}]}],null,{outlet:[{type:core.ViewChild,args:[router_Dwfin5Au.n3]}]});class RouterTestingHarness{static create(initialUrl){return(0,asyncToGenerator.A)((function*(){const harness=TestBed.inject(RootFixtureService).createHarness();return void 0!==initialUrl&&(yield harness.navigateByUrl(initialUrl)),harness}))()}fixture;constructor(fixture){this.fixture=fixture}detectChanges(){this.fixture.detectChanges()}get routeDebugElement(){const outlet=this.fixture.componentInstance.outlet;return outlet&&outlet.isActivated?this.fixture.debugElement.query((v=>v.componentInstance===outlet.component)):null}get routeNativeElement(){return this.routeDebugElement?.nativeElement??null}navigateByUrl(url,requiredRoutedComponentType){var _this=this;return(0,asyncToGenerator.A)((function*(){const router=TestBed.inject(router_Dwfin5Au.Ix);let resolveFn;const redirectTrackingPromise=new Promise((resolve=>{resolveFn=resolve}));(0,router_Dwfin5Au.gk)(TestBed.inject(router_Dwfin5Au.Ix),resolveFn),yield router.navigateByUrl(url),yield redirectTrackingPromise,_this.fixture.detectChanges();const outlet=_this.fixture.componentInstance.outlet;if(outlet&&outlet.isActivated&&outlet.activatedRoute.component){const activatedComponent=outlet.component;if(void 0!==requiredRoutedComponentType&&!(activatedComponent instanceof requiredRoutedComponentType))throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);return activatedComponent}if(void 0!==requiredRoutedComponentType)throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but the navigation did not activate any component.`);return null}))()}}},"./node_modules/rxjs/dist/esm5/internal/observable/interval.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Y:()=>interval});var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/async.js"),_timer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/timer.js");function interval(period,scheduler){return void 0===period&&(period=0),void 0===scheduler&&(scheduler=_scheduler_async__WEBPACK_IMPORTED_MODULE_0__.E),period<0&&(period=0),(0,_timer__WEBPACK_IMPORTED_MODULE_1__.O)(period,period,scheduler)}},"./node_modules/rxjs/dist/esm5/internal/observable/timer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{O:()=>timer});var Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js"),scheduler_async=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/async.js"),isScheduler=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js");function timer(dueTime,intervalOrScheduler,scheduler){void 0===dueTime&&(dueTime=0),void 0===scheduler&&(scheduler=scheduler_async.b);var intervalDuration=-1;return null!=intervalOrScheduler&&((0,isScheduler.m)(intervalOrScheduler)?scheduler=intervalOrScheduler:intervalDuration=intervalOrScheduler),new Observable.c((function(subscriber){var due=function isValidDate(value){return value instanceof Date&&!isNaN(value)}(dueTime)?+dueTime-scheduler.now():dueTime;due<0&&(due=0);var n=0;return scheduler.schedule((function(){subscriber.closed||(subscriber.next(n++),0<=intervalDuration?this.schedule(void 0,intervalDuration):subscriber.complete())}),due)}))}},"./node_modules/rxjs/dist/esm5/internal/scheduler/async.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>async_async,E:()=>asyncScheduler});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),Action=function(_super){function Action(scheduler,work){return _super.call(this)||this}return(0,tslib_es6.C6)(Action,_super),Action.prototype.schedule=function(state,delay){return void 0===delay&&(delay=0),this},Action}(__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js").yU),intervalProvider={setInterval:function(handler,timeout){for(var args=[],_i=2;_i<arguments.length;_i++)args[_i-2]=arguments[_i];var delegate=intervalProvider.delegate;return(null==delegate?void 0:delegate.setInterval)?delegate.setInterval.apply(delegate,(0,tslib_es6.fX)([handler,timeout],(0,tslib_es6.zs)(args))):setInterval.apply(void 0,(0,tslib_es6.fX)([handler,timeout],(0,tslib_es6.zs)(args)))},clearInterval:function(handle){var delegate=intervalProvider.delegate;return((null==delegate?void 0:delegate.clearInterval)||clearInterval)(handle)},delegate:void 0},arrRemove=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"),AsyncAction=function(_super){function AsyncAction(scheduler,work){var _this=_super.call(this,scheduler,work)||this;return _this.scheduler=scheduler,_this.work=work,_this.pending=!1,_this}return(0,tslib_es6.C6)(AsyncAction,_super),AsyncAction.prototype.schedule=function(state,delay){var _a;if(void 0===delay&&(delay=0),this.closed)return this;this.state=state;var id=this.id,scheduler=this.scheduler;return null!=id&&(this.id=this.recycleAsyncId(scheduler,id,delay)),this.pending=!0,this.delay=delay,this.id=null!==(_a=this.id)&&void 0!==_a?_a:this.requestAsyncId(scheduler,this.id,delay),this},AsyncAction.prototype.requestAsyncId=function(scheduler,_id,delay){return void 0===delay&&(delay=0),intervalProvider.setInterval(scheduler.flush.bind(scheduler,this),delay)},AsyncAction.prototype.recycleAsyncId=function(_scheduler,id,delay){if(void 0===delay&&(delay=0),null!=delay&&this.delay===delay&&!1===this.pending)return id;null!=id&&intervalProvider.clearInterval(id)},AsyncAction.prototype.execute=function(state,delay){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;var error=this._execute(state,delay);if(error)return error;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))},AsyncAction.prototype._execute=function(state,_delay){var errorValue,errored=!1;try{this.work(state)}catch(e){errored=!0,errorValue=e||new Error("Scheduled action threw falsy error")}if(errored)return this.unsubscribe(),errorValue},AsyncAction.prototype.unsubscribe=function(){if(!this.closed){var id=this.id,scheduler=this.scheduler,actions=scheduler.actions;this.work=this.state=this.scheduler=null,this.pending=!1,(0,arrRemove.o)(actions,this),null!=id&&(this.id=this.recycleAsyncId(scheduler,id,null)),this.delay=null,_super.prototype.unsubscribe.call(this)}},AsyncAction}(Action),dateTimestampProvider={now:function(){return(dateTimestampProvider.delegate||Date).now()},delegate:void 0},Scheduler=function(){function Scheduler(schedulerActionCtor,now){void 0===now&&(now=Scheduler.now),this.schedulerActionCtor=schedulerActionCtor,this.now=now}return Scheduler.prototype.schedule=function(work,delay,state){return void 0===delay&&(delay=0),new this.schedulerActionCtor(this,work).schedule(state,delay)},Scheduler.now=dateTimestampProvider.now,Scheduler}(),asyncScheduler=new(function(_super){function AsyncScheduler(SchedulerAction,now){void 0===now&&(now=Scheduler.now);var _this=_super.call(this,SchedulerAction,now)||this;return _this.actions=[],_this._active=!1,_this}return(0,tslib_es6.C6)(AsyncScheduler,_super),AsyncScheduler.prototype.flush=function(action){var actions=this.actions;if(this._active)actions.push(action);else{var error;this._active=!0;do{if(error=action.execute(action.state,action.delay))break}while(action=actions.shift());if(this._active=!1,error){for(;action=actions.shift();)action.unsubscribe();throw error}}},AsyncScheduler}(Scheduler))(AsyncAction),async_async=asyncScheduler}}]);