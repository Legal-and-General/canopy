/*! For license information please see 65212.045c5a9a.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_legal_and_general_canopy=self.webpackChunk_legal_and_general_canopy||[]).push([[65212],{"./node_modules/@angular/router/fesm2022/testing.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{c1:()=>RouterTestingModule});var asyncToGenerator=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),debug_node=__webpack_require__("./node_modules/@angular/core/fesm2022/debug_node.mjs"),root_effect_scheduler=__webpack_require__("./node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),Subscription=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js"),compiler=__webpack_require__("./node_modules/@angular/compiler/fesm2022/compiler.mjs");class TestBedApplicationErrorHandler{zone=(0,root_effect_scheduler.WQX)(debug_node.SKi);injector=(0,root_effect_scheduler.WQX)(root_effect_scheduler.uvJ);userErrorHandler;whenStableRejectFunctions=new Set;handleError(e){try{this.zone.runOutsideAngular(()=>{this.userErrorHandler??=this.injector.get(root_effect_scheduler.zcH),this.userErrorHandler.handleError(e)})}catch(userError){e=userError}if(!(this.whenStableRejectFunctions.size>0))throw e;for(const fn of this.whenStableRejectFunctions.values())fn(e);this.whenStableRejectFunctions.clear()}static ɵfac=function TestBedApplicationErrorHandler_Factory(__ngFactoryType__){return new(__ngFactoryType__||TestBedApplicationErrorHandler)};static ɵprov=root_effect_scheduler.jDH({token:TestBedApplicationErrorHandler,factory:TestBedApplicationErrorHandler.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(TestBedApplicationErrorHandler,[{type:debug_node._qm}],null,null);class DeferBlockFixture{block;componentFixture;constructor(block,componentFixture){this.block=block,this.componentFixture=componentFixture}render(state){var _this=this;return(0,asyncToGenerator.A)(function*(){if(!function hasStateTemplate(state,block){switch(state){case debug_node.DnF.Placeholder:return null!==block.tDetails.placeholderTmplIndex;case debug_node.DnF.Loading:return null!==block.tDetails.loadingTmplIndex;case debug_node.DnF.Error:return null!==block.tDetails.errorTmplIndex;case debug_node.DnF.Complete:return!0;default:return!1}}(state,_this.block)){const stateAsString=function getDeferBlockStateNameFromEnum(state){switch(state){case debug_node.DnF.Placeholder:return"Placeholder";case debug_node.DnF.Loading:return"Loading";case debug_node.DnF.Error:return"Error";default:return"Main"}}(state);throw new Error(`Tried to render this defer block in the \`${stateAsString}\` state, but there was no @${stateAsString.toLowerCase()} block defined in a template.`)}state===debug_node.DnF.Complete&&(yield(0,debug_node.n5O)(_this.block.tDetails,_this.block.lView,_this.block.tNode));(0,debug_node.Hlh)(state,_this.block.tNode,_this.block.lContainer,!0),_this.componentFixture.detectChanges()})()}getDeferBlocks(){const deferBlocks=[],deferBlockFixtures=[];if(this.block.lContainer.length>=root_effect_scheduler.Y20){const lView=this.block.lContainer[root_effect_scheduler.Y20];(0,debug_node.xHs)(lView,deferBlocks);for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this.componentFixture))}return Promise.resolve(deferBlockFixtures)}}const DEFER_BLOCK_DEFAULT_BEHAVIOR=debug_node.saZ.Playthrough;class TestComponentRenderer{insertRootElement(rootElementId,tagName){}removeAllRootElements(){}}const ComponentFixtureAutoDetect=new root_effect_scheduler.nKC("ComponentFixtureAutoDetect"),ComponentFixtureNoNgZone=new root_effect_scheduler.nKC("ComponentFixtureNoNgZone");class ComponentFixture{componentRef;debugElement;componentInstance;nativeElement;elementRef;changeDetectorRef;_renderer;_isDestroyed=!1;_noZoneOptionIsSet=(0,root_effect_scheduler.WQX)(ComponentFixtureNoNgZone,{optional:!0});_ngZone=this._noZoneOptionIsSet?new debug_node.myG:(0,root_effect_scheduler.WQX)(debug_node.SKi);_appRef=(0,root_effect_scheduler.WQX)(debug_node.o8S);_testAppRef=this._appRef;pendingTasks=(0,root_effect_scheduler.WQX)(root_effect_scheduler.rev);appErrorHandler=(0,root_effect_scheduler.WQX)(TestBedApplicationErrorHandler);zonelessEnabled=(0,root_effect_scheduler.WQX)(root_effect_scheduler.Evm);scheduler=(0,root_effect_scheduler.WQX)(root_effect_scheduler.hk6);rootEffectScheduler=(0,root_effect_scheduler.WQX)(root_effect_scheduler.VML);autoDetectDefault=!!this.zonelessEnabled;autoDetect=(0,root_effect_scheduler.WQX)(ComponentFixtureAutoDetect,{optional:!0})??this.autoDetectDefault;subscriptions=new Subscription.yU;ngZone=this._noZoneOptionIsSet?null:this._ngZone;constructor(componentRef){this.componentRef=componentRef,this.changeDetectorRef=componentRef.changeDetectorRef,this.elementRef=componentRef.location,this.debugElement=(0,debug_node.uRB)(this.elementRef.nativeElement),this.componentInstance=componentRef.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=componentRef,this._testAppRef.allTestViews.add(this.componentRef.hostView),this.autoDetect&&(this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView),this.scheduler?.notify(8),this.scheduler?.notify(0)),this.componentRef.hostView.onDestroy(()=>{this._testAppRef.allTestViews.delete(this.componentRef.hostView),this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView)}),this._ngZone.runOutsideAngular(()=>{this.subscriptions.add(this._ngZone.onError.subscribe({next:error=>{if("undefined"!=typeof Zone&&!Zone.current.get("FakeAsyncTestZoneSpec"))throw error}}))})}detectChanges(checkNoChanges=!0){const originalCheckNoChanges=this.componentRef.changeDetectorRef.checkNoChanges;try{if(checkNoChanges||(this.componentRef.changeDetectorRef.checkNoChanges=()=>{}),this.zonelessEnabled)try{this._testAppRef.includeAllTestViews=!0,this._appRef.tick()}finally{this._testAppRef.includeAllTestViews=!1}else this._ngZone.run(()=>{this.rootEffectScheduler.flush(),this.changeDetectorRef.detectChanges(),this.checkNoChanges()})}finally{this.componentRef.changeDetectorRef.checkNoChanges=originalCheckNoChanges}}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}autoDetectChanges(autoDetect=!0){if(!autoDetect&&this.zonelessEnabled)throw new Error("Cannot set autoDetect to false with zoneless change detection.");if(this._noZoneOptionIsSet&&!this.zonelessEnabled)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.");autoDetect?this._testAppRef.autoDetectTestViews.add(this.componentRef.hostView):this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView),this.autoDetect=autoDetect,this.detectChanges()}isStable(){return!this.pendingTasks.hasPendingTasks}whenStable(){return this.isStable()?Promise.resolve(!1):new Promise((resolve,reject)=>{this.appErrorHandler.whenStableRejectFunctions.add(reject),this._appRef.whenStable().then(()=>{this.appErrorHandler.whenStableRejectFunctions.delete(reject),resolve(!0)})})}getDeferBlocks(){const deferBlocks=[],lView=this.componentRef.hostView._lView;(0,debug_node.xHs)(lView,deferBlocks);const deferBlockFixtures=[];for(const block of deferBlocks)deferBlockFixtures.push(new DeferBlockFixture(block,this));return Promise.resolve(deferBlockFixtures)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(debug_node._9s,null)),this._renderer}whenRenderingDone(){const renderer=this._getRenderer();return renderer&&renderer.whenRenderingDone?renderer.whenRenderingDone():this.whenStable()}destroy(){this.subscriptions.unsubscribe(),this._testAppRef.autoDetectTestViews.delete(this.componentRef.hostView),this._testAppRef.allTestViews.delete(this.componentRef.hostView),this._isDestroyed||(this.componentRef.destroy(),this._isDestroyed=!0)}}const _Zone="undefined"!=typeof Zone?Zone:null;function getFakeAsyncTestModule(){return _Zone&&_Zone[_Zone.__symbol__("fakeAsyncTest")]}let _nextReferenceId=0;class MetadataOverrider{_references=new Map;overrideMetadata(metadataClass,oldMetadata,override){const props={};if(oldMetadata&&function _valueProps(obj){const props=[];Object.keys(obj).forEach(prop=>{prop.startsWith("_")||props.push(prop)});let proto=obj;for(;proto=Object.getPrototypeOf(proto);)Object.keys(proto).forEach(protoProp=>{const desc=Object.getOwnPropertyDescriptor(proto,protoProp);!protoProp.startsWith("_")&&desc&&"get"in desc&&props.push(protoProp)});return props}(oldMetadata).forEach(prop=>props[prop]=oldMetadata[prop]),override.set){if(override.remove||override.add)throw new Error(`Cannot set and add/remove ${(0,root_effect_scheduler.AsM)(metadataClass)} at the same time!`);!function setMetadata(metadata,set){for(const prop in set)metadata[prop]=set[prop]}(props,override.set)}return override.remove&&function removeMetadata(metadata,remove,references){const removeObjects=new Set;for(const prop in remove){const removeValue=remove[prop];Array.isArray(removeValue)?removeValue.forEach(value=>{removeObjects.add(_propHashKey(prop,value,references))}):removeObjects.add(_propHashKey(prop,removeValue,references))}for(const prop in metadata){const propValue=metadata[prop];Array.isArray(propValue)?metadata[prop]=propValue.filter(value=>!removeObjects.has(_propHashKey(prop,value,references))):removeObjects.has(_propHashKey(prop,propValue,references))&&(metadata[prop]=void 0)}}(props,override.remove,this._references),override.add&&function addMetadata(metadata,add){for(const prop in add){const addValue=add[prop],propValue=metadata[prop];null!=propValue&&Array.isArray(propValue)?metadata[prop]=propValue.concat(addValue):metadata[prop]=addValue}}(props,override.add),new metadataClass(props)}}function _propHashKey(propName,propValue,references){let nextObjectId=0;const objectIds=new Map;return`${propName}:${JSON.stringify(propValue,(key,value)=>null!==value&&"object"==typeof value?objectIds.has(value)?objectIds.get(value):(objectIds.set(value,"ɵobj#"+nextObjectId++),value):("function"==typeof value&&(value=function _serializeReference(ref,references){let id=references.get(ref);id||(id=`${(0,root_effect_scheduler.AsM)(ref)}${_nextReferenceId++}`,references.set(ref,id));return id}(value,references)),value))}`}const reflection=new debug_node.XKJ;class OverrideResolver{overrides=new Map;resolved=new Map;addOverride(type,override){const overrides=this.overrides.get(type)||[];overrides.push(override),this.overrides.set(type,overrides),this.resolved.delete(type)}setOverrides(overrides){this.overrides.clear(),overrides.forEach(([type,override])=>{this.addOverride(type,override)})}getAnnotation(type){const annotations=reflection.annotations(type);for(let i=annotations.length-1;i>=0;i--){const annotation=annotations[i];if(annotation instanceof debug_node.WLR||annotation instanceof debug_node.uAl||annotation instanceof debug_node.nT_||annotation instanceof debug_node.UQu)return annotation instanceof this.type?annotation:null}return null}resolve(type){let resolved=this.resolved.get(type)||null;if(!resolved){if(resolved=this.getAnnotation(type),resolved){const overrides=this.overrides.get(type);if(overrides){const overrider=new MetadataOverrider;overrides.forEach(override=>{resolved=overrider.overrideMetadata(this.type,resolved,override)})}}this.resolved.set(type,resolved)}return resolved}}class DirectiveResolver extends OverrideResolver{get type(){return debug_node.WLR}}class ComponentResolver extends OverrideResolver{get type(){return debug_node.uAl}}class PipeResolver extends OverrideResolver{get type(){return debug_node.nT_}}class NgModuleResolver extends OverrideResolver{get type(){return debug_node.UQu}}var TestingModuleOverride;function assertNoStandaloneComponents(types,resolver,location){types.forEach(type=>{if(!(0,debug_node.Cpm)(type)){const component=resolver.resolve(type);if(component&&(null==component.standalone||component.standalone))throw new Error((0,debug_node.ZX9)(type,location))}})}!function(TestingModuleOverride){TestingModuleOverride[TestingModuleOverride.DECLARATION=0]="DECLARATION",TestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"}(TestingModuleOverride||(TestingModuleOverride={}));class TestBedCompiler{platform;additionalModuleTypes;originalComponentResolutionQueue=null;declarations=[];imports=[];providers=[];schemas=[];pendingComponents=new Set;pendingDirectives=new Set;pendingPipes=new Set;componentsWithAsyncMetadata=new Set;seenComponents=new Set;seenDirectives=new Set;overriddenModules=new Set;existingComponentStyles=new Map;resolvers=function initResolvers(){return{module:new NgModuleResolver,component:new ComponentResolver,directive:new DirectiveResolver,pipe:new PipeResolver}}();componentToModuleScope=new Map;initialNgDefs=new Map;defCleanupOps=[];_injector=null;compilerProviders=null;providerOverrides=[];rootProviderOverrides=[];providerOverridesByModule=new Map;providerOverridesByToken=new Map;scopesWithOverriddenProviders=new Set;testModuleType;testModuleRef=null;animationsEnabled=false;deferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR;rethrowApplicationTickErrors=true;constructor(platform,additionalModuleTypes){this.platform=platform,this.additionalModuleTypes=additionalModuleTypes;this.testModuleType=class DynamicTestModule{}}setCompilerProviders(providers){this.compilerProviders=providers,this._injector=null}configureTestingModule(moduleDef){void 0!==moduleDef.declarations&&(assertNoStandaloneComponents(moduleDef.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(moduleDef.declarations,TestingModuleOverride.DECLARATION),this.declarations.push(...moduleDef.declarations)),void 0!==moduleDef.imports&&(this.queueTypesFromModulesArray(moduleDef.imports),this.imports.push(...moduleDef.imports)),void 0!==moduleDef.providers&&this.providers.push(...moduleDef.providers),void 0!==moduleDef.schemas&&this.schemas.push(...moduleDef.schemas),this.deferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR,this.animationsEnabled=moduleDef.animationsEnabled??false,this.rethrowApplicationTickErrors=moduleDef.rethrowApplicationErrors??true}overrideModule(ngModule,override){debug_node.ZKm.clearScopeCacheFor(ngModule),this.overriddenModules.add(ngModule),this.resolvers.module.addOverride(ngModule,override);const metadata=this.resolvers.module.resolve(ngModule);if(null===metadata)throw invalidTypeError(ngModule.name,"NgModule");this.recompileNgModule(ngModule,metadata),this.queueTypesFromModulesArray([ngModule])}overrideComponent(component,override){this.verifyNoStandaloneFlagOverrides(component,override),this.resolvers.component.addOverride(component,override),this.pendingComponents.add(component),this.maybeRegisterComponentWithAsyncMetadata(component)}overrideDirective(directive,override){this.verifyNoStandaloneFlagOverrides(directive,override),this.resolvers.directive.addOverride(directive,override),this.pendingDirectives.add(directive)}overridePipe(pipe,override){this.verifyNoStandaloneFlagOverrides(pipe,override),this.resolvers.pipe.addOverride(pipe,override),this.pendingPipes.add(pipe)}verifyNoStandaloneFlagOverrides(type,override){if(override.add?.hasOwnProperty("standalone")||override.set?.hasOwnProperty("standalone")||override.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${type.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(token,provider){let providerDef;providerDef=void 0!==provider.useFactory?{provide:token,useFactory:provider.useFactory,deps:provider.deps||[],multi:provider.multi}:void 0!==provider.useValue?{provide:token,useValue:provider.useValue,multi:provider.multi}:{provide:token};const injectableDef="string"!=typeof token?(0,root_effect_scheduler.rrq)(token):null,providedIn=null===injectableDef?null:(0,root_effect_scheduler.nl4)(injectableDef.providedIn);if(("root"===providedIn?this.rootProviderOverrides:this.providerOverrides).push(providerDef),this.providerOverridesByToken.set(token,providerDef),null!==injectableDef&&null!==providedIn&&"string"!=typeof providedIn){const existingOverrides=this.providerOverridesByModule.get(providedIn);void 0!==existingOverrides?existingOverrides.push(providerDef):this.providerOverridesByModule.set(providedIn,[providerDef])}}overrideTemplateUsingTestingModule(type,template){const def=type[root_effect_scheduler.CQl],overrideStyleUrls=!!def&&!(0,debug_node.uuc)(type)&&(()=>{const metadata=this.resolvers.component.resolve(type);return!!metadata.styleUrl||!!metadata.styleUrls?.length})(),override=overrideStyleUrls?{template,styles:[],styleUrls:[],styleUrl:void 0}:{template};this.overrideComponent(type,{set:override}),overrideStyleUrls&&def.styles&&def.styles.length>0&&this.existingComponentStyles.set(type,def.styles),this.componentToModuleScope.set(type,TestingModuleOverride.OVERRIDE_TEMPLATE)}resolvePendingComponentsWithAsyncMetadata(){var _this2=this;return(0,asyncToGenerator.A)(function*(){if(0===_this2.componentsWithAsyncMetadata.size)return;const promises=[];for(const component of _this2.componentsWithAsyncMetadata){const asyncMetadataFn=(0,debug_node.Cpm)(component);asyncMetadataFn&&promises.push(asyncMetadataFn())}_this2.componentsWithAsyncMetadata.clear();const flatResolvedDeps=(yield Promise.all(promises)).flat(2);_this2.queueTypesFromModulesArray(flatResolvedDeps);for(const component of flatResolvedDeps)_this2.applyProviderOverridesInScope(component)})()}compileComponents(){var _this3=this;return(0,asyncToGenerator.A)(function*(){if(_this3.clearComponentResolutionQueue(),yield _this3.resolvePendingComponentsWithAsyncMetadata(),assertNoStandaloneComponents(_this3.declarations,_this3.resolvers.component,'"TestBed.configureTestingModule" call'),_this3.compileTypesSync()){let resourceLoader,resolver=url=>(resourceLoader||(resourceLoader=_this3.injector.get(compiler.WHm)),Promise.resolve(resourceLoader.get(url)));yield(0,debug_node.Zhj)(resolver)}})()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const parentInjector=this.platform.injector;this.testModuleRef=new debug_node.Vns(this.testModuleType,parentInjector,[]),this.testModuleRef.injector.get(debug_node.H1s).runInitializers();const localeId=this.testModuleRef.injector.get(debug_node.xe9,debug_node.DkB);return(0,debug_node.e6s)(localeId),this.testModuleRef}_compileNgModuleSync(moduleType){this.queueTypesFromModulesArray([moduleType]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(moduleType),this.applyTransitiveScopes()}_compileNgModuleAsync(moduleType){var _this4=this;return(0,asyncToGenerator.A)(function*(){_this4.queueTypesFromModulesArray([moduleType]),yield _this4.compileComponents(),_this4.applyProviderOverrides(),_this4.applyProviderOverridesInScope(moduleType),_this4.applyTransitiveScopes()})()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(moduleType){return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories,declaration)=>{const componentDef=declaration.ɵcmp;return componentDef&&factories.push(new debug_node.eHC(componentDef,this.testModuleRef)),factories},[])}compileTypesSync(){let needsAsyncResources=!1;return this.pendingComponents.forEach(declaration=>{if((0,debug_node.Cpm)(declaration))throw new Error(`Component '${declaration.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);needsAsyncResources=needsAsyncResources||(0,debug_node.uuc)(declaration);const metadata=this.resolvers.component.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Component");this.maybeStoreNgDef(root_effect_scheduler.CQl,declaration),debug_node.ZKm.clearScopeCacheFor(declaration),(0,debug_node.$RC)(declaration,metadata)}),this.pendingComponents.clear(),this.pendingDirectives.forEach(declaration=>{const metadata=this.resolvers.directive.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Directive");this.maybeStoreNgDef(root_effect_scheduler.CZt,declaration),(0,debug_node.jqK)(declaration,metadata)}),this.pendingDirectives.clear(),this.pendingPipes.forEach(declaration=>{const metadata=this.resolvers.pipe.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Pipe");this.maybeStoreNgDef(root_effect_scheduler.Vx9,declaration),(0,debug_node.QMp)(declaration,metadata)}),this.pendingPipes.clear(),needsAsyncResources}applyTransitiveScopes(){if(this.overriddenModules.size>0){const testingModuleDef=this.testModuleType[root_effect_scheduler.hmW],affectedModules=this.collectModulesAffectedByOverrides(testingModuleDef.imports);affectedModules.size>0&&affectedModules.forEach(moduleType=>{debug_node.ZKm.clearScopeCacheFor(moduleType)})}const moduleToScope=new Map,getScopeOfModule=moduleType=>{if(!moduleToScope.has(moduleType)){const realType=function isTestingModuleOverride(value){return value===TestingModuleOverride.DECLARATION||value===TestingModuleOverride.OVERRIDE_TEMPLATE}(moduleType)?this.testModuleType:moduleType;moduleToScope.set(moduleType,(0,debug_node.QEn)(realType))}return moduleToScope.get(moduleType)};this.componentToModuleScope.forEach((moduleType,componentType)=>{if(null!==moduleType){const moduleScope=getScopeOfModule(moduleType);this.storeFieldOfDefOnType(componentType,root_effect_scheduler.CQl,"directiveDefs"),this.storeFieldOfDefOnType(componentType,root_effect_scheduler.CQl,"pipeDefs"),(0,debug_node.jdi)(getComponentDef(componentType),moduleScope)}this.storeFieldOfDefOnType(componentType,root_effect_scheduler.CQl,"tView")}),this.componentToModuleScope.clear()}applyProviderOverrides(){const maybeApplyOverrides=field=>type=>{const metadata=(field===root_effect_scheduler.CQl?this.resolvers.component:this.resolvers.directive).resolve(type);this.hasProviderOverrides(metadata.providers)&&this.patchDefWithProviderOverrides(type,field)};this.seenComponents.forEach(maybeApplyOverrides(root_effect_scheduler.CQl)),this.seenDirectives.forEach(maybeApplyOverrides(root_effect_scheduler.CZt)),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(type){if(!(isStandaloneComponent(type)||function isNgModule(value){return hasNgModuleDef(value)}(type))||this.scopesWithOverriddenProviders.has(type))return;this.scopesWithOverriddenProviders.add(type);const injectorDef=type[root_effect_scheduler.ONQ];if(0!==this.providerOverridesByToken.size)if(isStandaloneComponent(type)){const dependencies=maybeUnwrapFn(getComponentDef(type).dependencies??[]);for(const dependency of dependencies)this.applyProviderOverridesInScope(dependency)}else{const providers=[...injectorDef.providers,...this.providerOverridesByModule.get(type)||[]];this.hasProviderOverrides(providers)&&(this.maybeStoreNgDef(root_effect_scheduler.ONQ,type),this.storeFieldOfDefOnType(type,root_effect_scheduler.ONQ,"providers"),injectorDef.providers=this.getOverriddenProviders(providers));const imports=maybeUnwrapFn(type[root_effect_scheduler.hmW].imports);for(const importedModule of imports)this.applyProviderOverridesInScope(importedModule);for(const importedModule of flatten(injectorDef.imports))isModuleWithProviders(importedModule)&&(this.defCleanupOps.push({object:importedModule,fieldName:"providers",originalValue:importedModule.providers}),importedModule.providers=this.getOverriddenProviders(importedModule.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach((styles,type)=>type[root_effect_scheduler.CQl].styles=styles),this.existingComponentStyles.clear()}queueTypeArray(arr,moduleType){for(const value of arr)Array.isArray(value)?this.queueTypeArray(value,moduleType):this.queueType(value,moduleType)}recompileNgModule(ngModule,metadata){this.maybeStoreNgDef(root_effect_scheduler.hmW,ngModule),this.maybeStoreNgDef(root_effect_scheduler.ONQ,ngModule),(0,debug_node.FW2)(ngModule,metadata)}maybeRegisterComponentWithAsyncMetadata(type){(0,debug_node.Cpm)(type)&&this.componentsWithAsyncMetadata.add(type)}queueType(type,moduleType){this.maybeRegisterComponentWithAsyncMetadata(type);if(this.resolvers.component.resolve(type))return!(0,debug_node.uuc)(type)&&type.hasOwnProperty(root_effect_scheduler.CQl)||this.pendingComponents.add(type),this.seenComponents.add(type),void(this.componentToModuleScope.has(type)&&this.componentToModuleScope.get(type)!==TestingModuleOverride.DECLARATION||this.componentToModuleScope.set(type,moduleType));if(this.resolvers.directive.resolve(type))return type.hasOwnProperty(root_effect_scheduler.CZt)||this.pendingDirectives.add(type),void this.seenDirectives.add(type);!this.resolvers.pipe.resolve(type)||type.hasOwnProperty(root_effect_scheduler.Vx9)||this.pendingPipes.add(type)}queueTypesFromModulesArray(arr){const processedDefs=new Set,queueTypesFromModulesArrayRecur=arr=>{for(const value of arr)if(Array.isArray(value))queueTypesFromModulesArrayRecur(value);else if(hasNgModuleDef(value)){const def=value.ɵmod;if(processedDefs.has(def))continue;processedDefs.add(def),this.queueTypeArray(maybeUnwrapFn(def.declarations),value),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports)),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports))}else if(isModuleWithProviders(value))queueTypesFromModulesArrayRecur([value.ngModule]);else if(isStandaloneComponent(value)){this.queueType(value,null);const def=getComponentDef(value);if(processedDefs.has(def))continue;processedDefs.add(def);maybeUnwrapFn(def.dependencies??[]).forEach(dependency=>{isStandaloneComponent(dependency)||hasNgModuleDef(dependency)?queueTypesFromModulesArrayRecur([dependency]):this.queueType(dependency,null)})}};queueTypesFromModulesArrayRecur(arr)}collectModulesAffectedByOverrides(arr){const seenModules=new Set,affectedModules=new Set,calcAffectedModulesRecur=(arr,path)=>{for(const value of arr)if(Array.isArray(value))calcAffectedModulesRecur(value,path);else if(hasNgModuleDef(value)){if(seenModules.has(value)){affectedModules.has(value)&&path.forEach(item=>affectedModules.add(item));continue}seenModules.add(value),this.overriddenModules.has(value)&&path.forEach(item=>affectedModules.add(item));const moduleDef=value[root_effect_scheduler.hmW];calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports),path.concat(value))}};return calcAffectedModulesRecur(arr,[]),affectedModules}maybeStoreNgDef(prop,type){this.initialNgDefs.has(type)||this.initialNgDefs.set(type,new Map);const currentDefs=this.initialNgDefs.get(type);if(!currentDefs.has(prop)){const currentDef=Object.getOwnPropertyDescriptor(type,prop);currentDefs.set(prop,currentDef)}}storeFieldOfDefOnType(type,defField,fieldName){const def=type[defField],originalValue=def[fieldName];this.defCleanupOps.push({object:def,fieldName,originalValue})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),(0,debug_node.ik9)().forEach((value,key)=>this.originalComponentResolutionQueue.set(key,value))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&((0,debug_node.Za0)(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){forEachRight(this.defCleanupOps,op=>{op.object[op.fieldName]=op.originalValue}),this.initialNgDefs.forEach((defs,type)=>{debug_node.ZKm.clearScopeCacheFor(type),defs.forEach((descriptor,prop)=>{descriptor?Object.defineProperty(type,prop,descriptor):delete type[prop]})}),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,debug_node.e6s)(debug_node.DkB)}compileTestModule(){class RootScopeModule{}(0,debug_node.FW2)(RootScopeModule,{providers:[...this.rootProviderOverrides,(0,debug_node.SdI)({}),TestBedApplicationErrorHandler,{provide:root_effect_scheduler.hk6,useExisting:debug_node.Ts$},{provide:root_effect_scheduler.Z63,multi:!0,useValue:()=>{(0,root_effect_scheduler.WQX)(root_effect_scheduler.zcH)}}]});const providers=[{provide:debug_node.Ql9,useFactory:()=>new R3TestCompiler(this)},{provide:debug_node.Mlj,useValue:{behavior:this.deferBlockBehavior}},{provide:debug_node.DG8,useValue:!this.animationsEnabled},{provide:root_effect_scheduler.ZTf,useFactory:()=>{if(this.rethrowApplicationTickErrors){const handler=(0,root_effect_scheduler.WQX)(TestBedApplicationErrorHandler);return e=>{handler.handleError(e)}}{const userErrorHandler=(0,root_effect_scheduler.WQX)(root_effect_scheduler.zcH),ngZone=(0,root_effect_scheduler.WQX)(debug_node.SKi);return e=>ngZone.runOutsideAngular(()=>userErrorHandler.handleError(e))}}},...this.providers,...this.providerOverrides],imports=[RootScopeModule,this.additionalModuleTypes,this.imports||[]];(0,debug_node.FW2)(this.testModuleType,{declarations:this.declarations,imports,schemas:this.schemas,providers},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const providers=[];return this.platform.injector.get(debug_node.d80,[]).forEach(opts=>{opts.providers&&providers.push(opts.providers)}),null!==this.compilerProviders&&providers.push(...this.compilerProviders),this._injector=root_effect_scheduler.zZn.create({providers,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(provider){const token=getProviderToken(provider);return this.providerOverridesByToken.get(token)||null}getProviderOverrides(providers){return providers&&providers.length&&0!==this.providerOverridesByToken.size?flatten(flattenProviders(providers,provider=>this.getSingleProviderOverrides(provider)||[])):[]}getOverriddenProviders(providers){if(!providers||!providers.length||0===this.providerOverridesByToken.size)return[];const flattenedProviders=flattenProviders(providers),overrides=this.getProviderOverrides(flattenedProviders),overriddenProviders=[...flattenedProviders,...overrides],final=[],seenOverriddenProviders=new Set;return forEachRight(overriddenProviders,provider=>{const token=getProviderToken(provider);this.providerOverridesByToken.has(token)?seenOverriddenProviders.has(token)||(seenOverriddenProviders.add(token),final.unshift({...provider,multi:!1})):final.unshift(provider)}),final}hasProviderOverrides(providers){return this.getProviderOverrides(providers).length>0}patchDefWithProviderOverrides(declaration,field){const def=declaration[field];if(def&&def.providersResolver){this.maybeStoreNgDef(field,declaration);const resolver=def.providersResolver,processProvidersFn=providers=>this.getOverriddenProviders(providers);this.storeFieldOfDefOnType(declaration,field,"providersResolver"),def.providersResolver=ngDef=>resolver(ngDef,processProvidersFn)}}}function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}function getComponentDef(value){return value.ɵcmp??null}function hasNgModuleDef(value){return value.hasOwnProperty("ɵmod")}function maybeUnwrapFn(maybeFn){return maybeFn instanceof Function?maybeFn():maybeFn}function flatten(values){const out=[];return values.forEach(value=>{Array.isArray(value)?out.push(...flatten(value)):out.push(value)}),out}function identityFn(value){return value}function flattenProviders(providers,mapFn=identityFn){const out=[];for(let provider of providers)(0,root_effect_scheduler._y6)(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?out.push(...flattenProviders(provider,mapFn)):out.push(mapFn(provider));return out}function getProviderToken(provider){return function getProviderField(provider,field){return provider&&"object"==typeof provider&&provider[field]}(provider,"provide")||provider}function isModuleWithProviders(value){return value.hasOwnProperty("ngModule")}function forEachRight(values,fn){for(let idx=values.length-1;idx>=0;idx--)fn(values[idx],idx)}function invalidTypeError(name,expectedType){return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`)}class R3TestCompiler{testBed;constructor(testBed){this.testBed=testBed}compileModuleSync(moduleType){return this.testBed._compileNgModuleSync(moduleType),new debug_node.Co$(moduleType)}compileModuleAsync(moduleType){var _this5=this;return(0,asyncToGenerator.A)(function*(){return yield _this5.testBed._compileNgModuleAsync(moduleType),new debug_node.Co$(moduleType)})()}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=this.testBed._getComponentFactories(moduleType);return new debug_node.S7R(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){var _this6=this;return(0,asyncToGenerator.A)(function*(){const ngModuleFactory=yield _this6.compileModuleAsync(moduleType),componentFactories=_this6.testBed._getComponentFactories(moduleType);return new debug_node.S7R(ngModuleFactory,componentFactories)})()}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){const meta=this.testBed._getModuleResolver().resolve(moduleType);return meta&&meta.id||void 0}}let _nextRootElementId=0;class TestBedImpl{static _INSTANCE=null;static get INSTANCE(){return TestBedImpl._INSTANCE=TestBedImpl._INSTANCE||new TestBedImpl}static _environmentTeardownOptions;static _environmentErrorOnUnknownElementsOption;static _environmentErrorOnUnknownPropertiesOption;_instanceTeardownOptions;_instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR;_instanceAnimationsEnabled=false;_instanceErrorOnUnknownElementsOption;_instanceErrorOnUnknownPropertiesOption;_previousErrorOnUnknownElementsOption;_previousErrorOnUnknownPropertiesOption;_instanceInferTagName;static initTestEnvironment(ngModule,platform,options){const testBed=TestBedImpl.INSTANCE;return testBed.initTestEnvironment(ngModule,platform,options),testBed}static resetTestEnvironment(){TestBedImpl.INSTANCE.resetTestEnvironment()}static configureCompiler(config){return TestBedImpl.INSTANCE.configureCompiler(config)}static configureTestingModule(moduleDef){return TestBedImpl.INSTANCE.configureTestingModule(moduleDef)}static compileComponents(){return TestBedImpl.INSTANCE.compileComponents()}static overrideModule(ngModule,override){return TestBedImpl.INSTANCE.overrideModule(ngModule,override)}static overrideComponent(component,override){return TestBedImpl.INSTANCE.overrideComponent(component,override)}static overrideDirective(directive,override){return TestBedImpl.INSTANCE.overrideDirective(directive,override)}static overridePipe(pipe,override){return TestBedImpl.INSTANCE.overridePipe(pipe,override)}static overrideTemplate(component,template){return TestBedImpl.INSTANCE.overrideTemplate(component,template)}static overrideTemplateUsingTestingModule(component,template){return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component,template)}static overrideProvider(token,provider){return TestBedImpl.INSTANCE.overrideProvider(token,provider)}static inject(token,notFoundValue,options){return TestBedImpl.INSTANCE.inject(token,notFoundValue,options)}static runInInjectionContext(fn){return TestBedImpl.INSTANCE.runInInjectionContext(fn)}static createComponent(component,options){return TestBedImpl.INSTANCE.createComponent(component,options)}static resetTestingModule(){return TestBedImpl.INSTANCE.resetTestingModule()}static execute(tokens,fn,context){return TestBedImpl.INSTANCE.execute(tokens,fn,context)}static get platform(){return TestBedImpl.INSTANCE.platform}static get ngModule(){return TestBedImpl.INSTANCE.ngModule}static flushEffects(){return TestBedImpl.INSTANCE.tick()}static tick(){return TestBedImpl.INSTANCE.tick()}platform=null;ngModule=null;_compiler=null;_testModuleRef=null;_activeFixtures=[];globalCompilationChecked=!1;initTestEnvironment(ngModule,platform,options){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");TestBedImpl._environmentTeardownOptions=options?.teardown,TestBedImpl._environmentErrorOnUnknownElementsOption=options?.errorOnUnknownElements,TestBedImpl._environmentErrorOnUnknownPropertiesOption=options?.errorOnUnknownProperties,this.platform=platform,this.ngModule=ngModule,this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,debug_node.Peg)(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,TestBedImpl._environmentTeardownOptions=void 0,(0,debug_node.Peg)(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,debug_node.Ded)(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,debug_node.kx9)(this._previousErrorOnUnknownElementsOption??false),(0,debug_node.Hd_)(this._previousErrorOnUnknownPropertiesOption??false);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0,this._instanceInferTagName=void 0,this._instanceDeferBlockBehavior=DEFER_BLOCK_DEFAULT_BEHAVIOR,this._instanceAnimationsEnabled=false}}return this}configureCompiler(config){if(null!=config.useJit)throw new Error("JIT compiler is not configurable via TestBed APIs.");return void 0!==config.providers&&this.compiler.setCompilerProviders(config.providers),this}configureTestingModule(moduleDef){return this.assertNotInstantiated("TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=moduleDef.teardown,this._instanceErrorOnUnknownElementsOption=moduleDef.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=moduleDef.errorOnUnknownProperties,this._instanceInferTagName=moduleDef.inferTagName,this._instanceDeferBlockBehavior=moduleDef.deferBlockBehavior??DEFER_BLOCK_DEFAULT_BEHAVIOR,this._instanceAnimationsEnabled=moduleDef.animationsEnabled??false,this._previousErrorOnUnknownElementsOption=(0,debug_node.GaJ)(),(0,debug_node.kx9)(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,debug_node.x4$)(),(0,debug_node.Hd_)(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(moduleDef),this}compileComponents(){return this.compiler.compileComponents()}inject(token,notFoundValue,options){if(token===TestBed)return this;const UNDEFINED={},result=this.testModuleRef.injector.get(token,UNDEFINED,options);return result===UNDEFINED?this.compiler.injector.get(token,notFoundValue,options):result}runInInjectionContext(fn){return(0,root_effect_scheduler.N4e)(this.inject(root_effect_scheduler.uvJ),fn)}execute(tokens,fn,context){const params=tokens.map(t=>this.inject(t));return fn.apply(context,params)}overrideModule(ngModule,override){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(ngModule,override),this}overrideComponent(component,override){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(component,override),this}overrideTemplateUsingTestingModule(component,template){return this.assertNotInstantiated("TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(component,template),this}overrideDirective(directive,override){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(directive,override),this}overridePipe(pipe,override){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(pipe,override),this}overrideProvider(token,provider){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(token,provider),this}overrideTemplate(component,template){return this.overrideComponent(component,{set:{template,templateUrl:null}})}createComponent(type,options){if((0,debug_node.Cpm)(type))throw new Error(`Component '${type.name}' has unresolved metadata. Please call \`await TestBed.compileComponents()\` before running this test.`);const testComponentRenderer=this.inject(TestComponentRenderer),shouldInferTagName=options?.inferTagName??this._instanceInferTagName??!1,componentDef=(0,root_effect_scheduler.xUg)(type),rootElId="root"+_nextRootElementId++;if(!componentDef)throw new Error(`It looks like '${(0,root_effect_scheduler.AsM)(type)}' has not been compiled.`);testComponentRenderer.insertRootElement(rootElId,shouldInferTagName?(0,debug_node.Fp)(componentDef):void 0);const componentFactory=new debug_node.eHC(componentDef),initComponent=()=>{const componentRef=componentFactory.create(root_effect_scheduler.zZn.NULL,[],`#${rootElId}`,this.testModuleRef,void 0,options?.bindings);return this.runInInjectionContext(()=>new ComponentFixture(componentRef))},ngZone=this.inject(ComponentFixtureNoNgZone,!1)?null:this.inject(debug_node.SKi,null),fixture=ngZone?ngZone.run(initComponent):initComponent();return this._activeFixtures.push(fixture),fixture}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(methodName,methodDescription){if(null!==this._testModuleRef)throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`)}checkGlobalCompilationFinished(){this.globalCompilationChecked||null!==this._testModuleRef||(0,debug_node.$dP)(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let errorCount=0;if(this._activeFixtures.forEach(fixture=>{try{fixture.destroy()}catch(e){errorCount++,console.error("Error during cleanup of component",{component:fixture.componentInstance,stacktrace:e})}}),this._activeFixtures=[],errorCount>0&&this.shouldRethrowTeardownErrors())throw Error(`${errorCount} ${1===errorCount?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const instanceOptions=this._instanceTeardownOptions,environmentOptions=TestBedImpl._environmentTeardownOptions;return!instanceOptions&&!environmentOptions||(instanceOptions?.rethrowErrors??environmentOptions?.rethrowErrors??this.shouldTearDownTestingModule())}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??TestBedImpl._environmentErrorOnUnknownElementsOption??false}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??TestBedImpl._environmentErrorOnUnknownPropertiesOption??false}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??TestBedImpl._environmentTeardownOptions?.destroyAfterEach??true}getDeferBlockBehavior(){return this._instanceDeferBlockBehavior}getAnimationsEnabled(){return this._instanceAnimationsEnabled}tearDownTestingModule(){if(null===this._testModuleRef)return;const testRenderer=this.inject(TestComponentRenderer);try{this._testModuleRef.destroy()}catch(e){if(this.shouldRethrowTeardownErrors())throw e;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:e})}finally{testRenderer.removeAllRootElements?.()}}flushEffects(){this.tick()}tick(){const appRef=this.inject(debug_node.o8S);try{appRef.includeAllTestViews=!0,appRef.tick()}finally{appRef.includeAllTestViews=!1}}}const TestBed=TestBedImpl;class FakeNavigation{entriesArr=[];currentEntryIndex=0;navigateEvent=null;traversalQueue=new Map;nextTraversal=Promise.resolve();prospectiveEntryIndex=0;synchronousTraversals=!1;canSetInitialEntry=!0;eventTarget;nextId=0;nextKey=0;disposed=!1;get currentEntry(){return this.entriesArr[this.currentEntryIndex]}get canGoBack(){return this.currentEntryIndex>0}get canGoForward(){return this.currentEntryIndex<this.entriesArr.length-1}createEventTarget;_window;get window(){return this._window}constructor(doc,startURL){this.createEventTarget=()=>{try{return doc.createElement("div")}catch{return new EventTarget}},this._window=document.defaultView??this.createEventTarget(),this.eventTarget=this.createEventTarget(),this.setInitialEntryForTesting(startURL)}setInitialEntryForTesting(url,options={historyState:null}){if(!this.canSetInitialEntry)throw new Error("setInitialEntryForTesting can only be called before any navigation has occurred");const currentInitialEntry=this.entriesArr[0];this.entriesArr[0]=new FakeNavigationHistoryEntry(this.eventTarget,new URL(url).toString(),{index:0,key:currentInitialEntry?.key??String(this.nextKey++),id:currentInitialEntry?.id??String(this.nextId++),sameDocument:!0,historyState:options?.historyState,state:options.state})}canSetInitialEntryForTesting(){return this.canSetInitialEntry}setSynchronousTraversalsForTesting(synchronousTraversals){this.synchronousTraversals=synchronousTraversals}entries(){return this.entriesArr.slice()}navigate(url,options){const fromUrl=new URL(this.currentEntry.url),toUrl=new URL(url,this.currentEntry.url);let navigationType;navigationType=options?.history&&"auto"!==options.history?options.history:fromUrl.toString()===toUrl.toString()?"replace":"push";const hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),state:options?.state,sameDocument:hashChange,historyState:null}),result=new InternalNavigationResult(this);return this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info})||this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent),{committed:result.committed,finished:result.finished}}pushState(data,title,url){this.pushOrReplaceState("push",data,title,url)}replaceState(data,title,url){this.pushOrReplaceState("replace",data,title,url)}pushOrReplaceState(navigationType,data,_title,url){const fromUrl=new URL(this.currentEntry.url),toUrl=url?new URL(url,this.currentEntry.url):fromUrl,hashChange=isHashChange(fromUrl,toUrl),destination=new FakeNavigationDestination({url:toUrl.toString(),sameDocument:!0,historyState:data,state:void 0}),result=new InternalNavigationResult(this);this.userAgentNavigate(destination,result,{navigationType,cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange})||this.updateNavigationEntriesForSameDocumentNavigation(this.navigateEvent)}traverseTo(key,options){const fromUrl=new URL(this.currentEntry.url),entry=this.findEntry(key);if(!entry){const domException=new DOMException("Invalid key","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch(()=>{}),finished.catch(()=>{}),{committed,finished}}if(entry===this.currentEntry)return{committed:Promise.resolve(this.currentEntry),finished:Promise.resolve(this.currentEntry)};if(this.traversalQueue.has(entry.key)){const existingResult=this.traversalQueue.get(entry.key);return{committed:existingResult.committed,finished:existingResult.finished}}const hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument});this.prospectiveEntryIndex=entry.index;const result=new InternalNavigationResult(this);return this.traversalQueue.set(entry.key,result),this.runTraversal(()=>{this.traversalQueue.delete(entry.key);this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange,info:options?.info})||this.userAgentTraverse(this.navigateEvent)}),{committed:result.committed,finished:result.finished}}back(options){if(0===this.currentEntryIndex){const domException=new DOMException("Cannot go back","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch(()=>{}),finished.catch(()=>{}),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex-1];return this.traverseTo(entry.key,options)}forward(options){if(this.currentEntryIndex===this.entriesArr.length-1){const domException=new DOMException("Cannot go forward","InvalidStateError"),committed=Promise.reject(domException),finished=Promise.reject(domException);return committed.catch(()=>{}),finished.catch(()=>{}),{committed,finished}}const entry=this.entriesArr[this.currentEntryIndex+1];return this.traverseTo(entry.key,options)}go(direction){const targetIndex=this.prospectiveEntryIndex+direction;targetIndex>=this.entriesArr.length||targetIndex<0||(this.prospectiveEntryIndex=targetIndex,this.runTraversal(()=>{if(targetIndex>=this.entriesArr.length||targetIndex<0)return;const fromUrl=new URL(this.currentEntry.url),entry=this.entriesArr[targetIndex],hashChange=isHashChange(fromUrl,new URL(entry.url,this.currentEntry.url)),destination=new FakeNavigationDestination({url:entry.url,state:entry.getState(),historyState:entry.getHistoryState(),key:entry.key,id:entry.id,index:entry.index,sameDocument:entry.sameDocument}),result=new InternalNavigationResult(this);this.userAgentNavigate(destination,result,{navigationType:"traverse",cancelable:!0,canIntercept:!0,userInitiated:!1,hashChange})||this.userAgentTraverse(this.navigateEvent)}))}runTraversal(traversal){this.synchronousTraversals?traversal():this.nextTraversal=this.nextTraversal.then(()=>new Promise(resolve=>{setTimeout(()=>{resolve(),traversal()})}))}addEventListener(type,callback,options){this.eventTarget.addEventListener(type,callback,options)}removeEventListener(type,callback,options){this.eventTarget.removeEventListener(type,callback,options)}dispatchEvent(event){return this.eventTarget.dispatchEvent(event)}dispose(){this.eventTarget=this.createEventTarget(),this.disposed=!0}isDisposed(){return this.disposed}abortOngoingNavigation(eventToAbort,reason){if(this.navigateEvent!==eventToAbort)return;if(this.navigateEvent.abortController.signal.aborted)return;const abortReason=reason??new DOMException("Navigation aborted","AbortError");this.navigateEvent.cancel(abortReason)}userAgentNavigate(destination,result,options){this.canSetInitialEntry=!1,this.navigateEvent&&this.abortOngoingNavigation(this.navigateEvent,new DOMException("Navigation superseded by a new navigation.","AbortError"));const dispatchResultIsTrueIfNoInterception=function dispatchNavigateEvent({cancelable,canIntercept,userInitiated,hashChange,navigationType,destination,info,sameDocument,result}){const{navigation}=result,eventAbortController=new AbortController,event=new Event("navigate",{bubbles:!1,cancelable});event.navigationType=navigationType,event.destination=destination,event.canIntercept=canIntercept,event.userInitiated=userInitiated,event.hashChange=hashChange,event.signal=eventAbortController.signal,event.abortController=eventAbortController,event.info=info,event.focusResetBehavior=null,event.scrollBehavior=null,event.interceptionState="none",event.downloadRequest=null,event.formData=null,event.result=result,event.sameDocument=sameDocument;let precommitHandlers=[],handlers=[];function redirect(url,options={}){if("none"===event.interceptionState)throw new Error("cannot redirect when event is not intercepted");if("intercepted"!==event.interceptionState)throw new DOMException("cannot redirect when event is not in 'intercepted' state","InvalidStateError");if("push"!==event.navigationType&&"replace"!==event.navigationType)throw new DOMException("cannot redirect when navigationType is not 'push' or 'replace","InvalidStateError");const destinationUrl=new URL(url,navigation.currentEntry.url);"push"!==options.history&&"replace"!==options.history||(event.navigationType=options.history),options.hasOwnProperty("state")&&(event.destination.state=options.state),event.destination.url=destinationUrl.href,options.hasOwnProperty("info")&&(event.info=options.info)}function commit(){if(result.signal.aborted)return;if(navigation.transition?.committedResolve(),"intercepted"===event.interceptionState)switch(event.interceptionState="committed",event.navigationType){case"push":case"replace":navigation.urlAndHistoryUpdateSteps(event);break;case"reload":navigation.updateNavigationEntriesForSameDocumentNavigation(event);break;case"traverse":navigation.userAgentTraverse(event)}const promisesList=handlers.map(handler=>handler());0===promisesList.length&&promisesList.push(Promise.resolve()),Promise.all(promisesList).then(()=>{if(result.signal.aborted)return;if(event!==navigation.navigateEvent)return void(!result.signal.aborted&&result.committedTo&&result.finishedReject(new DOMException("Navigation superseded before handler completion","AbortError")));navigation.navigateEvent=null,finishNavigationEvent(event,!0),result.finishedResolve();const navigatesuccessEvent=new Event("navigatesuccess",{bubbles:!1,cancelable:!1});navigation.eventTarget.dispatchEvent(navigatesuccessEvent),navigation.transition?.finishedResolve(),navigation.transition=null}).catch(reason=>{event.abortController.signal.aborted||event.cancel(reason)})}function dispatch(){navigation.navigateEvent=event;const dispatchResult=navigation.eventTarget.dispatchEvent(event);if("intercepted"===event.interceptionState){if(!navigation.currentEntry)return void event.cancel(new DOMException("Cannot create transition without a currentEntry for intercepted navigation.","InvalidStateError"));const transition=new InternalNavigationTransition(navigation.currentEntry,navigationType);navigation.transition=transition,transition.finished.catch(()=>{}),transition.committed.catch(()=>{})}if(!dispatchResult&&event.cancelable)event.abortController.signal.aborted||event.cancel(new DOMException("Navigation prevented by event.preventDefault()","AbortError"));else if(0===precommitHandlers.length)commit();else{const precommitController={redirect},precommitPromisesList=precommitHandlers.map(handler=>{let p;try{p=handler(precommitController)}catch(e){p=Promise.reject(e)}return p.catch(()=>{}),p});Promise.all(precommitPromisesList).then(()=>commit()).catch(reason=>{event.abortController.signal.aborted||(navigation.transition&&navigation.transition.committedReject(reason),event.cancel(reason))})}}return event.intercept=function(options){if(!this.canIntercept)throw new DOMException("Cannot intercept when canIntercept is 'false'","SecurityError");this.interceptionState="intercepted",event.sameDocument=!0;const precommitHandler=options?.precommitHandler;if(precommitHandler){if(!this.cancelable)throw new DOMException("Cannot use precommitHandler when cancelable is 'false'","InvalidStateError");precommitHandlers.push(precommitHandler)}if("none"!==event.interceptionState&&"intercepted"!==event.interceptionState)throw new Error('Event interceptionState should be "none" or "intercepted"');event.interceptionState="intercepted";const handler=options?.handler;handler&&handlers.push(handler),event.focusResetBehavior=options?.focusReset??event.focusResetBehavior,event.scrollBehavior=options?.scroll??event.scrollBehavior},event.scroll=function(){if("committed"!==event.interceptionState)throw new DOMException("Failed to execute 'scroll' on 'NavigateEvent': scroll() must be called after commit() and interception options must specify manual scroll.","InvalidStateError");processScrollBehavior(event)},event.cancel=function(reason){if(result.signal.aborted)return;this.abortController.abort(reason);this===navigation.navigateEvent&&(navigation.navigateEvent=null),"intercepted"!==this.interceptionState&&"finished"!==this.interceptionState?finishNavigationEvent(this,!1):"intercepted"===this.interceptionState&&(this.interceptionState="finished"),result.committedReject(reason),result.finishedReject(reason);const navigateerrorEvent=new Event("navigateerror",{bubbles:!1,cancelable});navigateerrorEvent.error=reason,navigation.eventTarget.dispatchEvent(navigateerrorEvent);const transition=navigation.transition;transition?.committedReject(reason),transition?.finishedReject(reason),navigation.transition=null},dispatch(),"none"===event.interceptionState}({navigationType:options.navigationType,cancelable:options.cancelable,canIntercept:options.canIntercept,userInitiated:options.userInitiated,hashChange:options.hashChange,destination,info:options.info,sameDocument:destination.sameDocument,result});return!dispatchResultIsTrueIfNoInterception}urlAndHistoryUpdateSteps(navigateEvent){this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent)}userAgentTraverse(navigateEvent){const oldUrl=this.currentEntry.url;this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);const popStateEvent=function createPopStateEvent({state}){const event=new Event("popstate",{bubbles:!1,cancelable:!1});return event.state=state,event}({state:navigateEvent.destination.getHistoryState()});if(this._window.dispatchEvent(popStateEvent),navigateEvent.hashChange){const hashchangeEvent=function createHashChangeEvent(newURL,oldURL){const event=new Event("hashchange",{bubbles:!1,cancelable:!1});return event.newURL=newURL,event.oldURL=oldURL,event}(oldUrl,this.currentEntry.url);this._window.dispatchEvent(hashchangeEvent)}}updateNavigationEntriesForSameDocumentNavigation({destination,navigationType,result}){const oldCurrentNHE=this.currentEntry,disposedNHEs=[];if("traverse"===navigationType){if(this.currentEntryIndex=destination.index,-1===this.currentEntryIndex)throw new Error("unexpected current entry index")}else"push"===navigationType?(this.currentEntryIndex++,this.prospectiveEntryIndex=this.currentEntryIndex,disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex))):"replace"===navigationType&&disposedNHEs.push(oldCurrentNHE);if("push"===navigationType||"replace"===navigationType){const index=this.currentEntryIndex,key="push"===navigationType?String(this.nextKey++):oldCurrentNHE?.key??String(this.nextKey++),newNHE=new FakeNavigationHistoryEntry(this.eventTarget,destination.url,{id:String(this.nextId++),key,index,sameDocument:!0,state:destination.getState(),historyState:destination.getHistoryState()});this.entriesArr[this.currentEntryIndex]=newNHE}result.committedResolve(this.currentEntry);const currentEntryChangeEvent=function createFakeNavigationCurrentEntryChangeEvent({from,navigationType}){const event=new Event("currententrychange",{bubbles:!1,cancelable:!1});return event.from=from,event.navigationType=navigationType,event}({from:oldCurrentNHE,navigationType});this.eventTarget.dispatchEvent(currentEntryChangeEvent);for(const disposedNHE of disposedNHEs)disposedNHE.dispose()}findEntry(key){for(const entry of this.entriesArr)if(entry.key===key)return entry}set onnavigate(_handler){throw new Error("unimplemented")}get onnavigate(){throw new Error("unimplemented")}set oncurrententrychange(_handler){throw new Error("unimplemented")}get oncurrententrychange(){throw new Error("unimplemented")}set onnavigatesuccess(_handler){throw new Error("unimplemented")}get onnavigatesuccess(){throw new Error("unimplemented")}set onnavigateerror(_handler){throw new Error("unimplemented")}get onnavigateerror(){throw new Error("unimplemented")}_transition=null;set transition(t){this._transition=t}get transition(){return this._transition}updateCurrentEntry(_options){throw new Error("unimplemented")}reload(_options){throw new Error("unimplemented")}}class FakeNavigationHistoryEntry{eventTarget;url;sameDocument;id;key;index;state;historyState;ondispose=null;constructor(eventTarget,url,{id,key,index,sameDocument,state,historyState}){this.eventTarget=eventTarget,this.url=url,this.id=id,this.key=key,this.index=index,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState}getState(){return this.state?JSON.parse(JSON.stringify(this.state)):this.state}getHistoryState(){return this.historyState?JSON.parse(JSON.stringify(this.historyState)):this.historyState}addEventListener(type,callback,options){this.eventTarget.addEventListener(type,callback,options)}removeEventListener(type,callback,options){this.eventTarget.removeEventListener(type,callback,options)}dispatchEvent(event){return this.eventTarget.dispatchEvent(event)}dispose(){const disposeEvent=new Event("disposed");this.dispatchEvent(disposeEvent),this.eventTarget=null}}function finishNavigationEvent(event,didFulfill){if("finished"===event.interceptionState)throw new Error("Attempting to finish navigation event that was already finished");if("intercepted"!==event.interceptionState)"none"!==event.interceptionState&&(!function potentiallyResetFocus(event){if("committed"!==event.interceptionState&&"scrolled"!==event.interceptionState)throw new Error("cannot reset focus if navigation event is not committed or scrolled");if("manual"===event.focusResetBehavior)return}(event),didFulfill&&function potentiallyResetScroll(event){if("committed"!==event.interceptionState&&"scrolled"!==event.interceptionState)throw new Error("cannot reset scroll if navigation event is not committed or scrolled");if("scrolled"===event.interceptionState||"manual"===event.scrollBehavior)return;processScrollBehavior(event)}(event),event.interceptionState="finished");else{if(!0===didFulfill)throw new Error("didFulfill should be false");event.interceptionState="finished"}}function processScrollBehavior(event){if("committed"!==event.interceptionState)throw new Error("invalid event interception state when processing scroll behavior");event.interceptionState="scrolled"}class FakeNavigationDestination{url;sameDocument;key;id;index;state;historyState;constructor({url,sameDocument,historyState,state,key=null,id=null,index=-1}){this.url=url,this.sameDocument=sameDocument,this.state=state,this.historyState=historyState,this.key=key,this.id=id,this.index=index}getState(){return this.state}getHistoryState(){return this.historyState}}function isHashChange(from,to){return to.hash!==from.hash&&to.hostname===from.hostname&&to.pathname===from.pathname&&to.search===from.search}class InternalNavigationTransition{from;navigationType;finished;committed;finishedResolve;finishedReject;committedResolve;committedReject;constructor(from,navigationType){this.from=from,this.navigationType=navigationType,this.finished=new Promise((resolve,reject)=>{this.finishedReject=reject,this.finishedResolve=resolve}),this.committed=new Promise((resolve,reject)=>{this.committedReject=reject,this.committedResolve=resolve}),this.finished.catch(()=>{}),this.committed.catch(()=>{})}}class InternalNavigationResult{navigation;committedTo=null;committedResolve;committedReject;finishedResolve;finishedReject;committed;finished;get signal(){return this.abortController.signal}abortController=new AbortController;constructor(navigation){this.navigation=navigation,this.committed=new Promise((resolve,reject)=>{this.committedResolve=entry=>{this.committedTo=entry,resolve(entry)},this.committedReject=reject}),this.finished=new Promise((resolve,reject)=>{this.finishedResolve=()=>{if(null===this.committedTo)throw new Error("NavigateEvent should have been committed before resolving finished promise.");resolve(this.committedTo)},this.finishedReject=reason=>{reject(reason),this.abortController.abort(reason)}}),this.committed.catch(()=>{}),this.finished.catch(()=>{})}}function getCleanupHook(expectedTeardownValue){return()=>{const testBed=TestBedImpl.INSTANCE;testBed.shouldTearDownTestingModule()===expectedTeardownValue&&(testBed.resetTestingModule(),function resetFakeAsyncZoneIfExists(){getFakeAsyncTestModule()&&Zone.ProxyZoneSpec?.isLoaded()&&getFakeAsyncTestModule().resetFakeAsyncZone()}())}}globalThis.beforeEach?.(getCleanupHook(!1)),globalThis.afterEach?.(getCleanupHook(!0));class Log{logItems;constructor(){this.logItems=[]}add(value){this.logItems.push(value)}fn(value){return()=>{this.logItems.push(value)}}clear(){this.logItems=[]}result(){return this.logItems.join("; ")}static ɵfac=function Log_Factory(__ngFactoryType__){return new(__ngFactoryType__||Log)};static ɵprov=root_effect_scheduler.jDH({token:Log,factory:Log.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(Log,[{type:debug_node._qm}],()=>[],null);var router2=__webpack_require__("./node_modules/@angular/router/fesm2022/router2.mjs"),router_module=__webpack_require__("./node_modules/@angular/router/fesm2022/router_module.mjs"),fesm2022_location=__webpack_require__("./node_modules/@angular/common/fesm2022/location.mjs"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");class platform_navigation_PlatformNavigation{static ɵfac=function PlatformNavigation_Factory(__ngFactoryType__){return new(__ngFactoryType__||platform_navigation_PlatformNavigation)};static ɵprov=root_effect_scheduler.jDH({token:platform_navigation_PlatformNavigation,factory:()=>window.navigation,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(platform_navigation_PlatformNavigation,[{type:debug_node._qm,args:[{providedIn:"platform",useFactory:()=>window.navigation}]}],null,null);const urlParse=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;function parseUrl(urlStr,baseHref){let serverBase,parsedUrl;/^((http[s]?|ftp):\/\/)/.test(urlStr)||(serverBase="http://empty.com/");try{parsedUrl=new URL(urlStr,serverBase)}catch(e){const result=urlParse.exec(serverBase||""+urlStr);if(!result)throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);const hostSplit=result[4].split(":");parsedUrl={protocol:result[1],hostname:hostSplit[0],port:hostSplit[1]||"",pathname:result[5],search:result[6],hash:result[8]}}return parsedUrl.pathname&&0===parsedUrl.pathname.indexOf(baseHref)&&(parsedUrl.pathname=parsedUrl.pathname.substring(baseHref.length)),{hostname:!serverBase&&parsedUrl.hostname||"",protocol:!serverBase&&parsedUrl.protocol||"",port:!serverBase&&parsedUrl.port||"",pathname:parsedUrl.pathname||"/",search:parsedUrl.search||"",hash:parsedUrl.hash||""}}const MOCK_PLATFORM_LOCATION_CONFIG=new root_effect_scheduler.nKC("MOCK_PLATFORM_LOCATION_CONFIG");class MockPlatformLocation{baseHref="";hashUpdate=new Subject.B;popStateSubject=new Subject.B;urlChangeIndex=0;urlChanges=[{hostname:"",protocol:"",port:"",pathname:"/",search:"",hash:"",state:null}];constructor(config){if(config){this.baseHref=config.appBaseHref||"";const parsedChanges=this.parseChanges(null,config.startUrl||"http://_empty_/",this.baseHref);this.urlChanges[0]={...parsedChanges}}}get hostname(){return this.urlChanges[this.urlChangeIndex].hostname}get protocol(){return this.urlChanges[this.urlChangeIndex].protocol}get port(){return this.urlChanges[this.urlChangeIndex].port}get pathname(){return this.urlChanges[this.urlChangeIndex].pathname}get search(){return this.urlChanges[this.urlChangeIndex].search}get hash(){return this.urlChanges[this.urlChangeIndex].hash}get state(){return this.urlChanges[this.urlChangeIndex].state}getBaseHrefFromDOM(){return this.baseHref}onPopState(fn){const subscription=this.popStateSubject.subscribe(fn);return()=>subscription.unsubscribe()}onHashChange(fn){const subscription=this.hashUpdate.subscribe(fn);return()=>subscription.unsubscribe()}get href(){let url=`${this.protocol}//${this.hostname}${this.port?":"+this.port:""}`;return url+=`${"/"===this.pathname?"":this.pathname}${this.search}${this.hash}`,url}get url(){return`${this.pathname}${this.search}${this.hash}`}parseChanges(state,url,baseHref=""){return state=JSON.parse(JSON.stringify(state)),{...parseUrl(url,baseHref),state}}replaceState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChanges[this.urlChangeIndex]={...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}}pushState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChangeIndex>0&&this.urlChanges.splice(this.urlChangeIndex+1),this.urlChanges.push({...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}),this.urlChangeIndex=this.urlChanges.length-1}forward(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex<this.urlChanges.length&&this.urlChangeIndex++,this.emitEvents(oldHash,oldUrl)}back(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex>0&&this.urlChangeIndex--,this.emitEvents(oldHash,oldUrl)}historyGo(relativePosition=0){const oldUrl=this.url,oldHash=this.hash,nextPageIndex=this.urlChangeIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this.urlChanges.length&&(this.urlChangeIndex=nextPageIndex),this.emitEvents(oldHash,oldUrl)}getState(){return this.state}emitEvents(oldHash,oldUrl){this.popStateSubject.next({type:"popstate",state:this.getState(),oldUrl,newUrl:this.url}),oldHash!==this.hash&&this.hashUpdate.next({type:"hashchange",state:null,oldUrl,newUrl:this.url})}static ɵfac=function MockPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockPlatformLocation)(root_effect_scheduler.KVO(MOCK_PLATFORM_LOCATION_CONFIG,8))};static ɵprov=root_effect_scheduler.jDH({token:MockPlatformLocation,factory:MockPlatformLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(MockPlatformLocation,[{type:debug_node._qm}],()=>[{type:void 0,decorators:[{type:debug_node.y_5,args:[MOCK_PLATFORM_LOCATION_CONFIG]},{type:debug_node.Xx1}]}],null);class FakeNavigationPlatformLocation{_platformNavigation;constructor(){const platformNavigation=(0,root_effect_scheduler.WQX)(platform_navigation_PlatformNavigation);if(!(platformNavigation instanceof FakeNavigation))throw new Error("FakePlatformNavigation cannot be used without FakeNavigation. Use `provideFakeNavigation` to have all these services provided together.");this._platformNavigation=platformNavigation}config=(0,root_effect_scheduler.WQX)(MOCK_PLATFORM_LOCATION_CONFIG,{optional:!0});getBaseHrefFromDOM(){return this.config?.appBaseHref??""}onPopState(fn){return this._platformNavigation.window.addEventListener("popstate",fn),()=>this._platformNavigation.window.removeEventListener("popstate",fn)}onHashChange(fn){return this._platformNavigation.window.addEventListener("hashchange",fn),()=>this._platformNavigation.window.removeEventListener("hashchange",fn)}get href(){return this._platformNavigation.currentEntry.url}get protocol(){return new URL(this._platformNavigation.currentEntry.url).protocol}get hostname(){return new URL(this._platformNavigation.currentEntry.url).hostname}get port(){return new URL(this._platformNavigation.currentEntry.url).port}get pathname(){return new URL(this._platformNavigation.currentEntry.url).pathname}get search(){return new URL(this._platformNavigation.currentEntry.url).search}get hash(){return new URL(this._platformNavigation.currentEntry.url).hash}pushState(state,title,url){this._platformNavigation.pushState(state,title,url)}replaceState(state,title,url){this._platformNavigation.replaceState(state,title,url)}forward(){this._platformNavigation.forward()}back(){this._platformNavigation.back()}historyGo(relativePosition=0){this._platformNavigation.go(relativePosition)}getState(){return this._platformNavigation.currentEntry.getHistoryState()}static ɵfac=function FakeNavigationPlatformLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||FakeNavigationPlatformLocation)};static ɵprov=root_effect_scheduler.jDH({token:FakeNavigationPlatformLocation,factory:FakeNavigationPlatformLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(FakeNavigationPlatformLocation,[{type:debug_node._qm}],()=>[],null);new root_effect_scheduler.nKC("fakeNavigation",{providedIn:"root",factory:()=>{const config=(0,root_effect_scheduler.WQX)(MOCK_PLATFORM_LOCATION_CONFIG,{optional:!0}),startUrl=new URL(config?.startUrl||"http://_empty_/","http://_empty_/"),fakeNavigation=new FakeNavigation((0,root_effect_scheduler.WQX)(root_effect_scheduler.qQL),startUrl.href);return fakeNavigation.setSynchronousTraversalsForTesting(!0),fakeNavigation}});class SpyLocation{urlChanges=[];_history=[new LocationState("","",null)];_historyIndex=0;_subject=new Subject.B;_basePath="";_locationStrategy=null;_urlChangeListeners=[];_urlChangeSubscription=null;ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}setInitialPath(url){this._history[this._historyIndex].path=url}setBaseHref(url){this._basePath=url}path(){return this._history[this._historyIndex].path}getState(){return this._history[this._historyIndex].state}isCurrentPathEqualTo(path,query=""){const givenPath=path.endsWith("/")?path.substring(0,path.length-1):path;return(this.path().endsWith("/")?this.path().substring(0,this.path().length-1):this.path())==givenPath+(query.length>0?"?"+query:"")}simulateUrlPop(pathname){this._subject.next({url:pathname,pop:!0,type:"popstate"})}simulateHashChange(pathname){const path=this.prepareExternalUrl(pathname);this.pushHistory(path,"",null),this.urlChanges.push("hash: "+pathname),this._subject.next({url:pathname,pop:!0,type:"popstate"}),this._subject.next({url:pathname,pop:!0,type:"hashchange"})}prepareExternalUrl(url){return url.length>0&&!url.startsWith("/")&&(url="/"+url),this._basePath+url}go(path,query="",state=null){path=this.prepareExternalUrl(path),this.pushHistory(path,query,state);const locationState=this._history[this._historyIndex-1];if(locationState.path==path&&locationState.query==query)return;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push(url),this._notifyUrlChangeListeners(path+(0,fesm2022_location.Q)(query),state)}replaceState(path,query="",state=null){path=this.prepareExternalUrl(path);const history=this._history[this._historyIndex];if(history.state=state,history.path==path&&history.query==query)return;history.path=path,history.query=query;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push("replace: "+url),this._notifyUrlChangeListeners(path+(0,fesm2022_location.Q)(query),state)}forward(){this._historyIndex<this._history.length-1&&(this._historyIndex++,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}back(){this._historyIndex>0&&(this._historyIndex--,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}historyGo(relativePosition=0){const nextPageIndex=this._historyIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this._history.length&&(this._historyIndex=nextPageIndex,this._subject.next({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription??=this.subscribe(v=>{this._notifyUrlChangeListeners(v.url,v.state)}),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach(fn=>fn(url,state))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow??void 0,complete:onReturn??void 0})}normalize(url){return null}pushHistory(path,query,state){this._historyIndex>0&&this._history.splice(this._historyIndex+1),this._history.push(new LocationState(path,query,state)),this._historyIndex=this._history.length-1}static ɵfac=function SpyLocation_Factory(__ngFactoryType__){return new(__ngFactoryType__||SpyLocation)};static ɵprov=root_effect_scheduler.jDH({token:SpyLocation,factory:SpyLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(SpyLocation,[{type:debug_node._qm}],null,null);class LocationState{path;query;state;constructor(path,query,state){this.path=path,this.query=query,this.state=state}}class MockLocationStrategy extends fesm2022_location.hb{internalBaseHref="/";internalPath="/";internalTitle="";urlChanges=[];_subject=new Subject.B;stateChanges=[];constructor(){super()}simulatePopState(url){this.internalPath=url,this._subject.next(new _MockPopStateEvent(this.path()))}path(includeHash=!1){return this.internalPath}prepareExternalUrl(internal){return internal.startsWith("/")&&this.internalBaseHref.endsWith("/")?this.internalBaseHref+internal.substring(1):this.internalBaseHref+internal}pushState(ctx,title,path,query){this.stateChanges.push(ctx),this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push(externalUrl)}replaceState(ctx,title,path,query){this.stateChanges[(this.stateChanges.length||1)-1]=ctx,this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push("replace: "+externalUrl)}onPopState(fn){this._subject.subscribe({next:fn})}getBaseHref(){return this.internalBaseHref}back(){if(this.urlChanges.length>0){this.urlChanges.pop(),this.stateChanges.pop();const nextUrl=this.urlChanges.length>0?this.urlChanges[this.urlChanges.length-1]:"";this.simulatePopState(nextUrl)}}forward(){throw"not implemented"}getState(){return this.stateChanges[(this.stateChanges.length||1)-1]}static ɵfac=function MockLocationStrategy_Factory(__ngFactoryType__){return new(__ngFactoryType__||MockLocationStrategy)};static ɵprov=root_effect_scheduler.jDH({token:MockLocationStrategy,factory:MockLocationStrategy.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(MockLocationStrategy,[{type:debug_node._qm}],()=>[],null);class _MockPopStateEvent{newUrl;pop=!0;type="popstate";constructor(newUrl){this.newUrl=newUrl}}function provideLocationMocks(){return[{provide:fesm2022_location.aZ,useClass:SpyLocation},{provide:fesm2022_location.hb,useClass:MockLocationStrategy}]}class RouterTestingModule{static withRoutes(routes,config){return{ngModule:RouterTestingModule,providers:[{provide:router2.bw,multi:!0,useValue:routes},{provide:router2.J_,useValue:config||{}}]}}static ɵfac=function RouterTestingModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||RouterTestingModule)};static ɵmod=debug_node.$C({type:RouterTestingModule,exports:[router_module.iI]});static ɵinj=root_effect_scheduler.G2t({providers:[router_module.JG,provideLocationMocks(),(0,router_module.Sn)(router_module.D7).ɵproviders,{provide:router2.bw,multi:!0,useValue:[]}],imports:[router_module.iI]})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(RouterTestingModule,[{type:debug_node.UQu,args:[{exports:[router_module.iI],providers:[router_module.JG,provideLocationMocks(),(0,router_module.Sn)(router_module.D7).ɵproviders,{provide:router2.bw,multi:!0,useValue:[]}]}]}],null,null);class RootFixtureService{fixture;harness;createHarness(){if(this.harness)throw new Error("Only one harness should be created per test.");return this.harness=new RouterTestingHarness(this.getRootFixture()),this.harness}getRootFixture(){return void 0!==this.fixture||(this.fixture=TestBed.createComponent(RootCmp),this.fixture.detectChanges()),this.fixture}static ɵfac=function RootFixtureService_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootFixtureService)};static ɵprov=root_effect_scheduler.jDH({token:RootFixtureService,factory:RootFixtureService.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(RootFixtureService,[{type:debug_node._qm,args:[{providedIn:"root"}]}],null,null);class RootCmp{outlet;routerOutletData=(0,root_effect_scheduler.vPA)(void 0,...ngDevMode?[{debugName:"routerOutletData"}]:[]);static ɵfac=function RootCmp_Factory(__ngFactoryType__){return new(__ngFactoryType__||RootCmp)};static ɵcmp=debug_node.VBU({type:RootCmp,selectors:[["ng-component"]],viewQuery:function RootCmp_Query(rf,ctx){if(1&rf&&debug_node.GBs(router2.n3,5),2&rf){let _t;debug_node.mGM(_t=debug_node.lsd())&&(ctx.outlet=_t.first)}},decls:1,vars:1,consts:[[3,"routerOutletData"]],template:function RootCmp_Template(rf,ctx){1&rf&&debug_node.nrm(0,"router-outlet",0),2&rf&&debug_node.Y8G("routerOutletData",ctx.routerOutletData())},dependencies:[router2.n3],encapsulation:2})}("undefined"==typeof ngDevMode||ngDevMode)&&debug_node.cDI(RootCmp,[{type:debug_node.uAl,args:[{template:'<router-outlet [routerOutletData]="routerOutletData()"></router-outlet>',imports:[router2.n3]}]}],null,{outlet:[{type:core.ViewChild,args:[router2.n3]}]});class RouterTestingHarness{static create(initialUrl){return(0,asyncToGenerator.A)(function*(){const harness=TestBed.inject(RootFixtureService).createHarness();return void 0!==initialUrl&&(yield harness.navigateByUrl(initialUrl)),harness})()}fixture;constructor(fixture){this.fixture=fixture}detectChanges(){this.fixture.detectChanges()}get routeDebugElement(){const outlet=this.fixture.componentInstance.outlet;return outlet&&outlet.isActivated?this.fixture.debugElement.query(v=>v.componentInstance===outlet.component):null}get routeNativeElement(){return this.routeDebugElement?.nativeElement??null}navigateByUrl(url,requiredRoutedComponentType){var _this=this;return(0,asyncToGenerator.A)(function*(){const router=TestBed.inject(router2.Ix);let resolveFn;const redirectTrackingPromise=new Promise(resolve=>{resolveFn=resolve});(0,router2.gk)(TestBed.inject(router2.Ix),resolveFn),yield router.navigateByUrl(url),yield redirectTrackingPromise,_this.fixture.detectChanges();const outlet=_this.fixture.componentInstance.outlet;if(outlet&&outlet.isActivated&&outlet.activatedRoute.component){const activatedComponent=outlet.component;if(void 0!==requiredRoutedComponentType&&!(activatedComponent instanceof requiredRoutedComponentType))throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);return activatedComponent}if(void 0!==requiredRoutedComponentType)throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but the navigation did not activate any component.`);return null})()}}},"./node_modules/rxjs/dist/esm5/internal/observable/interval.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Y:()=>interval});var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/async.js"),_timer__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/timer.js");function interval(period,scheduler){return void 0===period&&(period=0),void 0===scheduler&&(scheduler=_scheduler_async__WEBPACK_IMPORTED_MODULE_0__.E),period<0&&(period=0),(0,_timer__WEBPACK_IMPORTED_MODULE_1__.O)(period,period,scheduler)}},"./node_modules/rxjs/dist/esm5/internal/observable/timer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{O:()=>timer});var Observable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js"),scheduler_async=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/scheduler/async.js"),isScheduler=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/isScheduler.js");function timer(dueTime,intervalOrScheduler,scheduler){void 0===dueTime&&(dueTime=0),void 0===scheduler&&(scheduler=scheduler_async.b);var intervalDuration=-1;return null!=intervalOrScheduler&&((0,isScheduler.m)(intervalOrScheduler)?scheduler=intervalOrScheduler:intervalDuration=intervalOrScheduler),new Observable.c(function(subscriber){var due=function isValidDate(value){return value instanceof Date&&!isNaN(value)}(dueTime)?+dueTime-scheduler.now():dueTime;due<0&&(due=0);var n=0;return scheduler.schedule(function(){subscriber.closed||(subscriber.next(n++),0<=intervalDuration?this.schedule(void 0,intervalDuration):subscriber.complete())},due)})}},"./node_modules/rxjs/dist/esm5/internal/scheduler/async.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>async_async,E:()=>asyncScheduler});var tslib_es6=__webpack_require__("./node_modules/tslib/tslib.es6.mjs"),Action=function(_super){function Action(scheduler,work){return _super.call(this)||this}return(0,tslib_es6.C6)(Action,_super),Action.prototype.schedule=function(state,delay){return void 0===delay&&(delay=0),this},Action}(__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js").yU),intervalProvider={setInterval:function(handler,timeout){for(var args=[],_i=2;_i<arguments.length;_i++)args[_i-2]=arguments[_i];var delegate=intervalProvider.delegate;return(null==delegate?void 0:delegate.setInterval)?delegate.setInterval.apply(delegate,(0,tslib_es6.fX)([handler,timeout],(0,tslib_es6.zs)(args))):setInterval.apply(void 0,(0,tslib_es6.fX)([handler,timeout],(0,tslib_es6.zs)(args)))},clearInterval:function(handle){var delegate=intervalProvider.delegate;return((null==delegate?void 0:delegate.clearInterval)||clearInterval)(handle)},delegate:void 0},arrRemove=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"),AsyncAction=function(_super){function AsyncAction(scheduler,work){var _this=_super.call(this,scheduler,work)||this;return _this.scheduler=scheduler,_this.work=work,_this.pending=!1,_this}return(0,tslib_es6.C6)(AsyncAction,_super),AsyncAction.prototype.schedule=function(state,delay){var _a;if(void 0===delay&&(delay=0),this.closed)return this;this.state=state;var id=this.id,scheduler=this.scheduler;return null!=id&&(this.id=this.recycleAsyncId(scheduler,id,delay)),this.pending=!0,this.delay=delay,this.id=null!==(_a=this.id)&&void 0!==_a?_a:this.requestAsyncId(scheduler,this.id,delay),this},AsyncAction.prototype.requestAsyncId=function(scheduler,_id,delay){return void 0===delay&&(delay=0),intervalProvider.setInterval(scheduler.flush.bind(scheduler,this),delay)},AsyncAction.prototype.recycleAsyncId=function(_scheduler,id,delay){if(void 0===delay&&(delay=0),null!=delay&&this.delay===delay&&!1===this.pending)return id;null!=id&&intervalProvider.clearInterval(id)},AsyncAction.prototype.execute=function(state,delay){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;var error=this._execute(state,delay);if(error)return error;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))},AsyncAction.prototype._execute=function(state,_delay){var errorValue,errored=!1;try{this.work(state)}catch(e){errored=!0,errorValue=e||new Error("Scheduled action threw falsy error")}if(errored)return this.unsubscribe(),errorValue},AsyncAction.prototype.unsubscribe=function(){if(!this.closed){var id=this.id,scheduler=this.scheduler,actions=scheduler.actions;this.work=this.state=this.scheduler=null,this.pending=!1,(0,arrRemove.o)(actions,this),null!=id&&(this.id=this.recycleAsyncId(scheduler,id,null)),this.delay=null,_super.prototype.unsubscribe.call(this)}},AsyncAction}(Action),dateTimestampProvider={now:function(){return(dateTimestampProvider.delegate||Date).now()},delegate:void 0},Scheduler=function(){function Scheduler(schedulerActionCtor,now){void 0===now&&(now=Scheduler.now),this.schedulerActionCtor=schedulerActionCtor,this.now=now}return Scheduler.prototype.schedule=function(work,delay,state){return void 0===delay&&(delay=0),new this.schedulerActionCtor(this,work).schedule(state,delay)},Scheduler.now=dateTimestampProvider.now,Scheduler}(),asyncScheduler=new(function(_super){function AsyncScheduler(SchedulerAction,now){void 0===now&&(now=Scheduler.now);var _this=_super.call(this,SchedulerAction,now)||this;return _this.actions=[],_this._active=!1,_this}return(0,tslib_es6.C6)(AsyncScheduler,_super),AsyncScheduler.prototype.flush=function(action){var actions=this.actions;if(this._active)actions.push(action);else{var error;this._active=!0;do{if(error=action.execute(action.state,action.delay))break}while(action=actions.shift());if(this._active=!1,error){for(;action=actions.shift();)action.unsubscribe();throw error}}},AsyncScheduler}(Scheduler))(AsyncAction),async_async=asyncScheduler}}]);