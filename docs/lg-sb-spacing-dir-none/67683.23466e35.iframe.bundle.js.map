{"version":3,"file":"67683.23466e35.iframe.bundle.js","mappings":";;AAqQA;;;;AAiKA","sources":["webpack://@legal-and-general/canopy/./node_modules/storybook-addon-tag-badges/dist/chunk-PGENTQFF.js"],"sourcesContent":["import React, { useMemo, Fragment } from 'react';\nimport { useStorybookApi, addons, experimental_useStatusStore } from 'storybook/manager-api';\nimport { styled, useTheme } from 'storybook/theming';\nimport { WithTooltip, TooltipMessage } from 'storybook/internal/components';\n\n// src/utils/tag.ts\nfunction getTagParts(tag) {\n  const [prefix, ...rest] = tag.split(\":\");\n  return { prefix, suffix: rest.join(\":\") || null };\n}\nfunction getTagPrefix(tag) {\n  return getTagParts(tag).prefix;\n}\nfunction getTagSuffix(tag) {\n  return getTagParts(tag).suffix;\n}\nfunction normalisePattern(pattern) {\n  if (pattern === void 0) {\n    return /.*/;\n  }\n  if (typeof pattern === \"string\") {\n    let patternWithBoundaries = pattern;\n    if (!patternWithBoundaries.startsWith(\"^\")) {\n      patternWithBoundaries = `^${patternWithBoundaries}`;\n    }\n    if (!patternWithBoundaries.endsWith(\"$\")) {\n      patternWithBoundaries += \"$\";\n    }\n    return new RegExp(patternWithBoundaries);\n  }\n  return pattern;\n}\nfunction matchTag(tag, patterns) {\n  const normalisedPatterns = [patterns].flat();\n  for (const pattern of normalisedPatterns) {\n    if (pattern instanceof RegExp) {\n      if (tag.match(pattern)) {\n        return true;\n      }\n    } else if (typeof pattern === \"string\") {\n      if (tag === pattern) {\n        return true;\n      }\n    } else {\n      const { prefix, suffix } = getTagParts(tag);\n      const prefixPattern = normalisePattern(pattern.prefix);\n      const suffixPattern = normalisePattern(pattern.suffix);\n      const matchesPrefix = prefix.match(prefixPattern);\n      const matchesSuffix = suffix && suffix.match(suffixPattern);\n      if (matchesPrefix && matchesSuffix) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction matchTags(tags, config) {\n  return tags.filter((tag) => matchTag(tag, config));\n}\n\n// src/defaultConfig.ts\nvar newBadge = {\n  tags: \"new\",\n  badge: {\n    text: \"New\",\n    style: \"green\"\n  }\n};\nvar preReleaseBadge = {\n  tags: [\"alpha\", \"beta\", \"rc\", \"experimental\"],\n  badge: ({ tag }) => {\n    const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);\n    return {\n      text: tag === \"rc\" ? \"Release candidate\" : upperFirst(tag),\n      style: \"purple\"\n    };\n  }\n};\nvar deprecatedBadge = {\n  tags: \"deprecated\",\n  badge: {\n    text: \"Deprecated\",\n    style: \"yellow\"\n  }\n};\nvar outdatedBadge = {\n  tags: \"outdated\",\n  badge: {\n    text: \"Outdated\",\n    style: \"orange\"\n  }\n};\nvar dangerBadge = {\n  tags: \"danger\",\n  badge: {\n    text: \"Danger\",\n    style: \"red\"\n  }\n};\nvar codeOnlyBadge = {\n  tags: [\"code-only\"],\n  badge: {\n    text: \"Code Only\",\n    style: \"grey\"\n  }\n};\nvar versionBadge = {\n  tags: [\n    {\n      prefix: \"v\"\n    },\n    {\n      prefix: \"version\"\n    }\n  ],\n  badge: ({ getTagSuffix: getTagSuffix2, tag }) => {\n    const version = getTagSuffix2(tag);\n    const isExperimental = version?.startsWith(\"0\");\n    return {\n      text: `${version}`,\n      style: isExperimental ? \"turquoise\" : \"blue\"\n    };\n  }\n};\nvar defaultConfig = [\n  newBadge,\n  preReleaseBadge,\n  deprecatedBadge,\n  outdatedBadge,\n  dangerBadge,\n  codeOnlyBadge,\n  versionBadge\n];\n\n// src/utils/display.ts\nvar DISPLAY_DEFAULTS = {\n  mdx: [\"story\", \"component\"],\n  sidebar: [\n    { type: \"story\", skipInherited: true },\n    { type: \"docs\", skipInherited: true },\n    { type: \"component\", skipInherited: false },\n    { type: \"group\", skipInherited: false }\n  ],\n  toolbar: [\"docs\", \"story\"]\n};\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction normaliseDisplay(display) {\n  return {\n    mdx: toArray(display?.mdx ?? DISPLAY_DEFAULTS.mdx),\n    sidebar: toArray(display?.sidebar ?? DISPLAY_DEFAULTS.sidebar),\n    toolbar: toArray(display?.toolbar ?? DISPLAY_DEFAULTS.toolbar)\n  };\n}\nfunction shouldDisplay({\n  config,\n  context,\n  type\n}) {\n  if (type === \"root\") {\n    return \"never\" /* NEVER */;\n  }\n  for (const condition of normaliseDisplay(config.display)[context]) {\n    if (condition === true) {\n      return \"always\" /* ALWAYS */;\n    }\n    if (condition === false) {\n      return \"never\" /* NEVER */;\n    }\n    if (condition === type) {\n      return \"always\" /* ALWAYS */;\n    }\n    if (context === \"sidebar\" && typeof condition === \"object\") {\n      if (condition.type === type) {\n        return condition.skipInherited ? \"skip-inherited\" /* SKIP_INHERITED */ : \"always\" /* ALWAYS */;\n      }\n    }\n  }\n  return \"never\" /* NEVER */;\n}\n\n// src/constants.ts\nvar ADDON_ID = \"storybook/addon-tag-badges\";\nvar TOOL_ID = `${ADDON_ID}/tool`;\nvar KEY = `tagBadges`;\nvar EVENTS = {\n  REQUEST_CONFIG: `${ADDON_ID}/requestConfig`,\n  CONFIG_READY: `${ADDON_ID}/configReady`\n};\nfunction _useBadgesToDisplay({\n  api,\n  context,\n  parameters,\n  parent,\n  tags,\n  type\n}) {\n  if (!tags || !type) {\n    return [];\n  }\n  let parentTags;\n  let resolvedParent;\n  if (api && parent) {\n    resolvedParent = api.resolveStory(parent);\n    if (resolvedParent && resolvedParent.type !== \"root\") {\n      parentTags = resolvedParent.tags;\n    }\n  }\n  return (parameters || []).map((config) => ({\n    ...config,\n    displayOutcome: shouldDisplay({ context, config, type })\n  })).filter(({ displayOutcome }) => displayOutcome !== \"never\" /* NEVER */).flatMap(\n    (config) => matchTags(tags, config.tags).map((tag) => ({\n      badge: config.badge,\n      displayOutcome: config.displayOutcome,\n      tag\n    }))\n  ).reduce((acc, current) => {\n    if (current.displayOutcome === \"skip-inherited\" /* SKIP_INHERITED */ && resolvedParent && resolvedParent.type !== \"root\" && parentTags?.includes(current.tag)) {\n      const displayParent = _useBadgesToDisplay({\n        api,\n        context,\n        parameters,\n        parent: resolvedParent.parent,\n        tags: parentTags,\n        type: resolvedParent.type\n      });\n      if (displayParent.find(({ tag }) => tag === current.tag)) {\n        return acc;\n      }\n    }\n    if (acc.every(({ tag }) => tag !== current.tag)) {\n      acc.push(current);\n    }\n    return acc;\n  }, []);\n}\nfunction useBadgesToDisplay({\n  context,\n  parameters,\n  parent,\n  tags,\n  type\n}) {\n  const api = useStorybookApi();\n  return useMemo(\n    () => _useBadgesToDisplay({\n      api,\n      context,\n      parameters,\n      parent,\n      tags,\n      type\n    }),\n    [context, parameters, parent, tags, type]\n  );\n}\nvar WithTooltipPatched = styled(WithTooltip)`\n  line-height: 1px;\n`;\nvar BadgeUI = styled.div(({ as, context, extraStyle, hasLongText, theme }) => ({\n  display: \"inline-block\",\n  fontSize: 11,\n  lineHeight: \".75rem\",\n  alignSelf: \"center\",\n  padding: context === \"sidebar\" ? \"3px 8px\" : \"4px 12px\",\n  border: \"none\",\n  cursor: as === \"button\" ? \"help\" : context === \"sidebar\" ? \"cursor\" : \"initial\",\n  borderRadius: \"3em\",\n  fontWeight: theme.typography.weight.bold,\n  boxShadow: theme.base === \"light\" ? `inset 0 0 0 1px ${extraStyle.borderColor ?? `color-mix(in oklab, ${extraStyle.color ?? theme.color.dark} 10%, transparent 90%)`}` : `inset 0 0 0 1px ${extraStyle.borderColor ?? \"none\"}`,\n  backgroundColor: theme.color.mediumlight,\n  color: theme.color.dark,\n  wordBreak: \"normal\",\n  width: hasLongText ? \"min-content\" : \"fit-content\",\n  flexShrink: 0,\n  textWrapStyle: \"pretty\",\n  textAlign: \"center\",\n  ...extraStyle,\n  borderColor: void 0\n}));\nvar TooltipUI = styled.div(({ theme }) => ({\n  padding: \"8px 12px\",\n  boxSizing: \"border-box\",\n  color: theme.color.defaultText,\n  lineHeight: \"1.125rem\"\n}));\nvar Badge = ({\n  context,\n  style,\n  text,\n  tooltip\n}) => {\n  const theme = useTheme();\n  let extraStyle;\n  if (style === \"green\") {\n    extraStyle = {\n      backgroundColor: \"hsl(130, 100%, 74%)\",\n      borderColor: \"hsl(130, 100%, 34%)\",\n      color: \"hsl(130, 100%, 6%)\"\n    };\n  } else if (style === \"purple\") {\n    extraStyle = {\n      backgroundColor: \"hsl(257, 100%, 84%)\",\n      borderColor: \"hsl(257, 100%, 64%)\",\n      color: \"hsl(257, 100%, 12%)\"\n    };\n  } else if (style === \"blue\") {\n    extraStyle = {\n      backgroundColor: \"hsl(194, 100%, 74%)\",\n      borderColor: \"hsl(194, 100%, 34%)\",\n      color: \"hsl(194, 100%, 12%)\"\n    };\n  } else if (style === \"grey\") {\n    extraStyle = {\n      backgroundColor: \"hsl(0, 0%, 84%)\",\n      borderColor: \"hsl(0, 0%, 34%)\",\n      color: \"hsl(0, 0%, 12%)\"\n    };\n  } else if (style === \"orange\") {\n    extraStyle = {\n      backgroundColor: \"hsl(16, 100%, 74%)\",\n      borderColor: \"hsl(16, 100%, 34%)\",\n      color: \"hsl(16, 100%, 12%)\"\n    };\n  } else if (style === \"red\") {\n    extraStyle = {\n      backgroundColor: \"hsl(0, 100%, 44%)\",\n      borderColor: \"hsl(0, 100%, 64%)\",\n      color: \"hsl(0, 100%, 94%)\"\n    };\n  } else if (style === \"yellow\") {\n    extraStyle = {\n      backgroundColor: \"hsl(36, 100%, 74%)\",\n      borderColor: \"hsl(36, 100%, 34%)\",\n      color: \"hsl(36, 100%, 12%)\"\n    };\n  } else if (style === \"pink\") {\n    extraStyle = {\n      backgroundColor: \"hsl(330, 100%, 74%)\",\n      borderColor: \"hsl(330, 100%, 34%)\",\n      color: \"hsl(330, 100%, 12%)\"\n    };\n  } else if (style === \"turquoise\") {\n    extraStyle = {\n      backgroundColor: \"hsl(157, 100%, 74%)\",\n      borderColor: \"hsl(157, 100%, 34%)\",\n      color: \"hsl(157, 100%, 12%)\"\n    };\n  } else if (typeof style === \"object\") {\n    extraStyle = {\n      ...style\n    };\n  }\n  if (typeof text !== \"string\") {\n    throw new Error(\n      \"Badge: the text prop must be defined and must be a string.\"\n    );\n  }\n  const hasLongText = text.length > 15;\n  return /* @__PURE__ */ React.createElement(Fragment, null, !tooltip || context == \"sidebar\" ? /* @__PURE__ */ React.createElement(\n    BadgeUI,\n    {\n      context,\n      extraStyle: extraStyle ?? {},\n      hasLongText,\n      theme\n    },\n    text\n  ) : /* @__PURE__ */ React.createElement(\n    WithTooltipPatched,\n    {\n      closeOnOutsideClick: true,\n      placement: \"bottom\",\n      tooltip: typeof tooltip === \"string\" ? /* @__PURE__ */ React.createElement(TooltipUI, null, tooltip) : /* @__PURE__ */ React.createElement(TooltipMessage, { ...tooltip })\n    },\n    /* @__PURE__ */ React.createElement(\n      BadgeUI,\n      {\n        as: \"button\",\n        context,\n        extraStyle: extraStyle ?? {},\n        hasLongText,\n        theme\n      },\n      text\n    )\n  ));\n};\nfunction getBadgeProps(config, entry, tag, context) {\n  const props = typeof config === \"function\" ? config({ context, entry, getTagParts, getTagPrefix, getTagSuffix, tag }) : config;\n  return props;\n}\nvar WithBadge = ({\n  context,\n  config,\n  entry,\n  tag,\n  ...restProps\n}) => {\n  const cfg = getBadgeProps(config, entry, tag, context);\n  return /* @__PURE__ */ React.createElement(Badge, { ...cfg, context, ...restProps });\n};\n\n// src/components/Sidebar.tsx\nvar Container = styled.div(\n  ({ hasParentPadding, hasStatusWithUI: hasStatusWithUI2 }) => `\n  display: flex;\n  flex: 1;\n  align-items: flex-start;\n  flex-wrap: wrap;\n  text-wrap-style: balance;\n  gap: 4px;\n  margin-right: ${hasStatusWithUI2 ? \"6px\" : hasParentPadding ? \"28px\" : \"34px\"};\n`\n);\nvar FirstLineAlignedLabel = styled.div`\n  display: flex;\n  align-items: center;\n  min-height: 19px;\n`;\nvar Spacer = styled.div`\n  flex: 1;\n`;\nvar Sidebar = ({\n  children,\n  item,\n  hasStatusWithUI: hasStatusWithUI2\n}) => {\n  const { [KEY]: parameters } = addons.getConfig();\n  if (item.type !== \"component\" && item.type !== \"group\" && item.type !== \"docs\" && item.type !== \"story\") {\n    return children;\n  }\n  const badgesToDisplay = useBadgesToDisplay({\n    context: \"sidebar\",\n    parameters,\n    parent: item.parent,\n    tags: item.tags,\n    type: item.type\n  });\n  return /* @__PURE__ */ React.createElement(\n    Container,\n    {\n      hasParentPadding: item.type === \"component\" || item.type === \"group\",\n      hasStatusWithUI: hasStatusWithUI2 ?? false\n    },\n    /* @__PURE__ */ React.createElement(FirstLineAlignedLabel, null, children),\n    /* @__PURE__ */ React.createElement(Spacer, null),\n    badgesToDisplay.length ? /* @__PURE__ */ React.createElement(\n      WithBadge,\n      {\n        config: badgesToDisplay[0].badge,\n        context: \"sidebar\",\n        entry: item,\n        tag: badgesToDisplay[0].tag\n      }\n    ) : \"\"\n  );\n};\nfunction hasStatusWithUI(itemStatuses) {\n  if (!itemStatuses) {\n    return false;\n  }\n  if (itemStatuses[\"storybook/component-test\"]) {\n    return true;\n  }\n  return false;\n}\nfunction RenderLabelContent({ item }) {\n  const itemStatuses = experimental_useStatusStore((all) => all[item.id]);\n  return /* @__PURE__ */ React.createElement(Sidebar, { item, hasStatusWithUI: hasStatusWithUI(itemStatuses) }, item.name);\n}\nfunction renderLabel(item) {\n  if (item.type !== \"story\" && item.type !== \"group\" && item.type !== \"docs\" && item.type !== \"component\") {\n    return;\n  }\n  return /* @__PURE__ */ React.createElement(RenderLabelContent, { item });\n}\n\nexport { ADDON_ID, Badge, DISPLAY_DEFAULTS, EVENTS, KEY, Sidebar, TOOL_ID, WithBadge, defaultConfig, getTagParts, getTagPrefix, getTagSuffix, matchTag, matchTags, renderLabel, useBadgesToDisplay };\n"],"names":[],"ignoreList":[],"sourceRoot":""}