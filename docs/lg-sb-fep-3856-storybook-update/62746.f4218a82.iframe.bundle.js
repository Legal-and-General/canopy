/*! For license information please see 62746.f4218a82.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_legal_and_general_canopy=self.webpackChunk_legal_and_general_canopy||[]).push([[62746],{"./node_modules/@angular/platform-browser/fesm2022/animations.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{ANIMATION_MODULE_TYPE:()=>core.ANIMATION_MODULE_TYPE,BrowserAnimationsModule:()=>BrowserAnimationsModule,NoopAnimationsModule:()=>NoopAnimationsModule,provideAnimations:()=>provideAnimations,provideNoopAnimations:()=>provideNoopAnimations,ɵInjectableAnimationEngine:()=>InjectableAnimationEngine});var AnimationMetadataType,core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),platform_browser=__webpack_require__("./node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs");!function(AnimationMetadataType){AnimationMetadataType[AnimationMetadataType.State=0]="State",AnimationMetadataType[AnimationMetadataType.Transition=1]="Transition",AnimationMetadataType[AnimationMetadataType.Sequence=2]="Sequence",AnimationMetadataType[AnimationMetadataType.Group=3]="Group",AnimationMetadataType[AnimationMetadataType.Animate=4]="Animate",AnimationMetadataType[AnimationMetadataType.Keyframes=5]="Keyframes",AnimationMetadataType[AnimationMetadataType.Style=6]="Style",AnimationMetadataType[AnimationMetadataType.Trigger=7]="Trigger",AnimationMetadataType[AnimationMetadataType.Reference=8]="Reference",AnimationMetadataType[AnimationMetadataType.AnimateChild=9]="AnimateChild",AnimationMetadataType[AnimationMetadataType.AnimateRef=10]="AnimateRef",AnimationMetadataType[AnimationMetadataType.Query=11]="Query",AnimationMetadataType[AnimationMetadataType.Stagger=12]="Stagger"}(AnimationMetadataType||(AnimationMetadataType={}));function sequence(steps,options=null){return{type:AnimationMetadataType.Sequence,steps,options}}function style(tokens){return{type:AnimationMetadataType.Style,styles:tokens,offset:null}}class AnimationBuilder{static{this.ɵfac=function AnimationBuilder_Factory(__ngFactoryType__){return new(__ngFactoryType__||AnimationBuilder)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:AnimationBuilder,factory:()=>(0,core.inject)(BrowserAnimationBuilder),providedIn:"root"})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](AnimationBuilder,[{type:core.Injectable,args:[{providedIn:"root",useFactory:()=>(0,core.inject)(BrowserAnimationBuilder)}]}],null,null);class AnimationFactory{}class BrowserAnimationBuilder extends AnimationBuilder{constructor(rootRenderer,doc){super(),this.animationModuleType=(0,core.inject)(core.ANIMATION_MODULE_TYPE,{optional:!0}),this._nextAnimationId=0;const typeData={id:"0",encapsulation:core.ViewEncapsulation.None,styles:[],data:{animation:[]}};if(this._renderer=rootRenderer.createRenderer(doc.body,typeData),null===this.animationModuleType&&!function isAnimationRenderer(renderer){const type=renderer.ɵtype;return 0===type||1===type}(this._renderer))throw new core["ɵRuntimeError"](3600,("undefined"==typeof ngDevMode||ngDevMode)&&"Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.")}build(animation){const id=this._nextAnimationId;this._nextAnimationId++;const entry=Array.isArray(animation)?sequence(animation):animation;return issueAnimationCommand(this._renderer,null,id,"register",[entry]),new BrowserAnimationFactory(id,this._renderer)}static{this.ɵfac=function BrowserAnimationBuilder_Factory(__ngFactoryType__){return new(__ngFactoryType__||BrowserAnimationBuilder)(core["ɵɵinject"](core.RendererFactory2),core["ɵɵinject"](common.qQ))}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:BrowserAnimationBuilder,factory:BrowserAnimationBuilder.ɵfac,providedIn:"root"})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](BrowserAnimationBuilder,[{type:core.Injectable,args:[{providedIn:"root"}]}],(()=>[{type:core.RendererFactory2},{type:Document,decorators:[{type:core.Inject,args:[common.qQ]}]}]),null);class BrowserAnimationFactory extends AnimationFactory{constructor(_id,_renderer){super(),this._id=_id,this._renderer=_renderer}create(element,options){return new RendererAnimationPlayer(this._id,element,options||{},this._renderer)}}class RendererAnimationPlayer{constructor(id,element,options,_renderer){this.id=id,this.element=element,this._renderer=_renderer,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",options)}_listen(eventName,callback){return this._renderer.listen(this.element,`@@${this.id}:${eventName}`,callback)}_command(command,...args){issueAnimationCommand(this._renderer,this.element,this.id,command,args)}onDone(fn){this._listen("done",fn)}onStart(fn){this._listen("start",fn)}onDestroy(fn){this._listen("destroy",fn)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(p){this._command("setPosition",p)}getPosition(){return function unwrapAnimationRenderer(renderer){const type=renderer.ɵtype;if(0===type)return renderer;if(1===type)return renderer.animationRenderer;return null}(this._renderer)?.engine?.players[this.id]?.getPosition()??0}}function issueAnimationCommand(renderer,element,id,command,args){renderer.setProperty(element,`@@${id}:${command}`,args)}class NoopAnimationPlayer{constructor(duration=0,delay=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=duration+delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach((fn=>fn())),this._onDoneFns=[])}onStart(fn){this._originalOnStartFns.push(fn),this._onStartFns.push(fn)}onDone(fn){this._originalOnDoneFns.push(fn),this._onDoneFns.push(fn)}onDestroy(fn){this._onDestroyFns.push(fn)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){queueMicrotask((()=>this._onFinish()))}_onStart(){this._onStartFns.forEach((fn=>fn())),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach((fn=>fn())),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(position){this._position=this.totalTime?position*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(phaseName){const methods="start"==phaseName?this._onStartFns:this._onDoneFns;methods.forEach((fn=>fn())),methods.length=0}}class AnimationGroupPlayer{constructor(_players){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=_players;let doneCount=0,destroyCount=0,startCount=0;const total=this.players.length;0==total?queueMicrotask((()=>this._onFinish())):this.players.forEach((player=>{player.onDone((()=>{++doneCount==total&&this._onFinish()})),player.onDestroy((()=>{++destroyCount==total&&this._onDestroy()})),player.onStart((()=>{++startCount==total&&this._onStart()}))})),this.totalTime=this.players.reduce(((time,player)=>Math.max(time,player.totalTime)),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach((fn=>fn())),this._onDoneFns=[])}init(){this.players.forEach((player=>player.init()))}onStart(fn){this._onStartFns.push(fn)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach((fn=>fn())),this._onStartFns=[])}onDone(fn){this._onDoneFns.push(fn)}onDestroy(fn){this._onDestroyFns.push(fn)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach((player=>player.play()))}pause(){this.players.forEach((player=>player.pause()))}restart(){this.players.forEach((player=>player.restart()))}finish(){this._onFinish(),this.players.forEach((player=>player.finish()))}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach((player=>player.destroy())),this._onDestroyFns.forEach((fn=>fn())),this._onDestroyFns=[])}reset(){this.players.forEach((player=>player.reset())),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(p){const timeAtPosition=p*this.totalTime;this.players.forEach((player=>{const position=player.totalTime?Math.min(1,timeAtPosition/player.totalTime):1;player.setPosition(position)}))}getPosition(){const longestPlayer=this.players.reduce(((longestSoFar,player)=>null===longestSoFar||player.totalTime>longestSoFar.totalTime?player:longestSoFar),null);return null!=longestPlayer?longestPlayer.getPosition():0}beforeDestroy(){this.players.forEach((player=>{player.beforeDestroy&&player.beforeDestroy()}))}triggerCallback(phaseName){const methods="start"==phaseName?this._onStartFns:this._onDoneFns;methods.forEach((fn=>fn())),methods.length=0}}function invalidTimingValue(exp){return new core["ɵRuntimeError"](3e3,ngDevMode&&`The provided timing value "${exp}" is invalid.`)}const ANIMATABLE_PROP_SET=new Set(["-moz-outline-radius","-moz-outline-radius-bottomleft","-moz-outline-radius-bottomright","-moz-outline-radius-topleft","-moz-outline-radius-topright","-ms-grid-columns","-ms-grid-rows","-webkit-line-clamp","-webkit-text-fill-color","-webkit-text-stroke","-webkit-text-stroke-color","accent-color","all","backdrop-filter","background","background-color","background-position","background-size","block-size","border","border-block-end","border-block-end-color","border-block-end-width","border-block-start","border-block-start-color","border-block-start-width","border-bottom","border-bottom-color","border-bottom-left-radius","border-bottom-right-radius","border-bottom-width","border-color","border-end-end-radius","border-end-start-radius","border-image-outset","border-image-slice","border-image-width","border-inline-end","border-inline-end-color","border-inline-end-width","border-inline-start","border-inline-start-color","border-inline-start-width","border-left","border-left-color","border-left-width","border-radius","border-right","border-right-color","border-right-width","border-start-end-radius","border-start-start-radius","border-top","border-top-color","border-top-left-radius","border-top-right-radius","border-top-width","border-width","bottom","box-shadow","caret-color","clip","clip-path","color","column-count","column-gap","column-rule","column-rule-color","column-rule-width","column-width","columns","filter","flex","flex-basis","flex-grow","flex-shrink","font","font-size","font-size-adjust","font-stretch","font-variation-settings","font-weight","gap","grid-column-gap","grid-gap","grid-row-gap","grid-template-columns","grid-template-rows","height","inline-size","input-security","inset","inset-block","inset-block-end","inset-block-start","inset-inline","inset-inline-end","inset-inline-start","left","letter-spacing","line-clamp","line-height","margin","margin-block-end","margin-block-start","margin-bottom","margin-inline-end","margin-inline-start","margin-left","margin-right","margin-top","mask","mask-border","mask-position","mask-size","max-block-size","max-height","max-inline-size","max-lines","max-width","min-block-size","min-height","min-inline-size","min-width","object-position","offset","offset-anchor","offset-distance","offset-path","offset-position","offset-rotate","opacity","order","outline","outline-color","outline-offset","outline-width","padding","padding-block-end","padding-block-start","padding-bottom","padding-inline-end","padding-inline-start","padding-left","padding-right","padding-top","perspective","perspective-origin","right","rotate","row-gap","scale","scroll-margin","scroll-margin-block","scroll-margin-block-end","scroll-margin-block-start","scroll-margin-bottom","scroll-margin-inline","scroll-margin-inline-end","scroll-margin-inline-start","scroll-margin-left","scroll-margin-right","scroll-margin-top","scroll-padding","scroll-padding-block","scroll-padding-block-end","scroll-padding-block-start","scroll-padding-bottom","scroll-padding-inline","scroll-padding-inline-end","scroll-padding-inline-start","scroll-padding-left","scroll-padding-right","scroll-padding-top","scroll-snap-coordinate","scroll-snap-destination","scrollbar-color","shape-image-threshold","shape-margin","shape-outside","tab-size","text-decoration","text-decoration-color","text-decoration-thickness","text-emphasis","text-emphasis-color","text-indent","text-shadow","text-underline-offset","top","transform","transform-origin","translate","vertical-align","visibility","width","word-spacing","z-index","zoom"]);function optimizeGroupPlayer(players){switch(players.length){case 0:return new NoopAnimationPlayer;case 1:return players[0];default:return new AnimationGroupPlayer(players)}}function normalizeKeyframes$1(normalizer,keyframes,preStyles=new Map,postStyles=new Map){const errors=[],normalizedKeyframes=[];let previousOffset=-1,previousKeyframe=null;if(keyframes.forEach((kf=>{const offset=kf.get("offset"),isSameOffset=offset==previousOffset,normalizedKeyframe=isSameOffset&&previousKeyframe||new Map;kf.forEach(((val,prop)=>{let normalizedProp=prop,normalizedValue=val;if("offset"!==prop)switch(normalizedProp=normalizer.normalizePropertyName(normalizedProp,errors),normalizedValue){case"!":normalizedValue=preStyles.get(prop);break;case"*":normalizedValue=postStyles.get(prop);break;default:normalizedValue=normalizer.normalizeStyleValue(prop,normalizedProp,normalizedValue,errors)}normalizedKeyframe.set(normalizedProp,normalizedValue)})),isSameOffset||normalizedKeyframes.push(normalizedKeyframe),previousKeyframe=normalizedKeyframe,previousOffset=offset})),errors.length)throw function animationFailed(errors){return new core["ɵRuntimeError"](3502,ngDevMode&&`Unable to animate due to the following errors:\n - ${errors.map((err=>err.message)).join("\n - ")}`)}(errors);return normalizedKeyframes}function listenOnPlayer(player,eventName,event,callback){switch(eventName){case"start":player.onStart((()=>callback(event&&copyAnimationEvent(event,"start",player))));break;case"done":player.onDone((()=>callback(event&&copyAnimationEvent(event,"done",player))));break;case"destroy":player.onDestroy((()=>callback(event&&copyAnimationEvent(event,"destroy",player))))}}function copyAnimationEvent(e,phaseName,player){const totalTime=player.totalTime,disabled=!!player.disabled,event=makeAnimationEvent(e.element,e.triggerName,e.fromState,e.toState,phaseName||e.phaseName,null==totalTime?e.totalTime:totalTime,disabled),data=e._data;return null!=data&&(event._data=data),event}function makeAnimationEvent(element,triggerName,fromState,toState,phaseName="",totalTime=0,disabled){return{element,triggerName,fromState,toState,phaseName,totalTime,disabled:!!disabled}}function getOrSetDefaultValue(map,key,defaultValue){let value=map.get(key);return value||map.set(key,value=defaultValue),value}function parseTimelineCommand(command){const separatorPos=command.indexOf(":");return[command.substring(1,separatorPos),command.slice(separatorPos+1)]}const documentElement=(()=>"undefined"==typeof document?null:document.documentElement)();function getParentElement(element){const parent=element.parentNode||element.host||null;return parent===documentElement?null:parent}let _CACHED_BODY=null,_IS_WEBKIT=!1;function validateStyleProperty(prop){_CACHED_BODY||(_CACHED_BODY=function getBodyNode(){if("undefined"!=typeof document)return document.body;return null}()||{},_IS_WEBKIT=!!_CACHED_BODY.style&&"WebkitAppearance"in _CACHED_BODY.style);let result=!0;if(_CACHED_BODY.style&&!function containsVendorPrefix(prop){return"ebkit"==prop.substring(1,6)}(prop)&&(result=prop in _CACHED_BODY.style,!result&&_IS_WEBKIT)){result="Webkit"+prop.charAt(0).toUpperCase()+prop.slice(1)in _CACHED_BODY.style}return result}function containsElement(elm1,elm2){for(;elm2;){if(elm2===elm1)return!0;elm2=getParentElement(elm2)}return!1}function invokeQuery(element,selector,multi){if(multi)return Array.from(element.querySelectorAll(selector));const elem=element.querySelector(selector);return elem?[elem]:[]}class NoopAnimationDriver{validateStyleProperty(prop){return validateStyleProperty(prop)}containsElement(elm1,elm2){return containsElement(elm1,elm2)}getParentElement(element){return getParentElement(element)}query(element,selector,multi){return invokeQuery(element,selector,multi)}computeStyle(element,prop,defaultValue){return defaultValue||""}animate(element,keyframes,duration,delay,easing,previousPlayers=[],scrubberAccessRequested){return new NoopAnimationPlayer(duration,delay)}static{this.ɵfac=function NoopAnimationDriver_Factory(__ngFactoryType__){return new(__ngFactoryType__||NoopAnimationDriver)}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:NoopAnimationDriver,factory:NoopAnimationDriver.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](NoopAnimationDriver,[{type:core.Injectable}],null,null);class AnimationDriver{static{this.NOOP=new NoopAnimationDriver}}class AnimationStyleNormalizer{}function resolveTimingValue(value){if("number"==typeof value)return value;const matches=value.match(/^(-?[\.\d]+)(m?s)/);return!matches||matches.length<2?0:_convertTimeValueToMS(parseFloat(matches[1]),matches[2])}function _convertTimeValueToMS(value,unit){return"s"===unit?1e3*value:value}function resolveTiming(timings,errors,allowNegativeValues){return timings.hasOwnProperty("duration")?timings:function parseTimeExpression(exp,errors,allowNegativeValues){const regex=/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;let duration,delay=0,easing="";if("string"==typeof exp){const matches=exp.match(regex);if(null===matches)return errors.push(invalidTimingValue(exp)),{duration:0,delay:0,easing:""};duration=_convertTimeValueToMS(parseFloat(matches[1]),matches[2]);const delayMatch=matches[3];null!=delayMatch&&(delay=_convertTimeValueToMS(parseFloat(delayMatch),matches[4]));const easingVal=matches[5];easingVal&&(easing=easingVal)}else duration=exp;if(!allowNegativeValues){let containsErrors=!1,startIndex=errors.length;duration<0&&(errors.push(function negativeStepValue(){return new core["ɵRuntimeError"](3100,ngDevMode&&"Duration values below 0 are not allowed for this animation step.")}()),containsErrors=!0),delay<0&&(errors.push(function negativeDelayValue(){return new core["ɵRuntimeError"](3101,ngDevMode&&"Delay values below 0 are not allowed for this animation step.")}()),containsErrors=!0),containsErrors&&errors.splice(startIndex,0,invalidTimingValue(exp))}return{duration,delay,easing}}(timings,errors,allowNegativeValues)}function setStyles(element,styles,formerStyles){styles.forEach(((val,prop)=>{const camelProp=dashCaseToCamelCase(prop);formerStyles&&!formerStyles.has(prop)&&formerStyles.set(prop,element.style[camelProp]),element.style[camelProp]=val}))}function eraseStyles(element,styles){styles.forEach(((_,prop)=>{const camelProp=dashCaseToCamelCase(prop);element.style[camelProp]=""}))}function normalizeAnimationEntry(steps){return Array.isArray(steps)?1==steps.length?steps[0]:sequence(steps):steps}function validateStyleParams(value,options,errors){const params=options.params||{},matches=extractStyleParams(value);matches.length&&matches.forEach((varName=>{params.hasOwnProperty(varName)||errors.push(function invalidStyleParams(varName){return new core["ɵRuntimeError"](3001,ngDevMode&&`Unable to resolve the local animation param ${varName} in the given list of values`)}(varName))}))}const PARAM_REGEX=new RegExp("{{\\s*(.+?)\\s*}}","g");function extractStyleParams(value){let params=[];if("string"==typeof value){let match;for(;match=PARAM_REGEX.exec(value);)params.push(match[1]);PARAM_REGEX.lastIndex=0}return params}function interpolateParams(value,params,errors){const original=`${value}`,str=original.replace(PARAM_REGEX,((_,varName)=>{let localVal=params[varName];return null==localVal&&(errors.push(function invalidParamValue(varName){return new core["ɵRuntimeError"](3003,ngDevMode&&`Please provide a value for the animation param ${varName}`)}(varName)),localVal=""),localVal.toString()}));return str==original?value:str}const DASH_CASE_REGEXP=/-+([a-z0-9])/g;function dashCaseToCamelCase(input){return input.replace(DASH_CASE_REGEXP,((...m)=>m[1].toUpperCase()))}function visitDslNode(visitor,node,context){switch(node.type){case AnimationMetadataType.Trigger:return visitor.visitTrigger(node,context);case AnimationMetadataType.State:return visitor.visitState(node,context);case AnimationMetadataType.Transition:return visitor.visitTransition(node,context);case AnimationMetadataType.Sequence:return visitor.visitSequence(node,context);case AnimationMetadataType.Group:return visitor.visitGroup(node,context);case AnimationMetadataType.Animate:return visitor.visitAnimate(node,context);case AnimationMetadataType.Keyframes:return visitor.visitKeyframes(node,context);case AnimationMetadataType.Style:return visitor.visitStyle(node,context);case AnimationMetadataType.Reference:return visitor.visitReference(node,context);case AnimationMetadataType.AnimateChild:return visitor.visitAnimateChild(node,context);case AnimationMetadataType.AnimateRef:return visitor.visitAnimateRef(node,context);case AnimationMetadataType.Query:return visitor.visitQuery(node,context);case AnimationMetadataType.Stagger:return visitor.visitStagger(node,context);default:throw function invalidNodeType(nodeType){return new core["ɵRuntimeError"](3004,ngDevMode&&`Unable to resolve animation metadata node #${nodeType}`)}(node.type)}}function computeStyle(element,prop){return window.getComputedStyle(element)[prop]}const DIMENSIONAL_PROP_SET=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class WebAnimationsStyleNormalizer extends AnimationStyleNormalizer{normalizePropertyName(propertyName,errors){return dashCaseToCamelCase(propertyName)}normalizeStyleValue(userProvidedProperty,normalizedProperty,value,errors){let unit="";const strVal=value.toString().trim();if(DIMENSIONAL_PROP_SET.has(normalizedProperty)&&0!==value&&"0"!==value)if("number"==typeof value)unit="px";else{const valAndSuffixMatch=value.match(/^[+-]?[\d\.]+([a-z]*)$/);valAndSuffixMatch&&0==valAndSuffixMatch[1].length&&errors.push(function invalidCssUnitValue(userProvidedProperty,value){return new core["ɵRuntimeError"](3005,ngDevMode&&`Please provide a CSS unit value for ${userProvidedProperty}:${value}`)}(userProvidedProperty,value))}return strVal+unit}}function createListOfWarnings(warnings){return`\n - ${warnings.filter(Boolean).map((warning=>warning)).join("\n - ")}`}function parseTransitionExpr(transitionValue,errors){const expressions=[];return"string"==typeof transitionValue?transitionValue.split(/\s*,\s*/).forEach((str=>function parseInnerTransitionStr(eventStr,expressions,errors){if(":"==eventStr[0]){const result=function parseAnimationAlias(alias,errors){switch(alias){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(fromState,toState)=>parseFloat(toState)>parseFloat(fromState);case":decrement":return(fromState,toState)=>parseFloat(toState)<parseFloat(fromState);default:return errors.push(function invalidTransitionAlias(alias){return new core["ɵRuntimeError"](3016,ngDevMode&&`The transition alias value "${alias}" is not supported`)}(alias)),"* => *"}}(eventStr,errors);if("function"==typeof result)return void expressions.push(result);eventStr=result}const match=eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==match||match.length<4)return errors.push(function invalidExpression(expr){return new core["ɵRuntimeError"](3015,ngDevMode&&`The provided transition expression "${expr}" is not supported`)}(eventStr)),expressions;const fromState=match[1],separator=match[2],toState=match[3];expressions.push(makeLambdaFromStates(fromState,toState));const isFullAnyStateExpr="*"==fromState&&"*"==toState;"<"!=separator[0]||isFullAnyStateExpr||expressions.push(makeLambdaFromStates(toState,fromState));return}(str,expressions,errors))):expressions.push(transitionValue),expressions}const TRUE_BOOLEAN_VALUES=new Set(["true","1"]),FALSE_BOOLEAN_VALUES=new Set(["false","0"]);function makeLambdaFromStates(lhs,rhs){const LHS_MATCH_BOOLEAN=TRUE_BOOLEAN_VALUES.has(lhs)||FALSE_BOOLEAN_VALUES.has(lhs),RHS_MATCH_BOOLEAN=TRUE_BOOLEAN_VALUES.has(rhs)||FALSE_BOOLEAN_VALUES.has(rhs);return(fromState,toState)=>{let lhsMatch="*"==lhs||lhs==fromState,rhsMatch="*"==rhs||rhs==toState;return!lhsMatch&&LHS_MATCH_BOOLEAN&&"boolean"==typeof fromState&&(lhsMatch=fromState?TRUE_BOOLEAN_VALUES.has(lhs):FALSE_BOOLEAN_VALUES.has(lhs)),!rhsMatch&&RHS_MATCH_BOOLEAN&&"boolean"==typeof toState&&(rhsMatch=toState?TRUE_BOOLEAN_VALUES.has(rhs):FALSE_BOOLEAN_VALUES.has(rhs)),lhsMatch&&rhsMatch}}const SELF_TOKEN_REGEX=new RegExp("s*:selfs*,?","g");function buildAnimationAst(driver,metadata,errors,warnings){return new AnimationAstBuilderVisitor(driver).build(metadata,errors,warnings)}class AnimationAstBuilderVisitor{constructor(_driver){this._driver=_driver}build(metadata,errors,warnings){const context=new AnimationAstBuilderContext(errors);this._resetContextStyleTimingState(context);const ast=visitDslNode(this,normalizeAnimationEntry(metadata),context);return("undefined"==typeof ngDevMode||ngDevMode)&&context.unsupportedCSSPropertiesFound.size&&function pushUnrecognizedPropertiesWarning(warnings,props){props.length&&warnings.push(`The following provided properties are not recognized: ${props.join(", ")}`)}(warnings,[...context.unsupportedCSSPropertiesFound.keys()]),ast}_resetContextStyleTimingState(context){context.currentQuerySelector="",context.collectedStyles=new Map,context.collectedStyles.set("",new Map),context.currentTime=0}visitTrigger(metadata,context){let queryCount=context.queryCount=0,depCount=context.depCount=0;const states=[],transitions=[];return"@"==metadata.name.charAt(0)&&context.errors.push(function invalidTrigger(){return new core["ɵRuntimeError"](3006,ngDevMode&&"animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))")}()),metadata.definitions.forEach((def=>{if(this._resetContextStyleTimingState(context),def.type==AnimationMetadataType.State){const stateDef=def,name=stateDef.name;name.toString().split(/\s*,\s*/).forEach((n=>{stateDef.name=n,states.push(this.visitState(stateDef,context))})),stateDef.name=name}else if(def.type==AnimationMetadataType.Transition){const transition=this.visitTransition(def,context);queryCount+=transition.queryCount,depCount+=transition.depCount,transitions.push(transition)}else context.errors.push(function invalidDefinition(){return new core["ɵRuntimeError"](3007,ngDevMode&&"only state() and transition() definitions can sit inside of a trigger()")}())})),{type:AnimationMetadataType.Trigger,name:metadata.name,states,transitions,queryCount,depCount,options:null}}visitState(metadata,context){const styleAst=this.visitStyle(metadata.styles,context),astParams=metadata.options&&metadata.options.params||null;if(styleAst.containsDynamicStyles){const missingSubs=new Set,params=astParams||{};styleAst.styles.forEach((style=>{style instanceof Map&&style.forEach((value=>{extractStyleParams(value).forEach((sub=>{params.hasOwnProperty(sub)||missingSubs.add(sub)}))}))})),missingSubs.size&&context.errors.push(function invalidState(metadataName,missingSubs){return new core["ɵRuntimeError"](3008,ngDevMode&&`state("${metadataName}", ...) must define default values for all the following style substitutions: ${missingSubs.join(", ")}`)}(metadata.name,[...missingSubs.values()]))}return{type:AnimationMetadataType.State,name:metadata.name,style:styleAst,options:astParams?{params:astParams}:null}}visitTransition(metadata,context){context.queryCount=0,context.depCount=0;const animation=visitDslNode(this,normalizeAnimationEntry(metadata.animation),context),matchers=parseTransitionExpr(metadata.expr,context.errors);return{type:AnimationMetadataType.Transition,matchers,animation,queryCount:context.queryCount,depCount:context.depCount,options:normalizeAnimationOptions(metadata.options)}}visitSequence(metadata,context){return{type:AnimationMetadataType.Sequence,steps:metadata.steps.map((s=>visitDslNode(this,s,context))),options:normalizeAnimationOptions(metadata.options)}}visitGroup(metadata,context){const currentTime=context.currentTime;let furthestTime=0;const steps=metadata.steps.map((step=>{context.currentTime=currentTime;const innerAst=visitDslNode(this,step,context);return furthestTime=Math.max(furthestTime,context.currentTime),innerAst}));return context.currentTime=furthestTime,{type:AnimationMetadataType.Group,steps,options:normalizeAnimationOptions(metadata.options)}}visitAnimate(metadata,context){const timingAst=function constructTimingAst(value,errors){if(value.hasOwnProperty("duration"))return value;if("number"==typeof value){return makeTimingAst(resolveTiming(value,errors).duration,0,"")}const strValue=value;if(strValue.split(/\s+/).some((v=>"{"==v.charAt(0)&&"{"==v.charAt(1)))){const ast=makeTimingAst(0,0,"");return ast.dynamic=!0,ast.strValue=strValue,ast}const timings=resolveTiming(strValue,errors);return makeTimingAst(timings.duration,timings.delay,timings.easing)}(metadata.timings,context.errors);let styleAst;context.currentAnimateTimings=timingAst;let styleMetadata=metadata.styles?metadata.styles:style({});if(styleMetadata.type==AnimationMetadataType.Keyframes)styleAst=this.visitKeyframes(styleMetadata,context);else{let styleMetadata=metadata.styles,isEmpty=!1;if(!styleMetadata){isEmpty=!0;const newStyleData={};timingAst.easing&&(newStyleData.easing=timingAst.easing),styleMetadata=style(newStyleData)}context.currentTime+=timingAst.duration+timingAst.delay;const _styleAst=this.visitStyle(styleMetadata,context);_styleAst.isEmptyStep=isEmpty,styleAst=_styleAst}return context.currentAnimateTimings=null,{type:AnimationMetadataType.Animate,timings:timingAst,style:styleAst,options:null}}visitStyle(metadata,context){const ast=this._makeStyleAst(metadata,context);return this._validateStyleAst(ast,context),ast}_makeStyleAst(metadata,context){const styles=[],metadataStyles=Array.isArray(metadata.styles)?metadata.styles:[metadata.styles];for(let styleTuple of metadataStyles)"string"==typeof styleTuple?"*"===styleTuple?styles.push(styleTuple):context.errors.push((value=styleTuple,new core["ɵRuntimeError"](3002,ngDevMode&&`The provided style string value ${value} is not allowed.`))):styles.push(new Map(Object.entries(styleTuple)));var value;let containsDynamicStyles=!1,collectedEasing=null;return styles.forEach((styleData=>{if(styleData instanceof Map&&(styleData.has("easing")&&(collectedEasing=styleData.get("easing"),styleData.delete("easing")),!containsDynamicStyles))for(let value of styleData.values())if(value.toString().indexOf("{{")>=0){containsDynamicStyles=!0;break}})),{type:AnimationMetadataType.Style,styles,easing:collectedEasing,offset:metadata.offset,containsDynamicStyles,options:null}}_validateStyleAst(ast,context){const timings=context.currentAnimateTimings;let endTime=context.currentTime,startTime=context.currentTime;timings&&startTime>0&&(startTime-=timings.duration+timings.delay),ast.styles.forEach((tuple=>{"string"!=typeof tuple&&tuple.forEach(((value,prop)=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&!this._driver.validateStyleProperty(prop))return tuple.delete(prop),void context.unsupportedCSSPropertiesFound.add(prop);const collectedStyles=context.collectedStyles.get(context.currentQuerySelector),collectedEntry=collectedStyles.get(prop);let updateCollectedStyle=!0;collectedEntry&&(startTime!=endTime&&startTime>=collectedEntry.startTime&&endTime<=collectedEntry.endTime&&(context.errors.push(function invalidParallelAnimation(prop,firstStart,firstEnd,secondStart,secondEnd){return new core["ɵRuntimeError"](3010,ngDevMode&&`The CSS property "${prop}" that exists between the times of "${firstStart}ms" and "${firstEnd}ms" is also being animated in a parallel animation between the times of "${secondStart}ms" and "${secondEnd}ms"`)}(prop,collectedEntry.startTime,collectedEntry.endTime,startTime,endTime)),updateCollectedStyle=!1),startTime=collectedEntry.startTime),updateCollectedStyle&&collectedStyles.set(prop,{startTime,endTime}),context.options&&validateStyleParams(value,context.options,context.errors)}))}))}visitKeyframes(metadata,context){const ast={type:AnimationMetadataType.Keyframes,styles:[],options:null};if(!context.currentAnimateTimings)return context.errors.push(function invalidKeyframes(){return new core["ɵRuntimeError"](3011,ngDevMode&&"keyframes() must be placed inside of a call to animate()")}()),ast;let totalKeyframesWithOffsets=0;const offsets=[];let offsetsOutOfOrder=!1,keyframesOutOfRange=!1,previousOffset=0;const keyframes=metadata.steps.map((styles=>{const style=this._makeStyleAst(styles,context);let offsetVal=null!=style.offset?style.offset:function consumeOffset(styles){if("string"==typeof styles)return null;let offset=null;if(Array.isArray(styles))styles.forEach((styleTuple=>{if(styleTuple instanceof Map&&styleTuple.has("offset")){const obj=styleTuple;offset=parseFloat(obj.get("offset")),obj.delete("offset")}}));else if(styles instanceof Map&&styles.has("offset")){const obj=styles;offset=parseFloat(obj.get("offset")),obj.delete("offset")}return offset}(style.styles),offset=0;return null!=offsetVal&&(totalKeyframesWithOffsets++,offset=style.offset=offsetVal),keyframesOutOfRange=keyframesOutOfRange||offset<0||offset>1,offsetsOutOfOrder=offsetsOutOfOrder||offset<previousOffset,previousOffset=offset,offsets.push(offset),style}));keyframesOutOfRange&&context.errors.push(function invalidOffset(){return new core["ɵRuntimeError"](3012,ngDevMode&&"Please ensure that all keyframe offsets are between 0 and 1")}()),offsetsOutOfOrder&&context.errors.push(function keyframeOffsetsOutOfOrder(){return new core["ɵRuntimeError"](3200,ngDevMode&&"Please ensure that all keyframe offsets are in order")}());const length=metadata.steps.length;let generatedOffset=0;totalKeyframesWithOffsets>0&&totalKeyframesWithOffsets<length?context.errors.push(function keyframesMissingOffsets(){return new core["ɵRuntimeError"](3202,ngDevMode&&"Not all style() steps within the declared keyframes() contain offsets")}()):0==totalKeyframesWithOffsets&&(generatedOffset=1/(length-1));const limit=length-1,currentTime=context.currentTime,currentAnimateTimings=context.currentAnimateTimings,animateDuration=currentAnimateTimings.duration;return keyframes.forEach(((kf,i)=>{const offset=generatedOffset>0?i==limit?1:generatedOffset*i:offsets[i],durationUpToThisFrame=offset*animateDuration;context.currentTime=currentTime+currentAnimateTimings.delay+durationUpToThisFrame,currentAnimateTimings.duration=durationUpToThisFrame,this._validateStyleAst(kf,context),kf.offset=offset,ast.styles.push(kf)})),ast}visitReference(metadata,context){return{type:AnimationMetadataType.Reference,animation:visitDslNode(this,normalizeAnimationEntry(metadata.animation),context),options:normalizeAnimationOptions(metadata.options)}}visitAnimateChild(metadata,context){return context.depCount++,{type:AnimationMetadataType.AnimateChild,options:normalizeAnimationOptions(metadata.options)}}visitAnimateRef(metadata,context){return{type:AnimationMetadataType.AnimateRef,animation:this.visitReference(metadata.animation,context),options:normalizeAnimationOptions(metadata.options)}}visitQuery(metadata,context){const parentSelector=context.currentQuerySelector,options=metadata.options||{};context.queryCount++,context.currentQuery=metadata;const[selector,includeSelf]=function normalizeSelector(selector){const hasAmpersand=!!selector.split(/\s*,\s*/).find((token=>":self"==token));hasAmpersand&&(selector=selector.replace(SELF_TOKEN_REGEX,""));return selector=selector.replace(/@\*/g,".ng-trigger").replace(/@\w+/g,(match=>".ng-trigger-"+match.slice(1))).replace(/:animating/g,".ng-animating"),[selector,hasAmpersand]}(metadata.selector);context.currentQuerySelector=parentSelector.length?parentSelector+" "+selector:selector,getOrSetDefaultValue(context.collectedStyles,context.currentQuerySelector,new Map);const animation=visitDslNode(this,normalizeAnimationEntry(metadata.animation),context);return context.currentQuery=null,context.currentQuerySelector=parentSelector,{type:AnimationMetadataType.Query,selector,limit:options.limit||0,optional:!!options.optional,includeSelf,animation,originalSelector:metadata.selector,options:normalizeAnimationOptions(metadata.options)}}visitStagger(metadata,context){context.currentQuery||context.errors.push(function invalidStagger(){return new core["ɵRuntimeError"](3013,ngDevMode&&"stagger() can only be used inside of query()")}());const timings="full"===metadata.timings?{duration:0,delay:0,easing:"full"}:resolveTiming(metadata.timings,context.errors,!0);return{type:AnimationMetadataType.Stagger,animation:visitDslNode(this,normalizeAnimationEntry(metadata.animation),context),timings,options:null}}}class AnimationAstBuilderContext{constructor(errors){this.errors=errors,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function normalizeAnimationOptions(options){return options?(options={...options}).params&&(options.params=function normalizeParams(obj){return obj?{...obj}:null}(options.params)):options={},options}function makeTimingAst(duration,delay,easing){return{duration,delay,easing}}function createTimelineInstruction(element,keyframes,preStyleProps,postStyleProps,duration,delay,easing=null,subTimeline=!1){return{type:1,element,keyframes,preStyleProps,postStyleProps,duration,delay,totalTime:duration+delay,easing,subTimeline}}class ElementInstructionMap{constructor(){this._map=new Map}get(element){return this._map.get(element)||[]}append(element,instructions){let existingInstructions=this._map.get(element);existingInstructions||this._map.set(element,existingInstructions=[]),existingInstructions.push(...instructions)}has(element){return this._map.has(element)}clear(){this._map.clear()}}const ENTER_TOKEN_REGEX=new RegExp(":enter","g"),LEAVE_TOKEN_REGEX=new RegExp(":leave","g");function buildAnimationTimelines(driver,rootElement,ast,enterClassName,leaveClassName,startingStyles=new Map,finalStyles=new Map,options,subInstructions,errors=[]){return(new AnimationTimelineBuilderVisitor).buildKeyframes(driver,rootElement,ast,enterClassName,leaveClassName,startingStyles,finalStyles,options,subInstructions,errors)}class AnimationTimelineBuilderVisitor{buildKeyframes(driver,rootElement,ast,enterClassName,leaveClassName,startingStyles,finalStyles,options,subInstructions,errors=[]){subInstructions=subInstructions||new ElementInstructionMap;const context=new AnimationTimelineContext(driver,rootElement,subInstructions,enterClassName,leaveClassName,errors,[]);context.options=options;const delay=options.delay?resolveTimingValue(options.delay):0;context.currentTimeline.delayNextStep(delay),context.currentTimeline.setStyles([startingStyles],null,context.errors,options),visitDslNode(this,ast,context);const timelines=context.timelines.filter((timeline=>timeline.containsAnimation()));if(timelines.length&&finalStyles.size){let lastRootTimeline;for(let i=timelines.length-1;i>=0;i--){const timeline=timelines[i];if(timeline.element===rootElement){lastRootTimeline=timeline;break}}lastRootTimeline&&!lastRootTimeline.allowOnlyTimelineStyles()&&lastRootTimeline.setStyles([finalStyles],null,context.errors,options)}return timelines.length?timelines.map((timeline=>timeline.buildKeyframes())):[createTimelineInstruction(rootElement,[],[],[],0,delay,"",!1)]}visitTrigger(ast,context){}visitState(ast,context){}visitTransition(ast,context){}visitAnimateChild(ast,context){const elementInstructions=context.subInstructions.get(context.element);if(elementInstructions){const innerContext=context.createSubContext(ast.options),startTime=context.currentTimeline.currentTime,endTime=this._visitSubInstructions(elementInstructions,innerContext,innerContext.options);startTime!=endTime&&context.transformIntoNewTimeline(endTime)}context.previousNode=ast}visitAnimateRef(ast,context){const innerContext=context.createSubContext(ast.options);innerContext.transformIntoNewTimeline(),this._applyAnimationRefDelays([ast.options,ast.animation.options],context,innerContext),this.visitReference(ast.animation,innerContext),context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime),context.previousNode=ast}_applyAnimationRefDelays(animationsRefsOptions,context,innerContext){for(const animationRefOptions of animationsRefsOptions){const animationDelay=animationRefOptions?.delay;if(animationDelay){const animationDelayValue="number"==typeof animationDelay?animationDelay:resolveTimingValue(interpolateParams(animationDelay,animationRefOptions?.params??{},context.errors));innerContext.delayNextStep(animationDelayValue)}}}_visitSubInstructions(instructions,context,options){let furthestTime=context.currentTimeline.currentTime;const duration=null!=options.duration?resolveTimingValue(options.duration):null,delay=null!=options.delay?resolveTimingValue(options.delay):null;return 0!==duration&&instructions.forEach((instruction=>{const instructionTimings=context.appendInstructionToTimeline(instruction,duration,delay);furthestTime=Math.max(furthestTime,instructionTimings.duration+instructionTimings.delay)})),furthestTime}visitReference(ast,context){context.updateOptions(ast.options,!0),visitDslNode(this,ast.animation,context),context.previousNode=ast}visitSequence(ast,context){const subContextCount=context.subContextCount;let ctx=context;const options=ast.options;if(options&&(options.params||options.delay)&&(ctx=context.createSubContext(options),ctx.transformIntoNewTimeline(),null!=options.delay)){ctx.previousNode.type==AnimationMetadataType.Style&&(ctx.currentTimeline.snapshotCurrentStyles(),ctx.previousNode=DEFAULT_NOOP_PREVIOUS_NODE);const delay=resolveTimingValue(options.delay);ctx.delayNextStep(delay)}ast.steps.length&&(ast.steps.forEach((s=>visitDslNode(this,s,ctx))),ctx.currentTimeline.applyStylesToKeyframe(),ctx.subContextCount>subContextCount&&ctx.transformIntoNewTimeline()),context.previousNode=ast}visitGroup(ast,context){const innerTimelines=[];let furthestTime=context.currentTimeline.currentTime;const delay=ast.options&&ast.options.delay?resolveTimingValue(ast.options.delay):0;ast.steps.forEach((s=>{const innerContext=context.createSubContext(ast.options);delay&&innerContext.delayNextStep(delay),visitDslNode(this,s,innerContext),furthestTime=Math.max(furthestTime,innerContext.currentTimeline.currentTime),innerTimelines.push(innerContext.currentTimeline)})),innerTimelines.forEach((timeline=>context.currentTimeline.mergeTimelineCollectedStyles(timeline))),context.transformIntoNewTimeline(furthestTime),context.previousNode=ast}_visitTiming(ast,context){if(ast.dynamic){const strValue=ast.strValue;return resolveTiming(context.params?interpolateParams(strValue,context.params,context.errors):strValue,context.errors)}return{duration:ast.duration,delay:ast.delay,easing:ast.easing}}visitAnimate(ast,context){const timings=context.currentAnimateTimings=this._visitTiming(ast.timings,context),timeline=context.currentTimeline;timings.delay&&(context.incrementTime(timings.delay),timeline.snapshotCurrentStyles());const style=ast.style;style.type==AnimationMetadataType.Keyframes?this.visitKeyframes(style,context):(context.incrementTime(timings.duration),this.visitStyle(style,context),timeline.applyStylesToKeyframe()),context.currentAnimateTimings=null,context.previousNode=ast}visitStyle(ast,context){const timeline=context.currentTimeline,timings=context.currentAnimateTimings;!timings&&timeline.hasCurrentStyleProperties()&&timeline.forwardFrame();const easing=timings&&timings.easing||ast.easing;ast.isEmptyStep?timeline.applyEmptyStep(easing):timeline.setStyles(ast.styles,easing,context.errors,context.options),context.previousNode=ast}visitKeyframes(ast,context){const currentAnimateTimings=context.currentAnimateTimings,startTime=context.currentTimeline.duration,duration=currentAnimateTimings.duration,innerTimeline=context.createSubContext().currentTimeline;innerTimeline.easing=currentAnimateTimings.easing,ast.styles.forEach((step=>{const offset=step.offset||0;innerTimeline.forwardTime(offset*duration),innerTimeline.setStyles(step.styles,step.easing,context.errors,context.options),innerTimeline.applyStylesToKeyframe()})),context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline),context.transformIntoNewTimeline(startTime+duration),context.previousNode=ast}visitQuery(ast,context){const startTime=context.currentTimeline.currentTime,options=ast.options||{},delay=options.delay?resolveTimingValue(options.delay):0;delay&&(context.previousNode.type===AnimationMetadataType.Style||0==startTime&&context.currentTimeline.hasCurrentStyleProperties())&&(context.currentTimeline.snapshotCurrentStyles(),context.previousNode=DEFAULT_NOOP_PREVIOUS_NODE);let furthestTime=startTime;const elms=context.invokeQuery(ast.selector,ast.originalSelector,ast.limit,ast.includeSelf,!!options.optional,context.errors);context.currentQueryTotal=elms.length;let sameElementTimeline=null;elms.forEach(((element,i)=>{context.currentQueryIndex=i;const innerContext=context.createSubContext(ast.options,element);delay&&innerContext.delayNextStep(delay),element===context.element&&(sameElementTimeline=innerContext.currentTimeline),visitDslNode(this,ast.animation,innerContext),innerContext.currentTimeline.applyStylesToKeyframe();const endTime=innerContext.currentTimeline.currentTime;furthestTime=Math.max(furthestTime,endTime)})),context.currentQueryIndex=0,context.currentQueryTotal=0,context.transformIntoNewTimeline(furthestTime),sameElementTimeline&&(context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline),context.currentTimeline.snapshotCurrentStyles()),context.previousNode=ast}visitStagger(ast,context){const parentContext=context.parentContext,tl=context.currentTimeline,timings=ast.timings,duration=Math.abs(timings.duration),maxTime=duration*(context.currentQueryTotal-1);let delay=duration*context.currentQueryIndex;switch(timings.duration<0?"reverse":timings.easing){case"reverse":delay=maxTime-delay;break;case"full":delay=parentContext.currentStaggerTime}const timeline=context.currentTimeline;delay&&timeline.delayNextStep(delay);const startingTime=timeline.currentTime;visitDslNode(this,ast.animation,context),context.previousNode=ast,parentContext.currentStaggerTime=tl.currentTime-startingTime+(tl.startTime-parentContext.currentTimeline.startTime)}}const DEFAULT_NOOP_PREVIOUS_NODE={};class AnimationTimelineContext{constructor(_driver,element,subInstructions,_enterClassName,_leaveClassName,errors,timelines,initialTimeline){this._driver=_driver,this.element=element,this.subInstructions=subInstructions,this._enterClassName=_enterClassName,this._leaveClassName=_leaveClassName,this.errors=errors,this.timelines=timelines,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=DEFAULT_NOOP_PREVIOUS_NODE,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=initialTimeline||new TimelineBuilder(this._driver,element,0),timelines.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(options,skipIfExists){if(!options)return;const newOptions=options;let optionsToUpdate=this.options;null!=newOptions.duration&&(optionsToUpdate.duration=resolveTimingValue(newOptions.duration)),null!=newOptions.delay&&(optionsToUpdate.delay=resolveTimingValue(newOptions.delay));const newParams=newOptions.params;if(newParams){let paramsToUpdate=optionsToUpdate.params;paramsToUpdate||(paramsToUpdate=this.options.params={}),Object.keys(newParams).forEach((name=>{skipIfExists&&paramsToUpdate.hasOwnProperty(name)||(paramsToUpdate[name]=interpolateParams(newParams[name],paramsToUpdate,this.errors))}))}}_copyOptions(){const options={};if(this.options){const oldParams=this.options.params;if(oldParams){const params=options.params={};Object.keys(oldParams).forEach((name=>{params[name]=oldParams[name]}))}}return options}createSubContext(options=null,element,newTime){const target=element||this.element,context=new AnimationTimelineContext(this._driver,target,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(target,newTime||0));return context.previousNode=this.previousNode,context.currentAnimateTimings=this.currentAnimateTimings,context.options=this._copyOptions(),context.updateOptions(options),context.currentQueryIndex=this.currentQueryIndex,context.currentQueryTotal=this.currentQueryTotal,context.parentContext=this,this.subContextCount++,context}transformIntoNewTimeline(newTime){return this.previousNode=DEFAULT_NOOP_PREVIOUS_NODE,this.currentTimeline=this.currentTimeline.fork(this.element,newTime),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(instruction,duration,delay){const updatedTimings={duration:null!=duration?duration:instruction.duration,delay:this.currentTimeline.currentTime+(null!=delay?delay:0)+instruction.delay,easing:""},builder=new SubTimelineBuilder(this._driver,instruction.element,instruction.keyframes,instruction.preStyleProps,instruction.postStyleProps,updatedTimings,instruction.stretchStartingKeyframe);return this.timelines.push(builder),updatedTimings}incrementTime(time){this.currentTimeline.forwardTime(this.currentTimeline.duration+time)}delayNextStep(delay){delay>0&&this.currentTimeline.delayNextStep(delay)}invokeQuery(selector,originalSelector,limit,includeSelf,optional,errors){let results=[];if(includeSelf&&results.push(this.element),selector.length>0){selector=(selector=selector.replace(ENTER_TOKEN_REGEX,"."+this._enterClassName)).replace(LEAVE_TOKEN_REGEX,"."+this._leaveClassName);const multi=1!=limit;let elements=this._driver.query(this.element,selector,multi);0!==limit&&(elements=limit<0?elements.slice(elements.length+limit,elements.length):elements.slice(0,limit)),results.push(...elements)}return optional||0!=results.length||errors.push(function invalidQuery(selector){return new core["ɵRuntimeError"](3014,ngDevMode&&`\`query("${selector}")\` returned zero elements. (Use \`query("${selector}", { optional: true })\` if you wish to allow this.)`)}(originalSelector)),results}}class TimelineBuilder{constructor(_driver,element,startTime,_elementTimelineStylesLookup){this._driver=_driver,this.element=element,this.startTime=startTime,this._elementTimelineStylesLookup=_elementTimelineStylesLookup,this.duration=0,this.easing=null,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(element),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(element,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(delay){const hasPreStyleStep=1===this._keyframes.size&&this._pendingStyles.size;this.duration||hasPreStyleStep?(this.forwardTime(this.currentTime+delay),hasPreStyleStep&&this.snapshotCurrentStyles()):this.startTime+=delay}fork(element,currentTime){return this.applyStylesToKeyframe(),new TimelineBuilder(this._driver,element,currentTime||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(time){this.applyStylesToKeyframe(),this.duration=time,this._loadKeyframe()}_updateStyle(prop,value){this._localTimelineStyles.set(prop,value),this._globalTimelineStyles.set(prop,value),this._styleSummary.set(prop,{time:this.currentTime,value})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(easing){easing&&this._previousKeyframe.set("easing",easing);for(let[prop,value]of this._globalTimelineStyles)this._backFill.set(prop,value||"*"),this._currentKeyframe.set(prop,"*");this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(input,easing,errors,options){easing&&this._previousKeyframe.set("easing",easing);const params=options&&options.params||{},styles=function flattenStyles(input,allStyles){const styles=new Map;let allProperties;return input.forEach((token=>{if("*"===token){allProperties??=allStyles.keys();for(let prop of allProperties)styles.set(prop,"*")}else for(let[prop,val]of token)styles.set(prop,val)})),styles}(input,this._globalTimelineStyles);for(let[prop,value]of styles){const val=interpolateParams(value,params,errors);this._pendingStyles.set(prop,val),this._localTimelineStyles.has(prop)||this._backFill.set(prop,this._globalTimelineStyles.get(prop)??"*"),this._updateStyle(prop,val)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach(((val,prop)=>{this._currentKeyframe.set(prop,val)})),this._pendingStyles.clear(),this._localTimelineStyles.forEach(((val,prop)=>{this._currentKeyframe.has(prop)||this._currentKeyframe.set(prop,val)})))}snapshotCurrentStyles(){for(let[prop,val]of this._localTimelineStyles)this._pendingStyles.set(prop,val),this._updateStyle(prop,val)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const properties=[];for(let prop in this._currentKeyframe)properties.push(prop);return properties}mergeTimelineCollectedStyles(timeline){timeline._styleSummary.forEach(((details1,prop)=>{const details0=this._styleSummary.get(prop);(!details0||details1.time>details0.time)&&this._updateStyle(prop,details1.value)}))}buildKeyframes(){this.applyStylesToKeyframe();const preStyleProps=new Set,postStyleProps=new Set,isEmpty=1===this._keyframes.size&&0===this.duration;let finalKeyframes=[];this._keyframes.forEach(((keyframe,time)=>{const finalKeyframe=new Map([...this._backFill,...keyframe]);finalKeyframe.forEach(((value,prop)=>{"!"===value?preStyleProps.add(prop):"*"===value&&postStyleProps.add(prop)})),isEmpty||finalKeyframe.set("offset",time/this.duration),finalKeyframes.push(finalKeyframe)}));const preProps=[...preStyleProps.values()],postProps=[...postStyleProps.values()];if(isEmpty){const kf0=finalKeyframes[0],kf1=new Map(kf0);kf0.set("offset",0),kf1.set("offset",1),finalKeyframes=[kf0,kf1]}return createTimelineInstruction(this.element,finalKeyframes,preProps,postProps,this.duration,this.startTime,this.easing,!1)}}class SubTimelineBuilder extends TimelineBuilder{constructor(driver,element,keyframes,preStyleProps,postStyleProps,timings,_stretchStartingKeyframe=!1){super(driver,element,timings.delay),this.keyframes=keyframes,this.preStyleProps=preStyleProps,this.postStyleProps=postStyleProps,this._stretchStartingKeyframe=_stretchStartingKeyframe,this.timings={duration:timings.duration,delay:timings.delay,easing:timings.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let keyframes=this.keyframes,{delay,duration,easing}=this.timings;if(this._stretchStartingKeyframe&&delay){const newKeyframes=[],totalTime=duration+delay,startingGap=delay/totalTime,newFirstKeyframe=new Map(keyframes[0]);newFirstKeyframe.set("offset",0),newKeyframes.push(newFirstKeyframe);const oldFirstKeyframe=new Map(keyframes[0]);oldFirstKeyframe.set("offset",roundOffset(startingGap)),newKeyframes.push(oldFirstKeyframe);const limit=keyframes.length-1;for(let i=1;i<=limit;i++){let kf=new Map(keyframes[i]);const timeAtKeyframe=delay+kf.get("offset")*duration;kf.set("offset",roundOffset(timeAtKeyframe/totalTime)),newKeyframes.push(kf)}duration=totalTime,delay=0,easing="",keyframes=newKeyframes}return createTimelineInstruction(this.element,keyframes,this.preStyleProps,this.postStyleProps,duration,delay,easing,!0)}}function roundOffset(offset,decimalPoints=3){const mult=Math.pow(10,decimalPoints-1);return Math.round(offset*mult)/mult}function createTransitionInstruction(element,triggerName,fromState,toState,isRemovalTransition,fromStyles,toStyles,timelines,queriedElements,preStyleProps,postStyleProps,totalTime,errors){return{type:0,element,triggerName,isRemovalTransition,fromState,fromStyles,toState,toStyles,timelines,queriedElements,preStyleProps,postStyleProps,totalTime,errors}}const EMPTY_OBJECT={};class AnimationTransitionFactory{constructor(_triggerName,ast,_stateStyles){this._triggerName=_triggerName,this.ast=ast,this._stateStyles=_stateStyles}match(currentState,nextState,element,params){return function oneOrMoreTransitionsMatch(matchFns,currentState,nextState,element,params){return matchFns.some((fn=>fn(currentState,nextState,element,params)))}(this.ast.matchers,currentState,nextState,element,params)}buildStyles(stateName,params,errors){let styler=this._stateStyles.get("*");return void 0!==stateName&&(styler=this._stateStyles.get(stateName?.toString())||styler),styler?styler.buildStyles(params,errors):new Map}build(driver,element,currentState,nextState,enterClassName,leaveClassName,currentOptions,nextOptions,subInstructions,skipAstBuild){const errors=[],transitionAnimationParams=this.ast.options&&this.ast.options.params||EMPTY_OBJECT,currentAnimationParams=currentOptions&&currentOptions.params||EMPTY_OBJECT,currentStateStyles=this.buildStyles(currentState,currentAnimationParams,errors),nextAnimationParams=nextOptions&&nextOptions.params||EMPTY_OBJECT,nextStateStyles=this.buildStyles(nextState,nextAnimationParams,errors),queriedElements=new Set,preStyleMap=new Map,postStyleMap=new Map,isRemoval="void"===nextState,animationOptions={params:applyParamDefaults(nextAnimationParams,transitionAnimationParams),delay:this.ast.options?.delay},timelines=skipAstBuild?[]:buildAnimationTimelines(driver,element,this.ast.animation,enterClassName,leaveClassName,currentStateStyles,nextStateStyles,animationOptions,subInstructions,errors);let totalTime=0;return timelines.forEach((tl=>{totalTime=Math.max(tl.duration+tl.delay,totalTime)})),errors.length?createTransitionInstruction(element,this._triggerName,currentState,nextState,isRemoval,currentStateStyles,nextStateStyles,[],[],preStyleMap,postStyleMap,totalTime,errors):(timelines.forEach((tl=>{const elm=tl.element,preProps=getOrSetDefaultValue(preStyleMap,elm,new Set);tl.preStyleProps.forEach((prop=>preProps.add(prop)));const postProps=getOrSetDefaultValue(postStyleMap,elm,new Set);tl.postStyleProps.forEach((prop=>postProps.add(prop))),elm!==element&&queriedElements.add(elm)})),("undefined"==typeof ngDevMode||ngDevMode)&&function checkNonAnimatableInTimelines(timelines,triggerName,driver){if(!driver.validateAnimatableStyleProperty)return;const allowedNonAnimatableProps=new Set(["easing"]),invalidNonAnimatableProps=new Set;timelines.forEach((({keyframes})=>{const nonAnimatablePropsInitialValues=new Map;keyframes.forEach((keyframe=>{const entriesToCheck=Array.from(keyframe.entries()).filter((([prop])=>!allowedNonAnimatableProps.has(prop)));for(const[prop,value]of entriesToCheck)if(!driver.validateAnimatableStyleProperty(prop))if(nonAnimatablePropsInitialValues.has(prop)&&!invalidNonAnimatableProps.has(prop)){nonAnimatablePropsInitialValues.get(prop)!==value&&invalidNonAnimatableProps.add(prop)}else nonAnimatablePropsInitialValues.set(prop,value)}))})),invalidNonAnimatableProps.size>0&&console.warn(`Warning: The animation trigger "${triggerName}" is attempting to animate the following not animatable properties: `+Array.from(invalidNonAnimatableProps).join(", ")+"\n(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)")}(timelines,this._triggerName,driver),createTransitionInstruction(element,this._triggerName,currentState,nextState,isRemoval,currentStateStyles,nextStateStyles,timelines,[...queriedElements.values()],preStyleMap,postStyleMap,totalTime))}}function applyParamDefaults(userParams,defaults){const result={...defaults};return Object.entries(userParams).forEach((([key,value])=>{null!=value&&(result[key]=value)})),result}class AnimationStateStyles{constructor(styles,defaultParams,normalizer){this.styles=styles,this.defaultParams=defaultParams,this.normalizer=normalizer}buildStyles(params,errors){const finalStyles=new Map,combinedParams=applyParamDefaults(params,this.defaultParams);return this.styles.styles.forEach((value=>{"string"!=typeof value&&value.forEach(((val,prop)=>{val&&(val=interpolateParams(val,combinedParams,errors));const normalizedProp=this.normalizer.normalizePropertyName(prop,errors);val=this.normalizer.normalizeStyleValue(prop,normalizedProp,val,errors),finalStyles.set(prop,val)}))})),finalStyles}}class AnimationTrigger{constructor(name,ast,_normalizer){this.name=name,this.ast=ast,this._normalizer=_normalizer,this.transitionFactories=[],this.states=new Map,ast.states.forEach((ast=>{const defaultParams=ast.options&&ast.options.params||{};this.states.set(ast.name,new AnimationStateStyles(ast.style,defaultParams,_normalizer))})),balanceProperties(this.states,"true","1"),balanceProperties(this.states,"false","0"),ast.transitions.forEach((ast=>{this.transitionFactories.push(new AnimationTransitionFactory(name,ast,this.states))})),this.fallbackTransition=function createFallbackTransition(triggerName,states,normalizer){const matchers=[(fromState,toState)=>!0],animation={type:AnimationMetadataType.Sequence,steps:[],options:null},transition={type:AnimationMetadataType.Transition,animation,matchers,options:null,queryCount:0,depCount:0};return new AnimationTransitionFactory(triggerName,transition,states)}(name,this.states,this._normalizer)}get containsQueries(){return this.ast.queryCount>0}matchTransition(currentState,nextState,element,params){return this.transitionFactories.find((f=>f.match(currentState,nextState,element,params)))||null}matchStyles(currentState,params,errors){return this.fallbackTransition.buildStyles(currentState,params,errors)}}function balanceProperties(stateMap,key1,key2){stateMap.has(key1)?stateMap.has(key2)||stateMap.set(key2,stateMap.get(key1)):stateMap.has(key2)&&stateMap.set(key1,stateMap.get(key2))}const EMPTY_INSTRUCTION_MAP=new ElementInstructionMap;class TimelineAnimationEngine{constructor(bodyNode,_driver,_normalizer){this.bodyNode=bodyNode,this._driver=_driver,this._normalizer=_normalizer,this._animations=new Map,this._playersById=new Map,this.players=[]}register(id,metadata){const errors=[],warnings=[],ast=buildAnimationAst(this._driver,metadata,errors,warnings);if(errors.length)throw function registerFailed(errors){return new core["ɵRuntimeError"](3503,ngDevMode&&`Unable to build the animation due to the following errors: ${errors.map((err=>err.message)).join("\n")}`)}(errors);warnings.length&&function warnRegister(warnings){("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`)}(warnings),this._animations.set(id,ast)}_buildPlayer(i,preStyles,postStyles){const element=i.element,keyframes=normalizeKeyframes$1(this._normalizer,i.keyframes,preStyles,postStyles);return this._driver.animate(element,keyframes,i.duration,i.delay,i.easing,[],!0)}create(id,element,options={}){const errors=[],ast=this._animations.get(id);let instructions;const autoStylesMap=new Map;if(ast?(instructions=buildAnimationTimelines(this._driver,element,ast,"ng-enter","ng-leave",new Map,new Map,options,EMPTY_INSTRUCTION_MAP,errors),instructions.forEach((inst=>{const styles=getOrSetDefaultValue(autoStylesMap,inst.element,new Map);inst.postStyleProps.forEach((prop=>styles.set(prop,null)))}))):(errors.push(function missingOrDestroyedAnimation(){return new core["ɵRuntimeError"](3300,ngDevMode&&"The requested animation doesn't exist or has already been destroyed")}()),instructions=[]),errors.length)throw function createAnimationFailed(errors){return new core["ɵRuntimeError"](3504,ngDevMode&&`Unable to create the animation due to the following errors:${errors.map((err=>err.message)).join("\n")}`)}(errors);autoStylesMap.forEach(((styles,element)=>{styles.forEach(((_,prop)=>{styles.set(prop,this._driver.computeStyle(element,prop,"*"))}))}));const player=optimizeGroupPlayer(instructions.map((i=>{const styles=autoStylesMap.get(i.element);return this._buildPlayer(i,new Map,styles)})));return this._playersById.set(id,player),player.onDestroy((()=>this.destroy(id))),this.players.push(player),player}destroy(id){const player=this._getPlayer(id);player.destroy(),this._playersById.delete(id);const index=this.players.indexOf(player);index>=0&&this.players.splice(index,1)}_getPlayer(id){const player=this._playersById.get(id);if(!player)throw function missingPlayer(id){return new core["ɵRuntimeError"](3301,ngDevMode&&`Unable to find the timeline player referenced by ${id}`)}(id);return player}listen(id,element,eventName,callback){const baseEvent=makeAnimationEvent(element,"","","");return listenOnPlayer(this._getPlayer(id),eventName,baseEvent,callback),()=>{}}command(id,element,command,args){if("register"==command)return void this.register(id,args[0]);if("create"==command){const options=args[0]||{};return void this.create(id,element,options)}const player=this._getPlayer(id);switch(command){case"play":player.play();break;case"pause":player.pause();break;case"reset":player.reset();break;case"restart":player.restart();break;case"finish":player.finish();break;case"init":player.init();break;case"setPosition":player.setPosition(parseFloat(args[0]));break;case"destroy":this.destroy(id)}}}const EMPTY_PLAYER_ARRAY=[],NULL_REMOVAL_STATE={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},NULL_REMOVED_QUERIED_STATE={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0};class StateValue{get params(){return this.options.params}constructor(input,namespaceId=""){this.namespaceId=namespaceId;const isObj=input&&input.hasOwnProperty("value"),value=isObj?input.value:input;if(this.value=function normalizeTriggerValue(value){return null!=value?value:null}(value),isObj){const{value,...options}=input;this.options=options}else this.options={};this.options.params||(this.options.params={})}absorbOptions(options){const newParams=options.params;if(newParams){const oldParams=this.options.params;Object.keys(newParams).forEach((prop=>{null==oldParams[prop]&&(oldParams[prop]=newParams[prop])}))}}}const DEFAULT_STATE_VALUE=new StateValue("void");class AnimationTransitionNamespace{constructor(id,hostElement,_engine){this.id=id,this.hostElement=hostElement,this._engine=_engine,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+id,addClass(hostElement,this._hostClassName)}listen(element,name,phase,callback){if(!this._triggers.has(name))throw function missingTrigger(phase,name){return new core["ɵRuntimeError"](3302,ngDevMode&&`Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn't exist!`)}(phase,name);if(null==phase||0==phase.length)throw function missingEvent(name){return new core["ɵRuntimeError"](3303,ngDevMode&&`Unable to listen on the animation trigger "${name}" because the provided event is undefined!`)}(name);if(!function isTriggerEventValid(eventName){return"start"==eventName||"done"==eventName}(phase))throw function unsupportedTriggerEvent(phase,name){return new core["ɵRuntimeError"](3400,ngDevMode&&`The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`)}(phase,name);const listeners=getOrSetDefaultValue(this._elementListeners,element,[]),data={name,phase,callback};listeners.push(data);const triggersWithStates=getOrSetDefaultValue(this._engine.statesByElement,element,new Map);return triggersWithStates.has(name)||(addClass(element,"ng-trigger"),addClass(element,"ng-trigger-"+name),triggersWithStates.set(name,DEFAULT_STATE_VALUE)),()=>{this._engine.afterFlush((()=>{const index=listeners.indexOf(data);index>=0&&listeners.splice(index,1),this._triggers.has(name)||triggersWithStates.delete(name)}))}}register(name,ast){return!this._triggers.has(name)&&(this._triggers.set(name,ast),!0)}_getTrigger(name){const trigger=this._triggers.get(name);if(!trigger)throw function unregisteredTrigger(name){return new core["ɵRuntimeError"](3401,ngDevMode&&`The provided animation trigger "${name}" has not been registered!`)}(name);return trigger}trigger(element,triggerName,value,defaultToFallback=!0){const trigger=this._getTrigger(triggerName),player=new TransitionAnimationPlayer(this.id,triggerName,element);let triggersWithStates=this._engine.statesByElement.get(element);triggersWithStates||(addClass(element,"ng-trigger"),addClass(element,"ng-trigger-"+triggerName),this._engine.statesByElement.set(element,triggersWithStates=new Map));let fromState=triggersWithStates.get(triggerName);const toState=new StateValue(value,this.id);!(value&&value.hasOwnProperty("value"))&&fromState&&toState.absorbOptions(fromState.options),triggersWithStates.set(triggerName,toState),fromState||(fromState=DEFAULT_STATE_VALUE);if(!("void"===toState.value)&&fromState.value===toState.value){if(!function objEquals(a,b){const k1=Object.keys(a),k2=Object.keys(b);if(k1.length!=k2.length)return!1;for(let i=0;i<k1.length;i++){const prop=k1[i];if(!b.hasOwnProperty(prop)||a[prop]!==b[prop])return!1}return!0}(fromState.params,toState.params)){const errors=[],fromStyles=trigger.matchStyles(fromState.value,fromState.params,errors),toStyles=trigger.matchStyles(toState.value,toState.params,errors);errors.length?this._engine.reportError(errors):this._engine.afterFlush((()=>{eraseStyles(element,fromStyles),setStyles(element,toStyles)}))}return}const playersOnElement=getOrSetDefaultValue(this._engine.playersByElement,element,[]);playersOnElement.forEach((player=>{player.namespaceId==this.id&&player.triggerName==triggerName&&player.queued&&player.destroy()}));let transition=trigger.matchTransition(fromState.value,toState.value,element,toState.params),isFallbackTransition=!1;if(!transition){if(!defaultToFallback)return;transition=trigger.fallbackTransition,isFallbackTransition=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element,triggerName,transition,fromState,toState,player,isFallbackTransition}),isFallbackTransition||(addClass(element,"ng-animate-queued"),player.onStart((()=>{removeClass(element,"ng-animate-queued")}))),player.onDone((()=>{let index=this.players.indexOf(player);index>=0&&this.players.splice(index,1);const players=this._engine.playersByElement.get(element);if(players){let index=players.indexOf(player);index>=0&&players.splice(index,1)}})),this.players.push(player),playersOnElement.push(player),player}deregister(name){this._triggers.delete(name),this._engine.statesByElement.forEach((stateMap=>stateMap.delete(name))),this._elementListeners.forEach(((listeners,element)=>{this._elementListeners.set(element,listeners.filter((entry=>entry.name!=name)))}))}clearElementCache(element){this._engine.statesByElement.delete(element),this._elementListeners.delete(element);const elementPlayers=this._engine.playersByElement.get(element);elementPlayers&&(elementPlayers.forEach((player=>player.destroy())),this._engine.playersByElement.delete(element))}_signalRemovalForInnerTriggers(rootElement,context){const elements=this._engine.driver.query(rootElement,".ng-trigger",!0);elements.forEach((elm=>{if(elm.__ng_removed)return;const namespaces=this._engine.fetchNamespacesByElement(elm);namespaces.size?namespaces.forEach((ns=>ns.triggerLeaveAnimation(elm,context,!1,!0))):this.clearElementCache(elm)})),this._engine.afterFlushAnimationsDone((()=>elements.forEach((elm=>this.clearElementCache(elm)))))}triggerLeaveAnimation(element,context,destroyAfterComplete,defaultToFallback){const triggerStates=this._engine.statesByElement.get(element),previousTriggersValues=new Map;if(triggerStates){const players=[];if(triggerStates.forEach(((state,triggerName)=>{if(previousTriggersValues.set(triggerName,state.value),this._triggers.has(triggerName)){const player=this.trigger(element,triggerName,"void",defaultToFallback);player&&players.push(player)}})),players.length)return this._engine.markElementAsRemoved(this.id,element,!0,context,previousTriggersValues),destroyAfterComplete&&optimizeGroupPlayer(players).onDone((()=>this._engine.processLeaveNode(element))),!0}return!1}prepareLeaveAnimationListeners(element){const listeners=this._elementListeners.get(element),elementStates=this._engine.statesByElement.get(element);if(listeners&&elementStates){const visitedTriggers=new Set;listeners.forEach((listener=>{const triggerName=listener.name;if(visitedTriggers.has(triggerName))return;visitedTriggers.add(triggerName);const transition=this._triggers.get(triggerName).fallbackTransition,fromState=elementStates.get(triggerName)||DEFAULT_STATE_VALUE,toState=new StateValue("void"),player=new TransitionAnimationPlayer(this.id,triggerName,element);this._engine.totalQueuedPlayers++,this._queue.push({element,triggerName,transition,fromState,toState,player,isFallbackTransition:!0})}))}}removeNode(element,context){const engine=this._engine;if(element.childElementCount&&this._signalRemovalForInnerTriggers(element,context),this.triggerLeaveAnimation(element,context,!0))return;let containsPotentialParentTransition=!1;if(engine.totalAnimations){const currentPlayers=engine.players.length?engine.playersByQueriedElement.get(element):[];if(currentPlayers&&currentPlayers.length)containsPotentialParentTransition=!0;else{let parent=element;for(;parent=parent.parentNode;){if(engine.statesByElement.get(parent)){containsPotentialParentTransition=!0;break}}}}if(this.prepareLeaveAnimationListeners(element),containsPotentialParentTransition)engine.markElementAsRemoved(this.id,element,!1,context);else{const removalFlag=element.__ng_removed;removalFlag&&removalFlag!==NULL_REMOVAL_STATE||(engine.afterFlush((()=>this.clearElementCache(element))),engine.destroyInnerAnimations(element),engine._onRemovalComplete(element,context))}}insertNode(element,parent){addClass(element,this._hostClassName)}drainQueuedTransitions(microtaskId){const instructions=[];return this._queue.forEach((entry=>{const player=entry.player;if(player.destroyed)return;const element=entry.element,listeners=this._elementListeners.get(element);listeners&&listeners.forEach((listener=>{if(listener.name==entry.triggerName){const baseEvent=makeAnimationEvent(element,entry.triggerName,entry.fromState.value,entry.toState.value);baseEvent._data=microtaskId,listenOnPlayer(entry.player,listener.phase,baseEvent,listener.callback)}})),player.markedForDestroy?this._engine.afterFlush((()=>{player.destroy()})):instructions.push(entry)})),this._queue=[],instructions.sort(((a,b)=>{const d0=a.transition.ast.depCount,d1=b.transition.ast.depCount;return 0==d0||0==d1?d0-d1:this._engine.driver.containsElement(a.element,b.element)?1:-1}))}destroy(context){this.players.forEach((p=>p.destroy())),this._signalRemovalForInnerTriggers(this.hostElement,context)}}class TransitionAnimationEngine{_onRemovalComplete(element,context){this.onRemovalComplete(element,context)}constructor(bodyNode,driver,_normalizer){this.bodyNode=bodyNode,this.driver=driver,this._normalizer=_normalizer,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(element,context)=>{}}get queuedPlayers(){const players=[];return this._namespaceList.forEach((ns=>{ns.players.forEach((player=>{player.queued&&players.push(player)}))})),players}createNamespace(namespaceId,hostElement){const ns=new AnimationTransitionNamespace(namespaceId,hostElement,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,hostElement)?this._balanceNamespaceList(ns,hostElement):(this.newHostElements.set(hostElement,ns),this.collectEnterElement(hostElement)),this._namespaceLookup[namespaceId]=ns}_balanceNamespaceList(ns,hostElement){const namespaceList=this._namespaceList,namespacesByHostElement=this.namespacesByHostElement;if(namespaceList.length-1>=0){let found=!1,ancestor=this.driver.getParentElement(hostElement);for(;ancestor;){const ancestorNs=namespacesByHostElement.get(ancestor);if(ancestorNs){const index=namespaceList.indexOf(ancestorNs);namespaceList.splice(index+1,0,ns),found=!0;break}ancestor=this.driver.getParentElement(ancestor)}found||namespaceList.unshift(ns)}else namespaceList.push(ns);return namespacesByHostElement.set(hostElement,ns),ns}register(namespaceId,hostElement){let ns=this._namespaceLookup[namespaceId];return ns||(ns=this.createNamespace(namespaceId,hostElement)),ns}registerTrigger(namespaceId,name,trigger){let ns=this._namespaceLookup[namespaceId];ns&&ns.register(name,trigger)&&this.totalAnimations++}destroy(namespaceId,context){namespaceId&&(this.afterFlush((()=>{})),this.afterFlushAnimationsDone((()=>{const ns=this._fetchNamespace(namespaceId);this.namespacesByHostElement.delete(ns.hostElement);const index=this._namespaceList.indexOf(ns);index>=0&&this._namespaceList.splice(index,1),ns.destroy(context),delete this._namespaceLookup[namespaceId]})))}_fetchNamespace(id){return this._namespaceLookup[id]}fetchNamespacesByElement(element){const namespaces=new Set,elementStates=this.statesByElement.get(element);if(elementStates)for(let stateValue of elementStates.values())if(stateValue.namespaceId){const ns=this._fetchNamespace(stateValue.namespaceId);ns&&namespaces.add(ns)}return namespaces}trigger(namespaceId,element,name,value){if(isElementNode(element)){const ns=this._fetchNamespace(namespaceId);if(ns)return ns.trigger(element,name,value),!0}return!1}insertNode(namespaceId,element,parent,insertBefore){if(!isElementNode(element))return;const details=element.__ng_removed;if(details&&details.setForRemoval){details.setForRemoval=!1,details.setForMove=!0;const index=this.collectedLeaveElements.indexOf(element);index>=0&&this.collectedLeaveElements.splice(index,1)}if(namespaceId){const ns=this._fetchNamespace(namespaceId);ns&&ns.insertNode(element,parent)}insertBefore&&this.collectEnterElement(element)}collectEnterElement(element){this.collectedEnterElements.push(element)}markElementAsDisabled(element,value){value?this.disabledNodes.has(element)||(this.disabledNodes.add(element),addClass(element,"ng-animate-disabled")):this.disabledNodes.has(element)&&(this.disabledNodes.delete(element),removeClass(element,"ng-animate-disabled"))}removeNode(namespaceId,element,context){if(isElementNode(element)){const ns=namespaceId?this._fetchNamespace(namespaceId):null;ns?ns.removeNode(element,context):this.markElementAsRemoved(namespaceId,element,!1,context);const hostNS=this.namespacesByHostElement.get(element);hostNS&&hostNS.id!==namespaceId&&hostNS.removeNode(element,context)}else this._onRemovalComplete(element,context)}markElementAsRemoved(namespaceId,element,hasAnimation,context,previousTriggersValues){this.collectedLeaveElements.push(element),element.__ng_removed={namespaceId,setForRemoval:context,hasAnimation,removedBeforeQueried:!1,previousTriggersValues}}listen(namespaceId,element,name,phase,callback){return isElementNode(element)?this._fetchNamespace(namespaceId).listen(element,name,phase,callback):()=>{}}_buildInstruction(entry,subTimelines,enterClassName,leaveClassName,skipBuildAst){return entry.transition.build(this.driver,entry.element,entry.fromState.value,entry.toState.value,enterClassName,leaveClassName,entry.fromState.options,entry.toState.options,subTimelines,skipBuildAst)}destroyInnerAnimations(containerElement){let elements=this.driver.query(containerElement,".ng-trigger",!0);elements.forEach((element=>this.destroyActiveAnimationsForElement(element))),0!=this.playersByQueriedElement.size&&(elements=this.driver.query(containerElement,".ng-animating",!0),elements.forEach((element=>this.finishActiveQueriedAnimationOnElement(element))))}destroyActiveAnimationsForElement(element){const players=this.playersByElement.get(element);players&&players.forEach((player=>{player.queued?player.markedForDestroy=!0:player.destroy()}))}finishActiveQueriedAnimationOnElement(element){const players=this.playersByQueriedElement.get(element);players&&players.forEach((player=>player.finish()))}whenRenderingDone(){return new Promise((resolve=>{if(this.players.length)return optimizeGroupPlayer(this.players).onDone((()=>resolve()));resolve()}))}processLeaveNode(element){const details=element.__ng_removed;if(details&&details.setForRemoval){if(element.__ng_removed=NULL_REMOVAL_STATE,details.namespaceId){this.destroyInnerAnimations(element);const ns=this._fetchNamespace(details.namespaceId);ns&&ns.clearElementCache(element)}this._onRemovalComplete(element,details.setForRemoval)}element.classList?.contains("ng-animate-disabled")&&this.markElementAsDisabled(element,!1),this.driver.query(element,".ng-animate-disabled",!0).forEach((node=>{this.markElementAsDisabled(node,!1)}))}flush(microtaskId=-1){let players=[];if(this.newHostElements.size&&(this.newHostElements.forEach(((ns,element)=>this._balanceNamespaceList(ns,element))),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let i=0;i<this.collectedEnterElements.length;i++){addClass(this.collectedEnterElements[i],"ng-star-inserted")}if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const cleanupFns=[];try{players=this._flushAnimations(cleanupFns,microtaskId)}finally{for(let i=0;i<cleanupFns.length;i++)cleanupFns[i]()}}else for(let i=0;i<this.collectedLeaveElements.length;i++){const element=this.collectedLeaveElements[i];this.processLeaveNode(element)}if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach((fn=>fn())),this._flushFns=[],this._whenQuietFns.length){const quietFns=this._whenQuietFns;this._whenQuietFns=[],players.length?optimizeGroupPlayer(players).onDone((()=>{quietFns.forEach((fn=>fn()))})):quietFns.forEach((fn=>fn()))}}reportError(errors){throw function triggerTransitionsFailed(errors){return new core["ɵRuntimeError"](3402,ngDevMode&&`Unable to process animations due to the following failed trigger transitions\n ${errors.map((err=>err.message)).join("\n")}`)}(errors)}_flushAnimations(cleanupFns,microtaskId){const subTimelines=new ElementInstructionMap,skippedPlayers=[],skippedPlayersMap=new Map,queuedInstructions=[],queriedElements=new Map,allPreStyleElements=new Map,allPostStyleElements=new Map,disabledElementsSet=new Set;this.disabledNodes.forEach((node=>{disabledElementsSet.add(node);const nodesThatAreDisabled=this.driver.query(node,".ng-animate-queued",!0);for(let i=0;i<nodesThatAreDisabled.length;i++)disabledElementsSet.add(nodesThatAreDisabled[i])}));const bodyNode=this.bodyNode,allTriggerElements=Array.from(this.statesByElement.keys()),enterNodeMap=buildRootMap(allTriggerElements,this.collectedEnterElements),enterNodeMapIds=new Map;let i=0;enterNodeMap.forEach(((nodes,root)=>{const className="ng-enter"+i++;enterNodeMapIds.set(root,className),nodes.forEach((node=>addClass(node,className)))}));const allLeaveNodes=[],mergedLeaveNodes=new Set,leaveNodesWithoutAnimations=new Set;for(let i=0;i<this.collectedLeaveElements.length;i++){const element=this.collectedLeaveElements[i],details=element.__ng_removed;details&&details.setForRemoval&&(allLeaveNodes.push(element),mergedLeaveNodes.add(element),details.hasAnimation?this.driver.query(element,".ng-star-inserted",!0).forEach((elm=>mergedLeaveNodes.add(elm))):leaveNodesWithoutAnimations.add(element))}const leaveNodeMapIds=new Map,leaveNodeMap=buildRootMap(allTriggerElements,Array.from(mergedLeaveNodes));leaveNodeMap.forEach(((nodes,root)=>{const className="ng-leave"+i++;leaveNodeMapIds.set(root,className),nodes.forEach((node=>addClass(node,className)))})),cleanupFns.push((()=>{enterNodeMap.forEach(((nodes,root)=>{const className=enterNodeMapIds.get(root);nodes.forEach((node=>removeClass(node,className)))})),leaveNodeMap.forEach(((nodes,root)=>{const className=leaveNodeMapIds.get(root);nodes.forEach((node=>removeClass(node,className)))})),allLeaveNodes.forEach((element=>{this.processLeaveNode(element)}))}));const allPlayers=[],erroneousTransitions=[];for(let i=this._namespaceList.length-1;i>=0;i--){this._namespaceList[i].drainQueuedTransitions(microtaskId).forEach((entry=>{const player=entry.player,element=entry.element;if(allPlayers.push(player),this.collectedEnterElements.length){const details=element.__ng_removed;if(details&&details.setForMove){if(details.previousTriggersValues&&details.previousTriggersValues.has(entry.triggerName)){const previousValue=details.previousTriggersValues.get(entry.triggerName),triggersWithStates=this.statesByElement.get(entry.element);if(triggersWithStates&&triggersWithStates.has(entry.triggerName)){const state=triggersWithStates.get(entry.triggerName);state.value=previousValue,triggersWithStates.set(entry.triggerName,state)}}return void player.destroy()}}const nodeIsOrphaned=!bodyNode||!this.driver.containsElement(bodyNode,element),leaveClassName=leaveNodeMapIds.get(element),enterClassName=enterNodeMapIds.get(element),instruction=this._buildInstruction(entry,subTimelines,enterClassName,leaveClassName,nodeIsOrphaned);if(instruction.errors&&instruction.errors.length)return void erroneousTransitions.push(instruction);if(nodeIsOrphaned)return player.onStart((()=>eraseStyles(element,instruction.fromStyles))),player.onDestroy((()=>setStyles(element,instruction.toStyles))),void skippedPlayers.push(player);if(entry.isFallbackTransition)return player.onStart((()=>eraseStyles(element,instruction.fromStyles))),player.onDestroy((()=>setStyles(element,instruction.toStyles))),void skippedPlayers.push(player);const timelines=[];instruction.timelines.forEach((tl=>{tl.stretchStartingKeyframe=!0,this.disabledNodes.has(tl.element)||timelines.push(tl)})),instruction.timelines=timelines,subTimelines.append(element,instruction.timelines);const tuple={instruction,player,element};queuedInstructions.push(tuple),instruction.queriedElements.forEach((element=>getOrSetDefaultValue(queriedElements,element,[]).push(player))),instruction.preStyleProps.forEach(((stringMap,element)=>{if(stringMap.size){let setVal=allPreStyleElements.get(element);setVal||allPreStyleElements.set(element,setVal=new Set),stringMap.forEach(((_,prop)=>setVal.add(prop)))}})),instruction.postStyleProps.forEach(((stringMap,element)=>{let setVal=allPostStyleElements.get(element);setVal||allPostStyleElements.set(element,setVal=new Set),stringMap.forEach(((_,prop)=>setVal.add(prop)))}))}))}if(erroneousTransitions.length){const errors=[];erroneousTransitions.forEach((instruction=>{errors.push(function transitionFailed(name,errors){return new core["ɵRuntimeError"](3505,ngDevMode&&`@${name} has failed due to:\n ${errors.map((err=>err.message)).join("\n- ")}`)}(instruction.triggerName,instruction.errors))})),allPlayers.forEach((player=>player.destroy())),this.reportError(errors)}const allPreviousPlayersMap=new Map,animationElementMap=new Map;queuedInstructions.forEach((entry=>{const element=entry.element;subTimelines.has(element)&&(animationElementMap.set(element,element),this._beforeAnimationBuild(entry.player.namespaceId,entry.instruction,allPreviousPlayersMap))})),skippedPlayers.forEach((player=>{const element=player.element;this._getPreviousPlayers(element,!1,player.namespaceId,player.triggerName,null).forEach((prevPlayer=>{getOrSetDefaultValue(allPreviousPlayersMap,element,[]).push(prevPlayer),prevPlayer.destroy()}))}));const replaceNodes=allLeaveNodes.filter((node=>replacePostStylesAsPre(node,allPreStyleElements,allPostStyleElements))),postStylesMap=new Map;cloakAndComputeStyles(postStylesMap,this.driver,leaveNodesWithoutAnimations,allPostStyleElements,"*").forEach((node=>{replacePostStylesAsPre(node,allPreStyleElements,allPostStyleElements)&&replaceNodes.push(node)}));const preStylesMap=new Map;enterNodeMap.forEach(((nodes,root)=>{cloakAndComputeStyles(preStylesMap,this.driver,new Set(nodes),allPreStyleElements,"!")})),replaceNodes.forEach((node=>{const post=postStylesMap.get(node),pre=preStylesMap.get(node);postStylesMap.set(node,new Map([...post?.entries()??[],...pre?.entries()??[]]))}));const rootPlayers=[],subPlayers=[],NO_PARENT_ANIMATION_ELEMENT_DETECTED={};queuedInstructions.forEach((entry=>{const{element,player,instruction}=entry;if(subTimelines.has(element)){if(disabledElementsSet.has(element))return player.onDestroy((()=>setStyles(element,instruction.toStyles))),player.disabled=!0,player.overrideTotalTime(instruction.totalTime),void skippedPlayers.push(player);let parentWithAnimation=NO_PARENT_ANIMATION_ELEMENT_DETECTED;if(animationElementMap.size>1){let elm=element;const parentsToAdd=[];for(;elm=elm.parentNode;){const detectedParent=animationElementMap.get(elm);if(detectedParent){parentWithAnimation=detectedParent;break}parentsToAdd.push(elm)}parentsToAdd.forEach((parent=>animationElementMap.set(parent,parentWithAnimation)))}const innerPlayer=this._buildAnimation(player.namespaceId,instruction,allPreviousPlayersMap,skippedPlayersMap,preStylesMap,postStylesMap);if(player.setRealPlayer(innerPlayer),parentWithAnimation===NO_PARENT_ANIMATION_ELEMENT_DETECTED)rootPlayers.push(player);else{const parentPlayers=this.playersByElement.get(parentWithAnimation);parentPlayers&&parentPlayers.length&&(player.parentPlayer=optimizeGroupPlayer(parentPlayers)),skippedPlayers.push(player)}}else eraseStyles(element,instruction.fromStyles),player.onDestroy((()=>setStyles(element,instruction.toStyles))),subPlayers.push(player),disabledElementsSet.has(element)&&skippedPlayers.push(player)})),subPlayers.forEach((player=>{const playersForElement=skippedPlayersMap.get(player.element);if(playersForElement&&playersForElement.length){const innerPlayer=optimizeGroupPlayer(playersForElement);player.setRealPlayer(innerPlayer)}})),skippedPlayers.forEach((player=>{player.parentPlayer?player.syncPlayerEvents(player.parentPlayer):player.destroy()}));for(let i=0;i<allLeaveNodes.length;i++){const element=allLeaveNodes[i],details=element.__ng_removed;if(removeClass(element,"ng-leave"),details&&details.hasAnimation)continue;let players=[];if(queriedElements.size){let queriedPlayerResults=queriedElements.get(element);queriedPlayerResults&&queriedPlayerResults.length&&players.push(...queriedPlayerResults);let queriedInnerElements=this.driver.query(element,".ng-animating",!0);for(let j=0;j<queriedInnerElements.length;j++){let queriedPlayers=queriedElements.get(queriedInnerElements[j]);queriedPlayers&&queriedPlayers.length&&players.push(...queriedPlayers)}}const activePlayers=players.filter((p=>!p.destroyed));activePlayers.length?removeNodesAfterAnimationDone(this,element,activePlayers):this.processLeaveNode(element)}return allLeaveNodes.length=0,rootPlayers.forEach((player=>{this.players.push(player),player.onDone((()=>{player.destroy();const index=this.players.indexOf(player);this.players.splice(index,1)})),player.play()})),rootPlayers}afterFlush(callback){this._flushFns.push(callback)}afterFlushAnimationsDone(callback){this._whenQuietFns.push(callback)}_getPreviousPlayers(element,isQueriedElement,namespaceId,triggerName,toStateValue){let players=[];if(isQueriedElement){const queriedElementPlayers=this.playersByQueriedElement.get(element);queriedElementPlayers&&(players=queriedElementPlayers)}else{const elementPlayers=this.playersByElement.get(element);if(elementPlayers){const isRemovalAnimation=!toStateValue||"void"==toStateValue;elementPlayers.forEach((player=>{player.queued||(isRemovalAnimation||player.triggerName==triggerName)&&players.push(player)}))}}return(namespaceId||triggerName)&&(players=players.filter((player=>(!namespaceId||namespaceId==player.namespaceId)&&(!triggerName||triggerName==player.triggerName)))),players}_beforeAnimationBuild(namespaceId,instruction,allPreviousPlayersMap){const triggerName=instruction.triggerName,rootElement=instruction.element,targetNameSpaceId=instruction.isRemovalTransition?void 0:namespaceId,targetTriggerName=instruction.isRemovalTransition?void 0:triggerName;for(const timelineInstruction of instruction.timelines){const element=timelineInstruction.element,isQueriedElement=element!==rootElement,players=getOrSetDefaultValue(allPreviousPlayersMap,element,[]);this._getPreviousPlayers(element,isQueriedElement,targetNameSpaceId,targetTriggerName,instruction.toState).forEach((player=>{const realPlayer=player.getRealPlayer();realPlayer.beforeDestroy&&realPlayer.beforeDestroy(),player.destroy(),players.push(player)}))}eraseStyles(rootElement,instruction.fromStyles)}_buildAnimation(namespaceId,instruction,allPreviousPlayersMap,skippedPlayersMap,preStylesMap,postStylesMap){const triggerName=instruction.triggerName,rootElement=instruction.element,allQueriedPlayers=[],allConsumedElements=new Set,allSubElements=new Set,allNewPlayers=instruction.timelines.map((timelineInstruction=>{const element=timelineInstruction.element;allConsumedElements.add(element);const details=element.__ng_removed;if(details&&details.removedBeforeQueried)return new NoopAnimationPlayer(timelineInstruction.duration,timelineInstruction.delay);const isQueriedElement=element!==rootElement,previousPlayers=function flattenGroupPlayers(players){const finalPlayers=[];return _flattenGroupPlayersRecur(players,finalPlayers),finalPlayers}((allPreviousPlayersMap.get(element)||EMPTY_PLAYER_ARRAY).map((p=>p.getRealPlayer()))).filter((p=>{const pp=p;return!!pp.element&&pp.element===element})),preStyles=preStylesMap.get(element),postStyles=postStylesMap.get(element),keyframes=normalizeKeyframes$1(this._normalizer,timelineInstruction.keyframes,preStyles,postStyles),player=this._buildPlayer(timelineInstruction,keyframes,previousPlayers);if(timelineInstruction.subTimeline&&skippedPlayersMap&&allSubElements.add(element),isQueriedElement){const wrappedPlayer=new TransitionAnimationPlayer(namespaceId,triggerName,element);wrappedPlayer.setRealPlayer(player),allQueriedPlayers.push(wrappedPlayer)}return player}));allQueriedPlayers.forEach((player=>{getOrSetDefaultValue(this.playersByQueriedElement,player.element,[]).push(player),player.onDone((()=>function deleteOrUnsetInMap(map,key,value){let currentValues=map.get(key);if(currentValues){if(currentValues.length){const index=currentValues.indexOf(value);currentValues.splice(index,1)}0==currentValues.length&&map.delete(key)}return currentValues}(this.playersByQueriedElement,player.element,player)))})),allConsumedElements.forEach((element=>addClass(element,"ng-animating")));const player=optimizeGroupPlayer(allNewPlayers);return player.onDestroy((()=>{allConsumedElements.forEach((element=>removeClass(element,"ng-animating"))),setStyles(rootElement,instruction.toStyles)})),allSubElements.forEach((element=>{getOrSetDefaultValue(skippedPlayersMap,element,[]).push(player)})),player}_buildPlayer(instruction,keyframes,previousPlayers){return keyframes.length>0?this.driver.animate(instruction.element,keyframes,instruction.duration,instruction.delay,instruction.easing,previousPlayers):new NoopAnimationPlayer(instruction.duration,instruction.delay)}}class TransitionAnimationPlayer{constructor(namespaceId,triggerName,element){this.namespaceId=namespaceId,this.triggerName=triggerName,this.element=element,this._player=new NoopAnimationPlayer,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.parentPlayer=null,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(player){this._containsRealPlayer||(this._player=player,this._queuedCallbacks.forEach(((callbacks,phase)=>{callbacks.forEach((callback=>listenOnPlayer(player,phase,void 0,callback)))})),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(player.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(totalTime){this.totalTime=totalTime}syncPlayerEvents(player){const p=this._player;p.triggerCallback&&player.onStart((()=>p.triggerCallback("start"))),player.onDone((()=>this.finish())),player.onDestroy((()=>this.destroy()))}_queueEvent(name,callback){getOrSetDefaultValue(this._queuedCallbacks,name,[]).push(callback)}onDone(fn){this.queued&&this._queueEvent("done",fn),this._player.onDone(fn)}onStart(fn){this.queued&&this._queueEvent("start",fn),this._player.onStart(fn)}onDestroy(fn){this.queued&&this._queueEvent("destroy",fn),this._player.onDestroy(fn)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(p){this.queued||this._player.setPosition(p)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(phaseName){const p=this._player;p.triggerCallback&&p.triggerCallback(phaseName)}}function isElementNode(node){return node&&1===node.nodeType}function cloakElement(element,value){const oldValue=element.style.display;return element.style.display=null!=value?value:"none",oldValue}function cloakAndComputeStyles(valuesMap,driver,elements,elementPropsMap,defaultStyle){const cloakVals=[];elements.forEach((element=>cloakVals.push(cloakElement(element))));const failedElements=[];elementPropsMap.forEach(((props,element)=>{const styles=new Map;props.forEach((prop=>{const value=driver.computeStyle(element,prop,defaultStyle);styles.set(prop,value),value&&0!=value.length||(element.__ng_removed=NULL_REMOVED_QUERIED_STATE,failedElements.push(element))})),valuesMap.set(element,styles)}));let i=0;return elements.forEach((element=>cloakElement(element,cloakVals[i++]))),failedElements}function buildRootMap(roots,nodes){const rootMap=new Map;if(roots.forEach((root=>rootMap.set(root,[]))),0==nodes.length)return rootMap;const nodeSet=new Set(nodes),localRootMap=new Map;function getRoot(node){if(!node)return 1;let root=localRootMap.get(node);if(root)return root;const parent=node.parentNode;return root=rootMap.has(parent)?parent:nodeSet.has(parent)?1:getRoot(parent),localRootMap.set(node,root),root}return nodes.forEach((node=>{const root=getRoot(node);1!==root&&rootMap.get(root).push(node)})),rootMap}function addClass(element,className){element.classList?.add(className)}function removeClass(element,className){element.classList?.remove(className)}function removeNodesAfterAnimationDone(engine,element,players){optimizeGroupPlayer(players).onDone((()=>engine.processLeaveNode(element)))}function _flattenGroupPlayersRecur(players,finalPlayers){for(let i=0;i<players.length;i++){const player=players[i];player instanceof AnimationGroupPlayer?_flattenGroupPlayersRecur(player.players,finalPlayers):finalPlayers.push(player)}}function replacePostStylesAsPre(element,allPreStyleElements,allPostStyleElements){const postEntry=allPostStyleElements.get(element);if(!postEntry)return!1;let preEntry=allPreStyleElements.get(element);return preEntry?postEntry.forEach((data=>preEntry.add(data))):allPreStyleElements.set(element,postEntry),allPostStyleElements.delete(element),!0}class AnimationEngine{constructor(doc,_driver,_normalizer){this._driver=_driver,this._normalizer=_normalizer,this._triggerCache={},this.onRemovalComplete=(element,context)=>{},this._transitionEngine=new TransitionAnimationEngine(doc.body,_driver,_normalizer),this._timelineEngine=new TimelineAnimationEngine(doc.body,_driver,_normalizer),this._transitionEngine.onRemovalComplete=(element,context)=>this.onRemovalComplete(element,context)}registerTrigger(componentId,namespaceId,hostElement,name,metadata){const cacheKey=componentId+"-"+name;let trigger=this._triggerCache[cacheKey];if(!trigger){const errors=[],warnings=[],ast=buildAnimationAst(this._driver,metadata,errors,warnings);if(errors.length)throw function triggerBuildFailed(name,errors){return new core["ɵRuntimeError"](3404,ngDevMode&&`The animation trigger "${name}" has failed to build due to the following errors:\n - ${errors.map((err=>err.message)).join("\n - ")}`)}(name,errors);warnings.length&&function warnTriggerBuild(name,warnings){("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(`The animation trigger "${name}" has built with the following warnings:${createListOfWarnings(warnings)}`)}(name,warnings),trigger=function buildTrigger(name,ast,normalizer){return new AnimationTrigger(name,ast,normalizer)}(name,ast,this._normalizer),this._triggerCache[cacheKey]=trigger}this._transitionEngine.registerTrigger(namespaceId,name,trigger)}register(namespaceId,hostElement){this._transitionEngine.register(namespaceId,hostElement)}destroy(namespaceId,context){this._transitionEngine.destroy(namespaceId,context)}onInsert(namespaceId,element,parent,insertBefore){this._transitionEngine.insertNode(namespaceId,element,parent,insertBefore)}onRemove(namespaceId,element,context){this._transitionEngine.removeNode(namespaceId,element,context)}disableAnimations(element,disable){this._transitionEngine.markElementAsDisabled(element,disable)}process(namespaceId,element,property,value){if("@"==property.charAt(0)){const[id,action]=parseTimelineCommand(property),args=value;this._timelineEngine.command(id,element,action,args)}else this._transitionEngine.trigger(namespaceId,element,property,value)}listen(namespaceId,element,eventName,eventPhase,callback){if("@"==eventName.charAt(0)){const[id,action]=parseTimelineCommand(eventName);return this._timelineEngine.listen(id,element,action,callback)}return this._transitionEngine.listen(namespaceId,element,eventName,eventPhase,callback)}flush(microtaskId=-1){this._transitionEngine.flush(microtaskId)}get players(){return[...this._transitionEngine.players,...this._timelineEngine.players]}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}afterFlushAnimationsDone(cb){this._transitionEngine.afterFlushAnimationsDone(cb)}}class SpecialCasedStyles{static{this.initialStylesByElement=new WeakMap}constructor(_element,_startStyles,_endStyles){this._element=_element,this._startStyles=_startStyles,this._endStyles=_endStyles,this._state=0;let initialStyles=SpecialCasedStyles.initialStylesByElement.get(_element);initialStyles||SpecialCasedStyles.initialStylesByElement.set(_element,initialStyles=new Map),this._initialStyles=initialStyles}start(){this._state<1&&(this._startStyles&&setStyles(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(setStyles(this._element,this._initialStyles),this._endStyles&&(setStyles(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(SpecialCasedStyles.initialStylesByElement.delete(this._element),this._startStyles&&(eraseStyles(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(eraseStyles(this._element,this._endStyles),this._endStyles=null),setStyles(this._element,this._initialStyles),this._state=3)}}function filterNonAnimatableStyles(styles){let result=null;return styles.forEach(((val,prop)=>{(function isNonAnimatableStyle(prop){return"display"===prop||"position"===prop})(prop)&&(result=result||new Map,result.set(prop,val))})),result}class WebAnimationsPlayer{constructor(element,keyframes,options,_specialStyles){this.element=element,this.keyframes=keyframes,this.options=options,this._specialStyles=_specialStyles,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=options.duration,this._delay=options.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach((fn=>fn())),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const keyframes=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,keyframes,this.options),this._finalKeyframe=keyframes.length?keyframes[keyframes.length-1]:new Map;const onFinish=()=>this._onFinish();this.domPlayer.addEventListener("finish",onFinish),this.onDestroy((()=>{this.domPlayer.removeEventListener("finish",onFinish)}))}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(keyframes){const kfs=[];return keyframes.forEach((frame=>{kfs.push(Object.fromEntries(frame))})),kfs}_triggerWebAnimation(element,keyframes,options){return element.animate(this._convertKeyframesToObject(keyframes),options)}onStart(fn){this._originalOnStartFns.push(fn),this._onStartFns.push(fn)}onDone(fn){this._originalOnDoneFns.push(fn),this._onDoneFns.push(fn)}onDestroy(fn){this._onDestroyFns.push(fn)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach((fn=>fn())),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach((fn=>fn())),this._onDestroyFns=[])}setPosition(p){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=p*this.time}getPosition(){return+(this.domPlayer.currentTime??0)/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const styles=new Map;if(this.hasStarted()){this._finalKeyframe.forEach(((val,prop)=>{"offset"!==prop&&styles.set(prop,this._finished?val:computeStyle(this.element,prop))}))}this.currentSnapshot=styles}triggerCallback(phaseName){const methods="start"===phaseName?this._onStartFns:this._onDoneFns;methods.forEach((fn=>fn())),methods.length=0}}class WebAnimationsDriver{validateStyleProperty(prop){return"undefined"!=typeof ngDevMode&&!ngDevMode||validateStyleProperty(prop)}validateAnimatableStyleProperty(prop){if("undefined"==typeof ngDevMode||ngDevMode){return function validateWebAnimatableStyleProperty(prop){return ANIMATABLE_PROP_SET.has(prop)}(function camelCaseToDashCase(input){return input.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}(prop))}return!0}containsElement(elm1,elm2){return containsElement(elm1,elm2)}getParentElement(element){return getParentElement(element)}query(element,selector,multi){return invokeQuery(element,selector,multi)}computeStyle(element,prop,defaultValue){return computeStyle(element,prop)}animate(element,keyframes,duration,delay,easing,previousPlayers=[]){const playerOptions={duration,delay,fill:0==delay?"both":"forwards"};easing&&(playerOptions.easing=easing);const previousStyles=new Map,previousWebAnimationPlayers=previousPlayers.filter((player=>player instanceof WebAnimationsPlayer));(function allowPreviousPlayerStylesMerge(duration,delay){return 0===duration||0===delay})(duration,delay)&&previousWebAnimationPlayers.forEach((player=>{player.currentSnapshot.forEach(((val,prop)=>previousStyles.set(prop,val)))}));let _keyframes=function normalizeKeyframes(keyframes){return keyframes.length?keyframes[0]instanceof Map?keyframes:keyframes.map((kf=>new Map(Object.entries(kf)))):[]}(keyframes).map((styles=>new Map(styles)));_keyframes=function balancePreviousStylesIntoKeyframes(element,keyframes,previousStyles){if(previousStyles.size&&keyframes.length){let startingKeyframe=keyframes[0],missingStyleProps=[];if(previousStyles.forEach(((val,prop)=>{startingKeyframe.has(prop)||missingStyleProps.push(prop),startingKeyframe.set(prop,val)})),missingStyleProps.length)for(let i=1;i<keyframes.length;i++){let kf=keyframes[i];missingStyleProps.forEach((prop=>kf.set(prop,computeStyle(element,prop))))}}return keyframes}(element,_keyframes,previousStyles);const specialStyles=function packageNonAnimatableStyles(element,styles){let startStyles=null,endStyles=null;return Array.isArray(styles)&&styles.length?(startStyles=filterNonAnimatableStyles(styles[0]),styles.length>1&&(endStyles=filterNonAnimatableStyles(styles[styles.length-1]))):styles instanceof Map&&(startStyles=filterNonAnimatableStyles(styles)),startStyles||endStyles?new SpecialCasedStyles(element,startStyles,endStyles):null}(element,_keyframes);return new WebAnimationsPlayer(element,_keyframes,playerOptions,specialStyles)}}class BaseAnimationRenderer{constructor(namespaceId,delegate,engine,_onDestroy){this.namespaceId=namespaceId,this.delegate=delegate,this.engine=engine,this._onDestroy=_onDestroy,this.ɵtype=0}get data(){return this.delegate.data}destroyNode(node){this.delegate.destroyNode?.(node)}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.engine.afterFlushAnimationsDone((()=>{queueMicrotask((()=>{this.delegate.destroy()}))})),this._onDestroy?.()}createElement(name,namespace){return this.delegate.createElement(name,namespace)}createComment(value){return this.delegate.createComment(value)}createText(value){return this.delegate.createText(value)}appendChild(parent,newChild){this.delegate.appendChild(parent,newChild),this.engine.onInsert(this.namespaceId,newChild,parent,!1)}insertBefore(parent,newChild,refChild,isMove=!0){this.delegate.insertBefore(parent,newChild,refChild),this.engine.onInsert(this.namespaceId,newChild,parent,isMove)}removeChild(parent,oldChild,isHostElement){this.parentNode(oldChild)&&this.engine.onRemove(this.namespaceId,oldChild,this.delegate)}selectRootElement(selectorOrNode,preserveContent){return this.delegate.selectRootElement(selectorOrNode,preserveContent)}parentNode(node){return this.delegate.parentNode(node)}nextSibling(node){return this.delegate.nextSibling(node)}setAttribute(el,name,value,namespace){this.delegate.setAttribute(el,name,value,namespace)}removeAttribute(el,name,namespace){this.delegate.removeAttribute(el,name,namespace)}addClass(el,name){this.delegate.addClass(el,name)}removeClass(el,name){this.delegate.removeClass(el,name)}setStyle(el,style,value,flags){this.delegate.setStyle(el,style,value,flags)}removeStyle(el,style,flags){this.delegate.removeStyle(el,style,flags)}setProperty(el,name,value){"@"==name.charAt(0)&&"@.disabled"==name?this.disableAnimations(el,!!value):this.delegate.setProperty(el,name,value)}setValue(node,value){this.delegate.setValue(node,value)}listen(target,eventName,callback){return this.delegate.listen(target,eventName,callback)}disableAnimations(element,value){this.engine.disableAnimations(element,value)}}class AnimationRenderer extends BaseAnimationRenderer{constructor(factory,namespaceId,delegate,engine,onDestroy){super(namespaceId,delegate,engine,onDestroy),this.factory=factory,this.namespaceId=namespaceId}setProperty(el,name,value){"@"==name.charAt(0)?"."==name.charAt(1)&&"@.disabled"==name?(value=void 0===value||!!value,this.disableAnimations(el,value)):this.engine.process(this.namespaceId,el,name.slice(1),value):this.delegate.setProperty(el,name,value)}listen(target,eventName,callback){if("@"==eventName.charAt(0)){const element=function resolveElementFromTarget(target){switch(target){case"body":return document.body;case"document":return document;case"window":return window;default:return target}}(target);let name=eventName.slice(1),phase="";return"@"!=name.charAt(0)&&([name,phase]=function parseTriggerCallbackName(triggerName){const dotIndex=triggerName.indexOf("."),trigger=triggerName.substring(0,dotIndex),phase=triggerName.slice(dotIndex+1);return[trigger,phase]}(name)),this.engine.listen(this.namespaceId,element,name,phase,(event=>{const countId=event._data||-1;this.factory.scheduleListenerCallback(countId,callback,event)}))}return this.delegate.listen(target,eventName,callback)}}class AnimationRendererFactory{constructor(delegate,engine,_zone){this.delegate=delegate,this.engine=engine,this._zone=_zone,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,engine.onRemovalComplete=(element,delegate)=>{delegate?.removeChild(null,element)}}createRenderer(hostElement,type){const delegate=this.delegate.createRenderer(hostElement,type);if(!hostElement||!type?.data?.animation){const cache=this._rendererCache;let renderer=cache.get(delegate);if(!renderer){const onRendererDestroy=()=>cache.delete(delegate);renderer=new BaseAnimationRenderer("",delegate,this.engine,onRendererDestroy),cache.set(delegate,renderer)}return renderer}const componentId=type.id,namespaceId=type.id+"-"+this._currentId;this._currentId++,this.engine.register(namespaceId,hostElement);const registerTrigger=trigger=>{Array.isArray(trigger)?trigger.forEach(registerTrigger):this.engine.registerTrigger(componentId,namespaceId,hostElement,trigger.name,trigger)};return type.data.animation.forEach(registerTrigger),new AnimationRenderer(this,namespaceId,delegate,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){queueMicrotask((()=>{this._microtaskId++}))}scheduleListenerCallback(count,fn,data){if(count>=0&&count<this._microtaskId)return void this._zone.run((()=>fn(data)));const animationCallbacksBuffer=this._animationCallbacksBuffer;0==animationCallbacksBuffer.length&&queueMicrotask((()=>{this._zone.run((()=>{animationCallbacksBuffer.forEach((tuple=>{const[fn,data]=tuple;fn(data)})),this._animationCallbacksBuffer=[]}))})),animationCallbacksBuffer.push([fn,data])}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular((()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)})),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}class InjectableAnimationEngine extends AnimationEngine{constructor(doc,driver,normalizer){super(doc,driver,normalizer)}ngOnDestroy(){this.flush()}static{this.ɵfac=function InjectableAnimationEngine_Factory(__ngFactoryType__){return new(__ngFactoryType__||InjectableAnimationEngine)(core["ɵɵinject"](common.qQ),core["ɵɵinject"](AnimationDriver),core["ɵɵinject"](AnimationStyleNormalizer))}}static{this.ɵprov=core["ɵɵdefineInjectable"]({token:InjectableAnimationEngine,factory:InjectableAnimationEngine.ɵfac})}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](InjectableAnimationEngine,[{type:core.Injectable}],(()=>[{type:Document,decorators:[{type:core.Inject,args:[common.qQ]}]},{type:AnimationDriver},{type:AnimationStyleNormalizer}]),null);const SHARED_ANIMATION_PROVIDERS=[{provide:AnimationStyleNormalizer,useFactory:function instantiateDefaultStyleNormalizer(){return new WebAnimationsStyleNormalizer}},{provide:AnimationEngine,useClass:InjectableAnimationEngine},{provide:core.RendererFactory2,useFactory:function instantiateRendererFactory(renderer,engine,zone){return new AnimationRendererFactory(renderer,engine,zone)},deps:[platform_browser.B7,AnimationEngine,core.NgZone]}],BROWSER_ANIMATIONS_PROVIDERS=[{provide:AnimationDriver,useFactory:()=>new WebAnimationsDriver},{provide:core.ANIMATION_MODULE_TYPE,useValue:"BrowserAnimations"},...SHARED_ANIMATION_PROVIDERS],BROWSER_NOOP_ANIMATIONS_PROVIDERS=[{provide:AnimationDriver,useClass:NoopAnimationDriver},{provide:core.ANIMATION_MODULE_TYPE,useValue:"NoopAnimations"},...SHARED_ANIMATION_PROVIDERS];class BrowserAnimationsModule{static withConfig(config){return{ngModule:BrowserAnimationsModule,providers:config.disableAnimations?BROWSER_NOOP_ANIMATIONS_PROVIDERS:BROWSER_ANIMATIONS_PROVIDERS}}static{this.ɵfac=function BrowserAnimationsModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||BrowserAnimationsModule)}}static{this.ɵmod=core["ɵɵdefineNgModule"]({type:BrowserAnimationsModule,exports:[platform_browser.Bb]})}static{this.ɵinj=core["ɵɵdefineInjector"]({providers:BROWSER_ANIMATIONS_PROVIDERS,imports:[platform_browser.Bb]})}}function provideAnimations(){return(0,core["ɵperformanceMarkFeature"])("NgEagerAnimations"),[...BROWSER_ANIMATIONS_PROVIDERS]}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](BrowserAnimationsModule,[{type:core.NgModule,args:[{exports:[platform_browser.Bb],providers:BROWSER_ANIMATIONS_PROVIDERS}]}],null,null);class NoopAnimationsModule{static{this.ɵfac=function NoopAnimationsModule_Factory(__ngFactoryType__){return new(__ngFactoryType__||NoopAnimationsModule)}}static{this.ɵmod=core["ɵɵdefineNgModule"]({type:NoopAnimationsModule,exports:[platform_browser.Bb]})}static{this.ɵinj=core["ɵɵdefineInjector"]({providers:BROWSER_NOOP_ANIMATIONS_PROVIDERS,imports:[platform_browser.Bb]})}}function provideNoopAnimations(){return[...BROWSER_NOOP_ANIMATIONS_PROVIDERS]}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](NoopAnimationsModule,[{type:core.NgModule,args:[{exports:[platform_browser.Bb],providers:BROWSER_NOOP_ANIMATIONS_PROVIDERS}]}],null,null)}}]);